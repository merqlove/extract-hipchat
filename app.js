/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	window.HC = {
	  Actions: __webpack_require__(14),
	  AppDispatcher: __webpack_require__(1),
	  ApplicationStore: __webpack_require__(2),
	  AppConfig: __webpack_require__(3),
	  Utils: __webpack_require__(4),
	  Emoticons: __webpack_require__(5),
	  Rehacked: __webpack_require__(6),
	  ENV: ("production")
	};

	$(document).trigger("hc.ready", window.HC);

	(function () {
	  var HipChat = __webpack_require__(17),
	      AppDispatcher = __webpack_require__(1),
	      AnalyticsDispatcher = __webpack_require__(7),
	      HCApiDispatcher = __webpack_require__(8),
	      APIV2 = __webpack_require__(9),
	      uploader = __webpack_require__(10),
	      MainLayout = __webpack_require__(15),
	      initState = $("body").data("init-state"),
	      features = $("body").data("features"),
	      utils = __webpack_require__(4),
	      KeyboardShortcuts = __webpack_require__(11);

	  __webpack_require__(12)(initState);
	  KeyboardShortcuts.init(navigator.platform);

	  // Don't hold up rendering for data
	  React.render(React.createElement(MainLayout, null), document.getElementById("hipchat"));

	  $(window).on("beforeunload", function () {
	    AppDispatcher.dispatch("unload-app");
	  });
	  $(window).blur(function (e) {
	    AppDispatcher.dispatch("application-blurred");
	  });
	  $(window).focus(function (e) {
	    AppDispatcher.dispatch("application-focused");
	  });

	  // Boot up connection
	  var hc = new HipChat({
	    initState: initState,
	    baseUrl: (undefined),
	    clientType: "ADG",

	    onReconnecting: function onReconnecting(numAttempts, nextAttempt) {
	      AppDispatcher.dispatch("strophe-reconnecting");
	    },

	    onConnectionChange: function onConnectionChange(status, condition) {
	      AppDispatcher.dispatch("strophe-connection-changed", {
	        status: status,
	        condition: condition
	      });
	    },

	    onReconnectionSuccess: function onReconnectionSuccess(shouldReattach) {
	      if (shouldReattach) {
	        hc.joinAutoJoinRooms(false, 0);
	      }
	      AppDispatcher.dispatch("reconnect-success");
	    },

	    onStaleSession: function onStaleSession(age) {
	      // TODO would be nice not to have to do this. Ideally, we should be able to mark
	      // core stores as dirty if the last_connected_time is past a certain threshold.
	      // Then we could dispatch an update that either replaces the data in the stores entirely
	      // or diffs and inserts the missing data.
	      if (age > 5 * 60000) {
	        window.location.reload();
	      }
	    },

	    onServerData: function onServerData(data) {
	      AppDispatcher.dispatch("server-data", data);
	    },

	    onInitialConnect: function onInitialConnect(hc) {
	      // TODO Make this debouncing unnecessary
	      var debouncedSavePreferences = _.debounce(hc.savePreferences.bind(hc), 500);

	      AppDispatcher.register({
	        "close-room": function (data) {
	          if (!data.doNotNotifyHC) {
	            hc.leaveRoom(data.jid, data.type);
	          }
	          _.remove(hc.config.prefs.autoJoin, function (room) {
	            return room.jid === data.jid;
	          });
	          // Send false when no chats open. jQuery does not serialise empty arrays.
	          if (!hc.config.prefs.autoJoin || hc.config.prefs.autoJoin.length === 0) {
	            hc.config.prefs.autoJoin = false;
	          }
	          hc.setPref("autoJoin", hc.config.prefs.autoJoin, true);
	        },
	        "join-room": function (data) {
	          /@conf/.test(data.jid) ? hc.joinRoom(data.jid) : hc.joinChat(data.jid);
	        },
	        "fetch-files": function (data) {
	          hc.fetchFiles(data.room);
	        },
	        "fetch-links": function (data) {
	          hc.fetchLinks(data.room);
	        },
	        "create-room": function (data, cb) {
	          hc.createRoom(data.name, data.topic, data.privacy, cb);
	        },
	        "delete-room": function (data, cb) {
	          hc.deleteRoom(data.jid, data.reason, cb);
	        },
	        "change-room-privacy": function (data, cb) {
	          hc.changeRoomPrivacy(data.jid, data.privacy, cb);
	        },
	        "change-room-name": function (data, cb) {
	          hc.renameRoom(data.jid, data.name, cb);
	        },
	        "update-presence": function (presence) {
	          hc.setPresence(presence.show, presence.status);
	        },
	        "set-guest-access": function (data) {
	          hc.setGuestAccess(data.jid, data.enable);
	        },
	        "updated:preferences": function (data) {
	          _.forOwn(data, function (val, key) {
	            hc.setPref(key, val, false);
	          });
	          debouncedSavePreferences();
	        },
	        "request-profile": function (jid) {
	          hc.fetchUserProfile(jid);
	        },
	        "fetch-presences": function (data) {
	          hc.fetchPresence(data);
	        },
	        "attempt-reconnect": function () {
	          hc.reconnect(function (status) {
	            AppDispatcher.dispatch("reconnect-" + status);
	          });
	        },
	        "fetch-previous": function (data) {
	          hc.fetchHistory(data.jid, data.oldest || null, 75, data.id);
	        },
	        "upload-file": function (data) {
	          AnalyticsDispatcher.dispatch("analytics-event", {
	            name: "hipchat.client.file.uploaded." + (utils.room.detect_chat_type(data.jid) === "groupchat" ? "room" : "oto"),
	            properties: {
	              fileType: data.fileName.substr(data.fileName.lastIndexOf(".") + 1)
	            }
	          });
	          var uploadConfig = {
	            user_id: hc.config.user_id,
	            group_id: hc.config.group_id,
	            jid: data.jid,
	            file: data.file,
	            fileName: data.fileName,
	            token: hc.token_info.token,
	            desc: data.desc,
	            progressBarSelector: "#upload-progress-bar",
	            success: function success(evt) {
	              AppDispatcher.dispatch("upload-successful", evt);
	              hc.fetchFiles(data.jid);
	            },
	            error: (function (_error) {
	              var _errorWrapper = function error() {
	                return _error.apply(this, arguments);
	              };

	              _errorWrapper.toString = function () {
	                return _error.toString();
	              };

	              return _errorWrapper;
	            })(function (error) {
	              AppDispatcher.dispatch("upload-failed", error);
	            })
	          };
	          uploader.uploadFile(uploadConfig);
	        },
	        "send-message": function (data) {
	          hc.sendMessage(data.jid, data.text, data.id);
	        },
	        "resend-message": function (data) {
	          hc.sendMessage(data.jid, data.body, data.mid);
	        },
	        "send-upload-message": function (data) {
	          hc.sendUploadMessage(data);
	        },
	        "set-topic": function (data) {
	          hc.setTopic(data.jid, data.topic);
	        },
	        "groupchat-invite-received": function (data, cb) {
	          hc.fetchRoom(data.from, cb);
	        },
	        "open-room": function (data) {
	          if (!utils.jid.is_private_chat(data.jid)) {
	            hc.fetchRoom(data.jid);
	          }
	        },
	        "exit-app": function (data) {
	          $(window).off("beforeunload");
	          hc.revokeOauth2Token();
	          for (var pref in data.preferences) {
	            hc.setPref(pref, data[pref], false);
	          }
	          if (data.is_guest) {
	            hc.leaveRoom(data.jid, data.type);
	            // Wait a second before leaving so we don't show up in the
	            // "Currently chatting" list on refresh
	            setTimeout(function () {
	              window.location.href = "/g" + data.guest_key + "?src=chat_exit";
	            }, 1000);
	          } else {
	            window.location.href = "/home?src=chat_exit";
	          }
	        },
	        "app-state-ready": function () {
	          if (hc.config.prefs.chatToFocus && utils.jid.is_room(hc.config.prefs.chatToFocus)) {
	            AppDispatcher.dispatch("initial-join-presence-sent", {
	              jid: hc.config.prefs.chatToFocus,
	              with_history: true
	            });
	            hc.joinRoom(hc.config.prefs.chatToFocus, 75);
	            hc.joinAutoJoinRooms(_.reject(hc.config.prefs.autoJoin, { jid: hc.config.prefs.chatToFocus }), 0);
	          } else {
	            hc.joinAutoJoinRooms();
	          }
	          if (!console) return;
	          console.emote("(awesome) Hey there …trying to reverse engineer something? (badass) why not join our team instead? (zoidberg)");
	          console.emote("Apply at https://www.hipchat.com/jobs and mention this comment. (celeryman)");
	        },
	        "invite-users": function (data, cb) {
	          hc.inviteUsersToRoom(data.room_jid, data.user_jids, data.reason);
	        },
	        "remove-users": function (data, cb) {
	          hc.removeUsersFromRoom(data.room_jid, data.user_jids, cb);
	        },
	        "send-user-state-message": function (data) {
	          hc.sendStateMessage(data.jid, data.type, data.state);
	        }
	      });

	      HCApiDispatcher.register({
	        "API:fetch-recent-history": function (data) {
	          HCApi[data.path.type].recent_history(data, function (result) {
	            HCApiDispatcher.dispatch("API:fetched-recent-history", {
	              jid: data.jid,
	              results: result.items,
	              mid: data.params["not-before"]
	            });
	          });
	        },
	        "API:update-room": function (data, cb) {
	          HCApi.room.update_room(data, cb);
	        }
	      });

	      _.merge(hc.config, { features: features });

	      window.HC.getHCTokenInfo = function () {
	        return hc.token_info;
	      };

	      var HCApi = new APIV2(hc.config.oauth2_token, hc.config.api_host);

	      AppDispatcher.dispatch("hc-init", _.merge({}, hc.config));
	      AnalyticsDispatcher.dispatch("analytics-hc-init", {});

	      hc.fetchRoster();
	      hc.fetchRooms();
	      hc.fetchEmoticons();
	    }
	  });
	})();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(62);

	module.exports = new AppDispatcher();

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4),
	    Store = __webpack_require__(43),
	    MessageProcessor = __webpack_require__(18),
	    IQProcessor = __webpack_require__(19),
	    PresenceProcessor = __webpack_require__(20),
	    AppDispatcher = __webpack_require__(1),
	    HCApiDispatcher = __webpack_require__(8),
	    PreferencesStore = __webpack_require__(21),
	    ChatPanelStrings = __webpack_require__(22);

	var AppStore = (function (Store) {
	  function AppStore() {
	    _classCallCheck(this, AppStore);

	    this.data = {};
	    this.local = {
	      initialized: false,
	      user_state: "active",
	      active_type: "",
	      profile_jids: [],
	      sent_msg_ids: [],
	      participants: [],
	      received_mids: [],
	      history_fetch_id: 0,
	      chat_states: ["active", "inactive", "composing", "gone"]
	    };

	    this.defaults = {
	      room: {
	        admins: [],
	        participants: {
	          members: [],
	          guests: []
	        },
	        files: [],
	        links: [],
	        is_archived: "0",
	        history_fetch_ids: [],
	        show_join_messages: false,
	        presence: {
	          show: "",
	          status: "",
	          seconds: "",
	          idleTime: ""
	        }
	      },
	      roster: {
	        presence: {
	          show: "unknown",
	          status: "",
	          seconds: "",
	          idleTime: ""
	        }
	      }
	    };

	    var initial = {
	      oauth2_token: "",
	      active_chat: "",
	      current_user: {},
	      activeRooms: {},
	      allRooms: {},
	      messageHistory: {},
	      newMessages: {},
	      roster: {},
	      profiles: {},
	      smileys: {},
	      emoticons: {
	        path_prefix: "",
	        icons: {}
	      },
	      connection: {
	        connected: true,
	        reconnecting: false,
	        disconnecting: false,
	        reconnectingIn: 0
	      },
	      mentionRegexUser: null,
	      mentionRegexMe: null,
	      group_name: "",
	      group_id: null,
	      conference_server: null,
	      features: {}
	    };

	    this.data = initial;

	    this.server_data_callbacks = {
	      message: this.handleIncomingMessages,
	      iq: IQProcessor.handleIQ,
	      presence: PresenceProcessor.handlePresence,
	      success: this.handleConnectionSuccess
	    };

	    this.messageProcessor = new MessageProcessor({
	      allRooms: this.data.allRooms,
	      activeRooms: this.data.activeRooms,
	      current_user: this.data.current_user,
	      mentionRegexMe: this.data.mentionRegexMe,
	      mentionRegexUser: this.data.mentionRegexUser,
	      emoticons: this.data.emoticons,
	      profiles: this.data.profiles,
	      roster: this.data.roster,
	      received_mids: this.local.received_mids,
	      sent_msg_ids: this.local.sent_msg_ids,
	      chat_states: this.local.chat_states,
	      token: this.data.oauth2_token
	    });

	    this.requestPresences = _.debounce(this.getParticipantPresences, 500, { leading: false, trailing: true });
	    this.debouncedSetActiveRooms = _.debounce(this.setActiveRooms, 500, { leading: true, trailing: true });
	    this.registerCallbacks();
	    this.addChangeHandlers();
	  }

	  _inherits(AppStore, Store);

	  _prototypeProperties(AppStore, null, {
	    registerCallbacks: {
	      value: function registerCallbacks() {
	        var _this = this;

	        AppDispatcher.registerOnce({
	          "hc-init": function (data) {
	            _this.handleHCInit(data);
	          },
	          signout: function () {
	            var opts = {
	              is_guest: false,
	              guest_key: false,
	              type: "",
	              jid: _this.data.active_chat,
	              preferences: PreferencesStore.getAll()
	            };
	            AppDispatcher.dispatch("exit-app", opts);
	          }
	        });
	        AppDispatcher.register({
	          "server-data": function (data) {
	            _this.handleServerData(data);
	          },
	          "app-state-ready": function () {
	            _this.handleAppStateReady();
	          },
	          "close-room": function (data) {
	            _this.handleCloseRoom(data.jid, data.type);
	          },
	          "join-room": function (data) {
	            _this.handleJoinRoom(data);
	          },
	          "send-message": function (data) {
	            _this.handleSendMessage(data);
	          },
	          "update-presence": function (presence) {
	            _this.updatePresence(presence);
	          },
	          "show-join-messages": function (data) {
	            if (_this.data.activeRooms[data.jid]) _this.data.activeRooms[data.jid].show_join_messages = true;
	          },
	          "hide-join-messages": function () {
	            _.forOwn(_this.data.activeRooms, function (room) {
	              room.show_join_messages = false;
	            });
	          },
	          "select-room": function (data) {
	            _this.local.active_type = /@chat/.test(data.jid) ? "chat" : "groupchat";
	            _this.set("active_chat", data.jid);
	          },
	          "request-ancient-history": function (data) {
	            _this.local.history_fetch_id++;
	            data.id = "history:" + _this.local.history_fetch_id;
	            if (_this.data.activeRooms[data.jid]) _this.data.activeRooms[data.jid].history_fetch_ids.push(data.id);
	            AppDispatcher.dispatch("fetch-previous", data);
	          },
	          "remove-room-participant": function (data) {
	            _this.removeRoomParticipant(data);
	          },
	          "add-room-visitor": function (data) {
	            _this.addVisitor(data);
	          },
	          "room-presence-received": function (data) {
	            _this.handleRoomPresence(data);
	          },
	          "user-removed": function (data) {
	            _this.handleUserRemoved(data);
	          },
	          "handle-cached-room": function (room) {
	            _this.handleRooms(room);
	          },
	          "global-presence-received": function (data) {
	            _this.handleGlobalPresence(data);
	          },
	          "groupchat-invite-received": function (message) {
	            _this.handleInviteMessage(message);
	          },
	          "private-chat-invite-received": function (message) {
	            var jid, uid;
	            if (message.from === _this.data.current_user.user_jid) jid = Utils.jid.bare_jid(message.to);else jid = Utils.jid.bare_jid(message.from);
	            uid = Utils.jid.user_id(jid);
	            _this.joinPrivateChat(jid, uid);
	          },
	          "groupchat-invite-accepted": function (data) {
	            _this.handleRoomInviteAccepted(data.jid);
	          },
	          "set-user-state": function (data) {
	            if (_this.local.user_state != data.state) {
	              _this.local.user_state = data.state;
	              AppDispatcher.dispatch("send-user-state-message", data);
	            }
	          },
	          "strophe-connection-changed": function (data) {
	            _this.handleConnectionChange(data);
	          },
	          "strophe-reconnecting": function () {
	            _this.handleReconnecting();
	          },
	          "status-message-received": function (data) {
	            _this.handleChatStateMessage(data);
	          },
	          "archive-room": function (data, cb) {
	            _this.handleArchiveRoom(data, true, cb);
	          },
	          "unarchive-room": function (data, cb) {
	            _this.handleArchiveRoom(data, false, cb);
	          },
	          "room-archived": function (data) {
	            var chat = _this.data.activeRooms[data.jid];
	            if (chat) {
	              chat.is_archived = "1";
	              _this.set("activeRooms", _this.data.activeRooms);
	            }
	          },
	          "room-unarchived": function (data) {
	            var chat = _this.data.activeRooms[data.jid];
	            if (chat) {
	              chat.is_archived = "0";
	              _this.set("activeRooms", _this.data.activeRooms);
	            }
	          }
	        });

	        HCApiDispatcher.register({
	          "API:fetched-recent-history": function (data) {
	            _this.handleIncomingMessages(data, _this);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleAppStateReady: {
	      value: function handleAppStateReady() {
	        _.map(this.local.profile_jids, function (jid) {
	          AppDispatcher.dispatch("request-profile", jid);
	        });
	        this.local.profile_jids = [];
	        var activeSize = _.size(this.data.activeRooms);
	        if (activeSize < 2) {
	          this.onBoardNewUser(activeSize);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    onBoardNewUser: {
	      value: function onBoardNewUser(activeSize) {
	        // Fixes a bug for GROW-1687
	        // we may consider removing when that experiment is complete
	        var conf = this.data.conference_server,
	            groupName = this.data.group_name.replace("-", "_"),
	            groupId = this.data.group_id,
	            jid = groupId + "_" + groupName.toLowerCase() + "@" + conf,
	            room = this.data.allRooms[jid],
	            shouldOnBoard = activeSize == 0;

	        if (activeSize == 1) {
	          // Make sure lone activeRoom is equal to jid room
	          shouldOnBoard = !!this.data.activeRooms[jid];
	        }

	        if (room && room.privacy === "public") {
	          if (activeSize == 0) {
	            AppDispatcher.dispatch("open-room", {
	              jid: jid
	            });
	          }
	          if (shouldOnBoard) {
	            $(document).trigger("hc.start-onboarding");
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    addChangeHandlers: {
	      value: function addChangeHandlers() {
	        var _this = this;

	        _.map(this.data, function (obj, key) {
	          _this.on("change:" + key, function (changeset) {
	            AppDispatcher.dispatch("updated:" + key, changeset);
	          });
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleJoinRoom: {
	      value: function handleJoinRoom(data) {
	        var jid = Utils.jid.bare_jid(data.jid || data.from);
	        if (Utils.jid.is_private_chat(jid)) {
	          this.joinPrivateChat(jid, Utils.jid.user_id(jid));
	          return;
	        }
	        var room = Utils.fetch(this.data.allRooms[jid], {});
	        _.assign(room, _.cloneDeep(this.defaults.room), {
	          presence: _.cloneDeep(this.defaults.room.presence),
	          type: "groupchat"
	        });
	        this.data.activeRooms[jid] = room;
	        this.set({
	          activeRooms: this.data.activeRooms
	        });
	        AppDispatcher.dispatch("select-room", { jid: jid });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleHCInit: {
	      value: function handleHCInit(data) {
	        var _this = this;

	        var uid,
	            roomsArr = Utils.toArray(_.uniq(_.cloneDeep(PreferencesStore.getAutoJoinRooms()))),
	            rooms = {},
	            roster = {},
	            initialPresence = {};
	        if (!this.local.initialized) {
	          var chatToFocus = PreferencesStore.getChatToFocus();
	          if (_.pluck(roomsArr, "jid").indexOf(chatToFocus) != -1) {
	            this.data.active_chat = chatToFocus;
	            this.local.active_type = /@chat/.test(chatToFocus) ? "chat" : "groupchat";
	          } else {
	            this.data.active_chat = "lobby";
	          }
	          _.forEach(roomsArr, function (room) {
	            room.type = Utils.jid.is_room(room.jid) ? "groupchat" : "chat";
	            rooms[room.jid] = _.assign(room, _.cloneDeep(_this.defaults.room));
	            if (room.type == "chat") {
	              uid = Utils.jid.user_id(room.jid);
	              if (_this.local.participants.indexOf(uid) == -1) _this.local.participants.push(uid);
	              _this.local.profile_jids.push(room.jid);
	            }
	          });
	          var current_user = _.pick(data, ["user_jid", "user_name", "mention", "title", "photo_large", "photo_small", "email", "is_admin"]);
	          roster[data.user_jid] = { presence: { show: "chat", status: "" } };
	          this.data.mentionRegexMe = new RegExp("(?=[^\\w>]|^)@(" + data.mention + "|all|here|\"" + data.user_name + "\")(?=[^\\w<]|$)", "ig");
	          rooms[current_user.user_jid] ? rooms[current_user.user_jid].presence.show = "chat" : _.noop();
	          initialPresence[current_user.user_jid] = {
	            from: current_user.user_jid,
	            show: "chat"
	          };
	          _.merge(this.data, {
	            current_user: current_user,
	            activeRooms: rooms,
	            roster: roster,
	            smileys: Utils.emoticons.addSmileys(data.emoticons || [])
	          });

	          this.updateMessageProcessor();

	          AppDispatcher.dispatch("initial-select-room", PreferencesStore.getChatToFocus());

	          this.set({
	            current_user: this.data.current_user,
	            activeRooms: this.data.activeRooms,
	            active_chat: chatToFocus,
	            roster: this.data.roster,
	            smileys: this.data.smileys,
	            conference_server: data.conference_server,
	            group_name: data.group_name,
	            group_id: data.group_id,
	            features: data.features,
	            oauth2_token: data.oauth2_token
	          });
	          this.local.initialized = true;
	          this.requestPresences();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleServerData: {
	      value: function handleServerData(data) {
	        var _this = this;

	        _.map(this.server_data_callbacks, function (cb, evt) {
	          var thisData = data[evt];
	          if (thisData) {
	            cb(thisData, _this);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    unsubscribeFromStanzas: {
	      value: function unsubscribeFromStanzas(type) {
	        var _this = this;

	        Utils.toArray(type).forEach(function (stanza) {
	          _this.server_data_callbacks[stanza] = function (stanza) {
	            _.noop(stanza);
	          };
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleInviteMessage: {
	      value: function handleInviteMessage(message) {
	        var fromRoom = Utils.jid.bare_jid(message.from),
	            invite = message.x[0].invite,
	            fromUser = invite.from,
	            room = message.x[1];

	        if (Utils.jid.bare_jid(fromUser) === this.data.current_user.user_jid) {
	          AppDispatcher.dispatch("join-room", { jid: fromRoom });
	          return;
	        }

	        var reason = invite.reason || "";

	        var inviteFromName = this.data.roster[Utils.jid.bare_jid(fromUser)].name;

	        if (Utils.jid.is_room(fromUser)) {
	          inviteFromName = Utils.jid.resource(fromUser);
	        }

	        var roomName = message.x[1].name;

	        AppDispatcher.dispatch("show-modal-dialog", {
	          dialog_type: "room-invite-dialog",
	          dialog_data: {
	            room_name: roomName,
	            room_jid: fromRoom,
	            from_user: inviteFromName,
	            reason: reason
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomInviteAccepted: {
	      value: function handleRoomInviteAccepted(jid) {
	        if (this.data.allRooms[jid]) {
	          this.handleNewRoom(this.data.allRooms[jid]);
	          AppDispatcher.dispatch("open-room", { jid: jid });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleIncomingMessages: {
	      value: function handleIncomingMessages(messages, store) {
	        var messagesObj = store.messageProcessor.processMessages(messages);
	        store.local.received_mids = store.local.received_mids.concat(_.keys(messagesObj));
	        messagesObj = _.groupBy(messagesObj, "room");
	        store.set({
	          messageHistory: _.merge(store.data.messageHistory, messagesObj),
	          newMessages: messagesObj
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleSendMessage: {
	      value: function handleSendMessage(data) {
	        var msg = this.messageProcessor.processSentMessage(data);
	        this.local.user_state = "active";
	        this.local.sent_msg_ids.push(data.id.toString());
	        this.set({
	          newMessages: _.groupBy(msg, "room")
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleChatStateMessage: {
	      value: function handleChatStateMessage(data) {
	        var jid = Utils.jid.bare_jid(data.message.from),
	            chat = this.data.activeRooms[jid],
	            user = Utils.jid.bare_jid(Utils.dot(data, "message.delay.from_jid")) || Utils.jid.bare_jid(Utils.dot(data, "message.from"));
	        switch (data.type) {
	          case "active":
	            if (!chat && this.data.current_user.user_jid === user) {
	              AppDispatcher.dispatch("join-room", { jid: jid });
	            }
	            break;
	          case "gone":
	            if (chat && user === this.data.current_user.user_jid && Utils.jid.is_private_chat(chat.jid)) {
	              this.handleCloseRoom(jid, "chat");
	            }
	            break;
	          default:
	            break;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleStartupIQ: {
	      value: function handleStartupIQ(data) {
	        this.deferred.resolve(data);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleConnectionSuccess: {
	      value: function handleConnectionSuccess(connection, store) {
	        store.deferred = Utils.promise.defer();
	        store.deferred.promise.then(function (query) {
	          var obj = {
	            user_jid: Utils.jid.bare_jid(connection.jid),
	            user_name: query.name,
	            mention: query.mention_name,
	            prefs: query.preferences
	          };
	          obj.prefs.autoJoin = Utils.toArray(query.preferences.autoJoin.item);
	          obj.prefs.chatToFocus = query.preferences.chatToFocus;
	          PreferencesStore.data.autoJoin = obj.prefs.autoJoin;
	          PreferencesStore.data.chatToFocus = obj.prefs.chatToFocus.replace(/"/g, "");
	          store.handleHCInit(obj);
	        });
	        store.set("current_user", {
	          user_jid: Utils.jid.bare_jid(connection.jid)
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleEmoticons: {
	      value: function handleEmoticons(e) {
	        e.item = e.item ? Utils.toArray(e.item) : [];
	        this.set({
	          emoticons: {
	            path_prefix: e.path_prefix,
	            icons: _.merge(this.data.emoticons.icons, Utils.emoticons.addBulk(e.item))
	          }
	        });
	        this.updateMessageProcessor();
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoster: {
	      value: function handleRoster(roster) {
	        var _this = this;

	        roster = Utils.toArray(roster);
	        var rosterObj = _.indexBy(roster, function (user) {
	          if (!_this.data.roster[user.jid]) _.assign(user, user.jid == _this.data.current_user.user_jid ? { presence: { show: "chat", status: "" } } : _.cloneDeep(_this.defaults.roster));
	          return user.jid;
	        });
	        this.set("roster", _.merge(this.data.roster, rosterObj));
	        this.updateMentionNames();
	        this.updateRosterNames();
	      },
	      writable: true,
	      configurable: true
	    },
	    updateMentionNames: {
	      value: function updateMentionNames() {
	        var mentionNames = _.map(this.data.roster, function (user) {
	          return user.mention_name;
	        });
	        mentionNames.splice(mentionNames.indexOf(this.data.current_user.mention), 1);
	        this.set({
	          mentionRegexUser: new RegExp("(?=[^\\w>]|^)@(" + (mentionNames.length ? mentionNames.join("|") + "|HipChat" : "HipChat") + ")(?=[^\\w<]|$)", "gi")
	        });
	        this.updateMessageProcessor();
	      },
	      writable: true,
	      configurable: true
	    },
	    updateRosterNames: {
	      value: function updateRosterNames() {
	        var name_map = _.transform(this.data.roster, function (result, user) {
	          result[user.mention_name] = user.name;
	        });
	        Utils.roster_names = _.merge(name_map, Utils.core_mention_names);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleProfile: {
	      value: function handleProfile(iq) {
	        this.data.profiles[Utils.jid.bare_jid(iq.from)] = iq.query;
	        this.set("profiles", this.data.profiles);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleFiles: {
	      value: function handleFiles(iq) {
	        var jid = Utils.jid.bare_jid(iq.from),
	            files,
	            user_name;
	        if (this.data.activeRooms[jid] && iq.query.item) {
	          files = Utils.toArray(iq.query.item);
	          _.forOwn(files, function (file) {
	            user_name = file.user_name ? file.user_name : Utils.user.get_user_name(this.data.roster, file.group_id, file.user_id);
	            file.user_name = user_name;
	            file.icon_class = Utils.file.get_icon_class(file.name);
	          }, this);
	          this.data.activeRooms[jid].files = files;

	          this.set({
	            activeRooms: this.data.activeRooms
	          });
	        }
	        AppDispatcher.dispatch("files-fetched", { jid: jid });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleLinks: {
	      value: function handleLinks(iq) {
	        var jid = Utils.jid.bare_jid(iq.from),
	            user_name,
	            links;
	        if (this.data.activeRooms[jid] && iq.query.item) {
	          links = Utils.toArray(iq.query.item);
	          _.forOwn(links, function (link) {
	            user_name = link.user_name ? link.user_name : Utils.user.get_user_name(this.data.roster, link.group_id, link.user_id);
	            link.user_name = user_name;
	            link.display_url = link.url.replace(/.*?:\/\//g, "");
	          }, this);
	          this.data.activeRooms[jid].links = links;
	          this.set({
	            activeRooms: this.data.activeRooms
	          });
	        }
	        AppDispatcher.dispatch("links-fetched", { jid: jid });
	      },
	      writable: true,
	      configurable: true
	    },
	    joinPrivateChat: {
	      value: function joinPrivateChat(jid, uid) {
	        this.data.activeRooms[jid] = {
	          messages: [],
	          jid: jid,
	          name: this.data.roster[jid].name,
	          type: "chat",
	          presence: this.data.roster[jid].presence || {
	            show: "",
	            status: ""
	          },
	          history_fetch_ids: []
	        };
	        if (this.local.participants.indexOf(uid) == -1) {
	          this.local.participants.push(uid);
	        }
	        AppDispatcher.dispatch("request-profile", jid);
	        this.set("activeRooms", this.data.activeRooms);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRooms: {
	      value: function handleRooms(rooms) {
	        var _this = this;

	        rooms = Utils.toArray(rooms);
	        var allRoomsObj = _.indexBy(_.map(rooms, function (room) {
	          var roomInfo = {};
	          if (room) {
	            roomInfo = _.assign(room.x, {
	              jid: room.jid,
	              name: room.name
	            });
	            _.assign(_this.data.activeRooms[room.jid], roomInfo);
	          }
	          return roomInfo;
	        }), "jid");

	        this.set({
	          allRooms: _.assign(this.data.allRooms, allRoomsObj),
	          activeRooms: this.data.activeRooms
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    determineRoomUpdate: {
	      value: function determineRoomUpdate(room) {
	        if (room.status === "deleted") {
	          this.handleRoomDelete(room);
	          return;
	        }
	        var is_new_room = !this.data.allRooms[room.jid];
	        if (is_new_room) {
	          this.handleNewRoom(room);
	        } else {
	          this.handleRoomUpdate(room);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleNewRoom: {
	      value: function handleNewRoom(room) {
	        var room_data = _.cloneDeep(this.defaults.room);
	        room_data.type = Utils.room.detect_chat_type(room.jid);
	        this.data.allRooms[room.jid] = _.assign(room_data, room);
	        if (!room_data.admins) {
	          room_data.admins = [];
	        }
	        room_data.admins.push(room.owner);
	        if (room.owner === this.data.current_user.user_jid) {
	          // Current User Created Room
	          this.data.activeRooms[room.jid] = _.assign(room_data, room);
	          this.data.allRooms[room.jid] = _.assign(room_data, room);
	          this.set({
	            allRooms: this.data.allRooms,
	            activeRooms: this.data.activeRooms
	          });
	          AppDispatcher.dispatch("open-room", room);
	          AppDispatcher.dispatch("new-room-created", room);
	        } else {
	          this.set({
	            allRooms: this.data.allRooms
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomUpdate: {
	      value: function handleRoomUpdate(room) {
	        this.data.allRooms[room.jid] = _.assign(this.data.allRooms[room.jid], room);
	        if (this.data.activeRooms[room.jid]) {
	          this.data.activeRooms[room.jid] = _.assign(this.data.activeRooms[room.jid], room);
	        }
	        this.set({
	          allRooms: this.data.allRooms,
	          activeRooms: this.data.activeRooms
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomDelete: {
	      value: function handleRoomDelete(room) {
	        delete this.data.allRooms[room.jid];
	        if (this.data.activeRooms[room.jid]) {
	          // Show msg to non-admin in the room
	          if (room.jid === this.data.active_chat && !_.contains(this.data.activeRooms[room.jid].admins, this.data.current_user.user_jid)) {
	            AppDispatcher.dispatch("show-flag", {
	              type: "info",
	              close: "auto",
	              body: "\"" + this.data.activeRooms[room.jid].name + "\" was deleted by the admin."
	            });
	          }
	          delete this.data.activeRooms[room.jid];
	        }
	        AppDispatcher.dispatch("room-deleted", {
	          jid: room.jid
	        });
	        this.set({
	          allRooms: this.data.allRooms,
	          activeRooms: this.data.activeRooms
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleCloseRoom: {
	      value: function handleCloseRoom(jid, type) {
	        AppDispatcher.dispatch("room-closed", {
	          jid: jid
	        });
	        delete this.data.activeRooms[jid];
	        delete this.data.newMessages[jid];
	        delete this.data.messageHistory[jid];
	        this.set({
	          activeRooms: this.data.activeRooms
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    addVisitor: {
	      value: function addVisitor(data) {
	        this.data.roster[data.participant] = {
	          mention_name: data.user_mention,
	          name: data.user_name,
	          jid: data.participant,
	          presence: {
	            show: "chat",
	            status: ""
	          }
	        };
	        this.addRoomParticipant({
	          room: data.room,
	          user_jid: data.participant,
	          user_id: Utils.jid.user_id(data.participant),
	          role: "visitor",
	          affiliation: ""
	        });
	        this.set("roster", this.data.roster);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomPresence: {
	      value: function handleRoomPresence(data) {
	        if (this.data.activeRooms[data.room]) {
	          var arr = data.role == "visitor" ? this.data.activeRooms[data.room].participants.guests : this.data.activeRooms[data.room].participants.members;
	          if (!arr[data.user_jid]) {
	            this.addRoomParticipant(data);
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleGlobalPresence: {
	      value: function handleGlobalPresence(data) {
	        var _this = this;

	        var person,
	            room,
	            shouldUpdate = false;
	        _.forOwn(data, function (pres, jid) {
	          person = _this.data.roster[jid];
	          room = _this.data.activeRooms[jid];
	          if (person) {
	            if (jid !== _this.data.current_user.user_jid || jid === _this.data.current_user.user_jid && _.contains(["away", "chat", "dnd"], pres.show)) {
	              _.assign(person.presence, pres);
	            }
	          }
	          if (room) {
	            _.assign(room.presence, pres);
	          }
	          if (!! ~_this.local.participants.indexOf(Utils.jid.user_id(jid))) {
	            shouldUpdate = true;
	          }
	        });
	        if (shouldUpdate) {
	          this.set({
	            activeRooms: this.data.activeRooms,
	            roster: this.data.roster
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    addRoomParticipant: {
	      value: function addRoomParticipant(data) {
	        var room = this.data.activeRooms[data.room];
	        var arr = data.role == "visitor" ? room.participants.guests : room.participants.members;
	        if (arr.indexOf(data.user_jid) == -1) arr.push(data.user_jid);

	        if (data.type === "unavailable" && Utils.user.is_admin(room.admins, room.owner, this.data.current_user)) {
	          this.roomParticipantNotification(data, "add");
	        } else {
	          this.roomParticipantNotification(data, "join");
	        }

	        if (room.privacy === "private") {
	          AppDispatcher.dispatch("unmark-participant", {
	            room: data.room,
	            user: data.user_jid,
	            role: data.role
	          });
	        }
	        if (data.affiliation === "owner" || data.affiliation === "admin") {
	          this.addRoomAdmin(data.room, data.user_jid);
	        }
	        this.debouncedSetActiveRooms();
	        if (this.local.participants.indexOf(data.user_id) == -1) this.local.participants.push(data.user_id);
	        AppDispatcher.dispatch("request-profile", data.user_jid);
	      },
	      writable: true,
	      configurable: true
	    },
	    removeRoomParticipant: {
	      value: function removeRoomParticipant(data) {
	        var room = this.data.activeRooms[data.room];
	        if (room) {
	          if (room.participants[data.role]) {

	            this.roomParticipantNotification(data, "leave");

	            if (room.privacy === "private" && data.role !== "guests") {
	              AppDispatcher.dispatch("mark-participant-unknown", {
	                room: data.room,
	                user: data.participant,
	                role: data.role
	              });
	            } else {
	              _.remove(room.participants[data.role], function (i) {
	                return i === data.participant;
	              });
	            }
	          } else if (data.role == "none") {
	            _.forEach(room.participants, function (group) {
	              _.remove(group, function (user_jid) {
	                return user_jid === data.participant;
	              });
	            });
	            if (Utils.user.is_admin(room.admins, room.owner, this.data.current_user)) {
	              this.roomParticipantNotification(data, "remove");
	            }
	          }
	          this.debouncedSetActiveRooms();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleUserRemoved: {
	      value: function handleUserRemoved(data) {
	        this.removeRoomParticipant({
	          room: data.room,
	          participant: data.user_jid,
	          role: data.role
	        });

	        if (this.data.allRooms[data.room] && !Utils.user.is_admin(this.data.activeRooms[data.room].admins, this.data.activeRooms[data.room].owner, this.data.current_user)) {
	          if (this.data.activeRooms[data.room]) {
	            AppDispatcher.dispatch("show-flag", {
	              type: "info",
	              body: ChatPanelStrings.you_have_been_removed + " \"" + Utils.escape(this.data.activeRooms[data.room].name) + "\"",
	              close: "auto"
	            });
	            AppDispatcher.dispatch("close-room", {
	              jid: data.room
	            });
	          }
	          AppDispatcher.dispatch("room-deleted", {
	            jid: data.room
	          });
	          delete this.data.allRooms[data.room];
	          this.set({
	            allRooms: this.data.allRooms
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    roomParticipantNotification: {
	      value: function roomParticipantNotification(data, notificationType) {
	        var statusMessage,
	            messages = [],
	            user_jid = data.participant || data.user_jid;

	        if (!this.data.activeRooms[data.room].show_join_messages) {
	          return;
	        }var name = name = this.data.roster[user_jid].name;

	        if (notificationType === "leave") {
	          switch (data.status) {
	            case "hc-disconnect":
	              statusMessage = ChatPanelStrings.user_leave_reason(name, ChatPanelStrings.user_disconnected);
	              break;
	            case "hc-not-allowed":
	              statusMessage = ChatPanelStrings.user_leave_reason(name, ChatPanelStrings.not_allowed);
	              break;
	            case "hc-timeout":
	              statusMessage = ChatPanelStrings.user_leave_reason(name, ChatPanelStrings.lost_connection);
	              break;
	            default:
	              statusMessage = ChatPanelStrings.user_leave(name);
	              break;
	          }
	        } else if (notificationType === "join") {
	          statusMessage = ChatPanelStrings.user_join(name);
	        } else if (notificationType === "remove") {
	          statusMessage = ChatPanelStrings.user_removed(name);
	        } else if (notificationType === "add") {
	          statusMessage = ChatPanelStrings.user_added(name);
	        }

	        messages.push({
	          body: statusMessage,
	          type: "room-presence",
	          from: data.room,
	          delay: true,
	          sender: " "
	        });

	        this.handleIncomingMessages(messages, this);
	      },
	      writable: true,
	      configurable: true
	    },
	    addRoomAdmin: {
	      value: function addRoomAdmin(roomJid, userJid) {
	        if (!_.contains(this.data.activeRooms[roomJid].admins, userJid)) {
	          this.data.activeRooms[roomJid].admins.push(userJid);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    updatePresence: {
	      value: function updatePresence(pres) {
	        _.merge(this.data.current_user.presence, pres);
	        this.set("current_user", this.data.current_user);
	      },
	      writable: true,
	      configurable: true
	    },
	    getParticipantPresences: {
	      value: function getParticipantPresences() {
	        return AppDispatcher.dispatch("fetch-presences", this.local.participants);
	      },
	      writable: true,
	      configurable: true
	    },
	    setActiveRooms: {
	      value: function setActiveRooms() {
	        this.set("activeRooms", this.data.activeRooms);
	      },
	      writable: true,
	      configurable: true
	    },
	    updateMessageProcessor: {
	      value: function updateMessageProcessor() {
	        this.messageProcessor.update({
	          allRooms: this.data.allRooms,
	          activeRooms: this.data.activeRooms,
	          current_user: this.data.current_user,
	          mentionRegexMe: this.data.mentionRegexMe,
	          mentionRegexUser: this.data.mentionRegexUser,
	          emoticons: this.data.emoticons,
	          roster: this.data.roster,
	          profiles: this.data.profiles,
	          received_mids: this.local.received_mids,
	          sent_msg_ids: this.local.sent_msg_ids,
	          chat_states: this.local.chat_states,
	          token: this.data.oauth2_token
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleConnectionChange: {
	      value: function handleConnectionChange(data) {
	        /*
	          Status Codes:
	            0: Error
	            1: Connecting
	            2: Connect Fail
	            3: Authenticating
	            4: Auth Fail
	            5: Connected
	            6: Disconnected
	            7: Disconnecting
	            8: Attached
	         */
	        this.data.connection = {
	          connected: [5, 8].indexOf(data.status) != -1,
	          reconnecting: [1, 3].indexOf(data.status) != -1,
	          disconnecting: [7].indexOf(data.status) != -1
	        };
	        this.set("connection", this.data.connection);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleReconnecting: {
	      value: function handleReconnecting() {
	        this.data.connection.reconnecting = true;
	        this.set("connection", this.data.connection);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleArchiveRoom: {
	      value: function handleArchiveRoom(data, archive, cb) {
	        var room = this.data.activeRooms[data.jid];
	        HCApiDispatcher.dispatch("API:update-room", {
	          params: {
	            name: room.name,
	            privacy: room.privacy,
	            is_archived: archive,
	            is_guest_accessible: !!room.guest_url,
	            topic: room.topic,
	            owner: {
	              id: Utils.jid.user_id(room.owner)
	            },
	            id: room.id
	          },
	          path: {
	            identifier: room.id,
	            type: "room"
	          },
	          jid: data.jid
	        }, cb);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return AppStore;
	})(Store);

	module.exports = new AppStore();

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  max_upload_size: 50, //max upload file size in Mb
	  chat_scroll_duration: 200, //The duration of the autoscroll animation when a new message comes in
	  render_twitter_cards: false, //Embedded Twitter cards
	  chat_room_idle_timeout_minutes: 90, //Time to elapse before we begin trimming the history
	  chat_room_trim_buffer: 100, //The minimum number of messages before beginning to trim
	  composing_message_linger_timeout: 6000, //How long "so and so is typing..." messages hang around
	  composing_message_delay_timeout: 1000, //Delay between typing and sending a composing message
	  notification_limit: 5, //limit unique OS notifications
	  message_confirmation_timeout: 6000, //Time elapsed before considering an non-echoed message failed
	  notify_sound_asset: window.assetBaseUri + "assets/audio/notify.mp3", //Url to notify sound asset
	  notification_close_timeout: 5000, //The duration that desktop notifications hang around
	  message_filter_predicate: _.constant(true), //An optional predicate to filter messages
	  notification_banner_slide: 200, //The duration of the notification banner slide
	  notification_icon: window.assetBaseUri + "assets/img/embedded/notification.png",
	  favicon_bg_color: "#707070", //Background color for the favicon notification badge
	  favicon_bg_color_with_mention: "#3873AE", //Background color for the favicon notification badge, when the user is mentioned
	  slash_replacement_regex: new RegExp("^s/([^/]+)/([^/]+)/?$"), //S-slash command replacement regex
	  column_width_limits: { //Column width limits
	    left: {
	      max: 450,
	      min: 95,
	      "default": 220
	    },
	    right: {
	      max: 450,
	      min: 95,
	      "default": 200
	    }
	  },
	  ace_stp_iframe_url: "https://ace-cdn.atlassian.com/stp/current/dialog/ace-stp-dialog-hipchat-web.html"
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var moment = __webpack_require__(64);
	var linkify = __webpack_require__(23);
	var emoticons = __webpack_require__(5);
	var Promise = __webpack_require__(69).Promise;
	var file_types = __webpack_require__(24);
	var mime_types = __webpack_require__(25);
	var ObjectPath = __webpack_require__(63);

	var Utils = {

	  TRUNCATE_CHARS: 800,
	  TRUNCATE_LINES: 6,

	  emoticons: emoticons.init(),
	  file_types: file_types.init(),
	  url_regex: linkify.RE_URL,
	  roster_names: {}, // roster names keyed by mention name
	  core_mention_names: {
	    all: "all",
	    here: "here",
	    HipChat: "HipChat"
	  },

	  log: function log(obj) {
	    if (typeof window != "undefined" && window.HC_LOG && "console" in window) {
	      console.info.apply(console, ["[DEBUG]"].concat(Array.prototype.slice.call(arguments, 0)));
	    }
	  },

	  /**
	   * Checks if the object has the following property. If not, returns a default if supplied.
	   * @param {object} obj
	   * @param {string} dot separated path
	   * @param {object} [default = false]
	   * @returns {object} value of property or default value
	   */
	  dot: function dot(obj, path, dflt) {
	    if (!obj) {
	      return false;
	    }
	    var props = ObjectPath.parse(path),
	        i = 0,
	        propChain = obj,
	        currProp;
	    while (propChain = propChain[props[i++]]) {
	      currProp = propChain;
	    }
	    return i - 1 === props.length ? currProp : dflt || false;
	  },

	  getOriginFromUrl: function getOriginFromUrl(url) {
	    var pathArray = url.split("/"),
	        protocol = pathArray[0],
	        host = pathArray[2];
	    return protocol + "//" + host;
	  },

	  /**
	   * merges two objects then removes properties with leading underscores
	   * if the same property without an underscore already exists
	   * @param {object} data
	   * @param {object} data
	   */
	  mergeAndSquash: function mergeAndSquash(obj1, obj2) {
	    var newObj = _.merge(obj1, obj2);
	    if ("jid" in newObj) {
	      newObj.key = newObj.jid.split("@")[0];
	    }
	    _.forEach(newObj, function (v, k) {
	      if (/^_/.test(k) && newObj.hasOwnProperty(k.substring(1))) {
	        delete newObj[k];
	      }
	    });
	    return newObj;
	  },

	  camelToSnake: function camelToSnake(str) {
	    return str.replace(/\W+/g, "_").replace(/([a-z\d])([A-Z])/g, "$1_$2").toLowerCase();
	  },

	  generateMID: function generateMID() {
	    var d = new Date().getTime();
	    var id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
	      var r = (d + Math.random() * 16) % 16 | 0;
	      d = Math.floor(d / 16);
	      return (c == "x" ? r : r & 7 | 8).toString(16);
	    });
	    return id;
	  },

	  extractJID: function extractJID(jid) {
	    return jid.split("/")[0];
	  },

	  format_time: function format_time(time, is24hr) {
	    var format = is24hr ? "HH:mm" : "h:mm A";

	    if (!time) {
	      return this.getCurrentTime().format(format);
	    } else if (/^-?\d*\.?\d*$/.test(time)) {
	      time = moment.unix(time);
	    }

	    time = moment(time);

	    if (!this.getCurrentTime().isSame(time, "day")) {
	      format = "MMM-D " + format;
	    }

	    return time.format(format);
	  },

	  getCurrentTime: function getCurrentTime() {
	    return moment();
	  },

	  format_time_for_history: function format_time_for_history(time) {
	    var offset = -moment().utcOffset();
	    return moment.unix(time).add(offset, "m").format("YYYY-MM-DDTHH:mm:ss") + "Z";
	  },

	  format_time_for_separator: function format_time_for_separator(time) {
	    return moment.unix(time).format("dddd MMMM D, YYYY");
	  },

	  getMoment: function getMoment(time) {
	    if (time) {
	      return moment(time).unix();
	    } else {
	      return moment().unix();
	    }
	  },

	  toArray: function toArray(obj) {
	    if (_.isArray(obj)) {
	      return obj;
	    } else {
	      return [obj];
	    }
	  },

	  escape: function escape(str) {
	    if (!str) {
	      return str;
	    }

	    str = str.replace(/&/g, "&amp;");
	    str = str.replace(/</g, "&lt;");
	    str = str.replace(/>/g, "&gt;");

	    return str;
	  },

	  get_roster_name: function get_roster_name(mention_name) {
	    var name = "";
	    if (!_.isEmpty(Utils.roster_names) && Utils.roster_names[mention_name]) {
	      name = Utils.roster_names[mention_name];
	    }
	    return name;
	  },

	  formatMessageBody: function formatMessageBody(message) {
	    //This gets extended by the message processor
	    return message;
	  },

	  escapeAndLinkify: function escapeAndLinkify(str, args) {
	    args = _.defaults(args || {}, {
	      name_tag_regex: null,
	      mention_regex: null,
	      escape_whitespace: false,
	      matches: null,
	      do_escape: true,
	      do_linkify: true,
	      do_emoticons: true,
	      do_word_breaks: true,
	      do_mentions: true
	    });
	    var name_regex = _.result(args, "name_tag_regex");
	    var mention_regex = _.result(args, "mention_regex");
	    var escape_whitespace = _.result(args, "escape_whitespace");
	    var matches = _.result(args, "matches");
	    var do_escape = _.result(args, "do_escape");
	    var do_linkify = _.result(args, "do_linkify");
	    var do_emoticons = _.result(args, "do_emoticons");
	    var do_word_breaks = _.result(args, "do_word_breaks");
	    var do_mentions = _.result(args, "do_mentions");

	    var TOKEN_SEPARATOR = " ";
	    str = str.split(TOKEN_SEPARATOR).map(function (token) {
	      if (do_escape) {
	        token = this.escape(token);
	      }

	      var linkified = false;
	      if (do_linkify) {
	        // Do hex preview before linkification since links add hex strings
	        token = token.replace(/(?:^|\b)(#[\da-fA-F]{6})\b/gm, "$1 <span class='hexPreview' style='background-color: $1'>&nbsp;</span>");

	        var token_matches = [];
	        token = linkify.linkify(token, token_matches, {
	          truncate_length: 100,
	          add_wbrs: do_word_breaks
	        });
	        linkified = !_.isEmpty(token_matches);
	        // a nice little side-effect here with matches is that it acts as an accumulator
	        matches = _.union(matches, token_matches);
	      }

	      // Add check for emoticonification
	      if (!linkified && do_emoticons) {
	        token = emoticons.render(token);
	      }

	      if (!linkified && do_mentions) {
	        if (name_regex) {
	          token = token.replace(name_regex, "<span class='hc-mention-user hc-mention-me'>$1</span>");
	        }
	        if (mention_regex) {
	          var matches = token.match(mention_regex);
	          if (matches && matches[0]) {
	            var mentionKey = matches[0].substr(1);
	            var userName = Utils.get_roster_name(mentionKey);
	            var content = "<span class='hc-mention-user'><a onClick='HC.Actions.AppActions.openChat(this)' title='" + userName + "' data-mention-name='$1'>$1</a></span>";
	            token = token.replace(mention_regex, content);
	          }
	        }
	      }

	      return token;
	    }, this).join(TOKEN_SEPARATOR);

	    // Add br's AFTER linkifying - doing it before could result in bad linkify
	    if (escape_whitespace) {
	      str = str.replace(/\r\n/g, "\n").replace(/[\r\n\u2028]/g, "<br />");
	    }

	    if (matches && matches.length == 0 && do_word_breaks && !/[<>]/.test(str)) {
	      // Break at commas first (for JSON)
	      str = str.replace(/(,)/g, "$1<wbr>");
	      // Also break if we have a string of 70 characters w/o spaces (and no wbrs)
	      str = str.replace(/([^<>\s]{70})/g, "$1<wbr>");
	    }

	    if (escape_whitespace) {
	      if (str.indexOf("  ") != -1) str = str.replace(/  /g, "&ensp;&ensp;");
	      if (str.indexOf("\t") != -1) str = str.replace(/\t/g, "&ensp;&ensp;");
	    }

	    return str;
	  },

	  fetch: function fetch(val, dflt) {
	    return val || dflt;
	  },

	  formatNumber: function formatNumber(num) {
	    if (typeof num !== "string" && num.toString) {
	      num = num.toString();
	    }
	    return num.replace(/\B(?=(\d{3})+(?!\d))/g, ",") || num;
	  },

	  formatMultilineBlock: function formatMultilineBlock(text) {
	    var matches = text.match(/\n.+/gm);
	    if (!matches) {
	      return text;
	    }

	    // Add one to numlines because the last line won't have a \n on it
	    var numLines = matches.length + 1;
	    if (numLines > 1) {
	      matches = text.match(/^(  |\t)/gm);
	      // remove leading whitespace common to all lines
	      while (matches && matches.length == numLines) {
	        text = text.replace(/^(  |\t)/gm, "");
	        matches = text.match(/^(  |\t)/gm);
	      }
	    }
	    return text;
	  },

	  get_file_size_string: function get_file_size_string(size) {
	    if (!size) {
	      return "";
	    }

	    var precision = size > 1024 ? 0 : 2;
	    var sizeString = Number(size / 1024).toFixed(precision);
	    var magnitude = "K";
	    if (size > 1048576) {
	      precision = 1;
	      sizeString = Number(size / 1048576).toFixed(precision);
	      magnitude = "MB";
	    }

	    return sizeString + magnitude;
	  },

	  isHistoryMessage: function isHistoryMessage(message) {
	    return typeof message.delay != "undefined";
	  },

	  getSenderFromMeta: function getSenderFromMeta(type) {
	    switch (type) {
	      case "video":
	        return "Video";
	        break;
	      case "twitter_status":
	      case "twitter_user":
	        return "Twitter";
	        break;
	      case "link":
	        return "Link";
	        break;
	      default:
	        return "HipChat";
	        break;
	    }
	  },

	  getCaretPosition: function getCaretPosition(input) {
	    if ("selectionStart" in input) {
	      return input.selectionStart;
	    } else if (document.selection) {
	      // IE
	      input.focus();
	      var sel = document.selection.createRange();
	      var selLen = document.selection.createRange().text.length;
	      sel.moveStart("character", -input.value.length);
	      return sel.text.length - selLen;
	    };
	  },

	  setCaretPosition: function setCaretPosition(input, posn) {
	    if (input.createTextRange) {
	      var range = input.createTextRange();
	      range.move("character", posn);
	      range.select();
	    } else {
	      if (input.selectionStart) {
	        input.focus();
	        input.setSelectionRange(posn, posn);
	        input.focus();
	      } else input.focus();
	    }
	  },

	  // Mimicks webkit's scrollIntoViewIfNeeded for other browsers
	  // https://gist.github.com/hsablonniere/2581101
	  scrollIntoViewIfNeeded: function scrollIntoViewIfNeeded(node, parent, centerIfNeeded) {
	    centerIfNeeded = arguments.length === 0 ? true : !!centerIfNeeded;

	    if ("scrollIntoViewIfNeeded" in node) {
	      node.scrollIntoViewIfNeeded(centerIfNeeded);
	      return;
	    }

	    var parentComputedStyle = window.getComputedStyle(parent, null),
	        parentBorderTopWidth = parseInt(parentComputedStyle.getPropertyValue("border-top-width")),
	        parentBorderLeftWidth = parseInt(parentComputedStyle.getPropertyValue("border-left-width")),
	        overTop = node.offsetTop - parent.offsetTop < parent.scrollTop,
	        overBottom = node.offsetTop - parent.offsetTop + node.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight,
	        overLeft = node.offsetLeft - parent.offsetLeft < parent.scrollLeft,
	        overRight = node.offsetLeft - parent.offsetLeft + node.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth,
	        alignWithTop = overTop && !overBottom;

	    if ((overTop || overBottom) && centerIfNeeded) {
	      parent.scrollTop = node.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + node.clientHeight / 2;
	    }

	    if ((overLeft || overRight) && centerIfNeeded) {
	      parent.scrollLeft = node.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + node.clientWidth / 2;
	    }

	    if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
	      node.scrollIntoView(alignWithTop);
	    }
	  },

	  user: {
	    get_user_name: function get_user_name(users, group_id, user_id) {
	      var jid_fragment = group_id + "_" + user_id,
	          user_name = "Unknown";
	      _.find(users, function (val, key) {
	        if (key.indexOf(jid_fragment) > -1) {
	          user_name = val.name;
	        }
	      });
	      return user_name;
	    },

	    get_user_status: function get_user_status(presence_show) {
	      var status;

	      switch (presence_show) {
	        case "chat":
	          status = "Available";
	          break;
	        case "away":
	          status = "Idle";
	          break;
	        case "dnd":
	          status = "Do not disturb";
	          break;
	        case "mobile":
	          status = "Mobile";
	          break;
	        case "unknown":
	          status = "Unavailable";
	          break;
	      }
	      return status;
	    },

	    chat_header_status: function chat_header_status(presence_status) {
	      var status;
	      switch (presence_status) {
	        case "chat":
	          status = "Available";
	          break;
	        case "away":
	          status = "Away";
	          break;
	        case "dnd":
	          status = "Do Not Disturb";
	          break;
	        case "mobile":
	          status = "Mobile";
	          break;
	        case "unknown":
	          status = "Unavailable";
	          break;
	        default:
	          status = "Unknown";
	      }
	      return status;
	    },

	    format_idle_time: function format_idle_time(seconds) {
	      var time_msg = "",
	          days = Math.floor(seconds / 86400),
	          hours = Math.floor(seconds % 86400 / 3600),
	          mins = Math.floor(seconds % 86400 % 3600 / 60);

	      if (days > 0) {
	        time_msg = days + "d ";
	      }
	      if (hours > 0) {
	        time_msg += hours + "h ";
	      }
	      if (mins > 0) {
	        time_msg += mins + "m";
	      }
	      return $.trim(time_msg);
	    },

	    is_admin: function is_admin(admins, owner, user) {
	      var result = false,
	          jid = Utils.dot(user, "user_jid") || Utils.dot(user, "jid");
	      if (Utils.dot(user, "is_admin")) {
	        result = true;
	      } else if (jid) {
	        if (admins) {
	          result = _.some(admins, function (val) {
	            return val == jid;
	          });
	        }
	        if (!result && owner) {
	          result = owner === jid;
	        }
	      }
	      return result;
	    }
	  },

	  file: {
	    get_extension: function get_extension(filename) {
	      var file = filename.split("/").pop(),
	          ext = file.split(".").pop();
	      return ext === file ? "" : ext.toLowerCase();
	    },

	    get_extension_for_mime_type: function get_extension_for_mime_type(mimeType) {
	      if (mime_types[mimeType]) {
	        return mime_types[mimeType];
	      } else if (mimeType.split("/").pop().length === 3) {
	        return mimeType.split("/").pop();
	      }
	    },

	    get_file_type: function get_file_type(filename, return_default) {
	      var extension = this.get_extension(filename),
	          type;
	      _.find(Utils.file_types, function (extension_list, key) {
	        if (_.contains(extension_list, extension)) {
	          type = key;
	        }
	      });
	      return return_default ? type || "text" : type;
	    },

	    get_icon_class: function get_icon_class(filename) {
	      var file_type = this.get_file_type(filename);
	      return file_type ? "icon-" + file_type : "icon-text";
	    },

	    create_file_object: function create_file_object(jid, file, ts, sender_name) {
	      return {
	        id: _.uniqueId(),
	        name: file.name,
	        thumbnail: file.thumb,
	        bucket: file.bucket,
	        size: file.size,
	        desc: file.desc,
	        group_id: Utils.jid.group_id(jid),
	        user_name: sender_name,
	        date: moment.utc(ts * 1000).format("YYYY-MM-DDTHH:mm:ss") + "Z",
	        file_url: file.file_url,
	        thumb_url: file.thumb_url,
	        icon_class: Utils.file.get_icon_class(file.name)
	      };
	    }
	  },

	  room: {
	    get_room_name: function get_room_name(rooms, room_jid) {
	      return rooms[room_jid] ? rooms[room_jid].name : "Unknown";
	    },

	    get_room_id: function get_room_id(rooms, room_jid) {
	      return rooms[room_jid] ? rooms[room_jid].id : false;
	    },

	    detect_chat_type: function detect_chat_type(jid) {
	      return Utils.jid.is_room(jid) ? "groupchat" : "chat";
	    },

	    is_archived: function is_archived(room) {
	      return !!parseInt(room.is_archived, 10) && room.is_archived != "";
	    }
	  },

	  roster: {
	    format_for_select2: function format_for_select2(participants, roster) {
	      var roster_jids = _.keys(roster),
	          invite_user_jids = _.difference(roster_jids, participants),
	          sorted_roster;

	      sorted_roster = _.sortBy(_.map(invite_user_jids, function (user_jid) {
	        return roster[user_jid];
	      }), function (person) {
	        return person.name;
	      });

	      return _.map(sorted_roster, function (person) {
	        return {
	          id: person.jid,
	          text: person.name
	        };
	      });
	    }
	  },

	  link: {
	    create_link_object: function create_link_object(jid, ts, message_body, sender_name) {
	      var url = Utils.link.get_urls_from_string(message_body)[0];
	      return {
	        date: moment.utc(ts * 1000).format("YYYY-MM-DDTHH:mm:ss") + "Z",
	        group_id: Utils.jid.group_id(jid),
	        id: _.uniqueId(),
	        user_name: sender_name,
	        url: url,
	        display_url: url.replace(/.*?:\/\//g, "")
	      };
	    },

	    get_urls_from_string: function get_urls_from_string(string) {
	      return string.match(Utils.url_regex);
	    }
	  },

	  jid: {
	    display_names: {},

	    bare_jid: function bare_jid(val) {
	      if (!val) {
	        return false;
	      }return val.split("/")[0];
	    },

	    domain: function domain(val) {
	      if (!val) {
	        return false;
	      }return val.split("@")[1].split("/")[0];
	    },

	    group_id: function group_id(val) {
	      var node = this.node(val);
	      var id = node.substr(0, node.indexOf("_"));
	      return parseInt(id, 10);
	    },

	    is_private_chat: function is_private_chat(val) {
	      return !this.is_room(val);
	    },

	    is_room: function is_room(val) {
	      return /@conf/.test(val);
	    },

	    node: function node(val) {
	      if (!val) {
	        return false;
	      }return val.split("@")[0];
	    },

	    resource: function resource(val) {
	      // we don't want to use val.split('/') here because there may be a slash
	      // in the resource
	      var i = val.indexOf("/");
	      if (i == -1) {
	        return null;
	      }
	      return val.substr(i + 1);
	    },

	    room_name: function room_name(val) {
	      var node = this.node(val);
	      var name = node.substr(node.indexOf("_") + 1);
	      return name;
	    },

	    // used to sanitize jids before using them in something HTML/Xpath like a jQuery search
	    sanitize: function sanitize(val) {
	      return val.replace("\\", "\\\\");
	    },

	    user_id: function user_id(val) {
	      var node = this.node(val);
	      var id = node.substr(node.indexOf("_") + 1);
	      if (id.match(/[0123456789]+/)) {
	        return parseInt(id, 10);
	      }

	      return null;
	    },

	    user_name: function user_name(jid) {
	      return jid.split("/")[1];
	    },

	    get_display_name: function get_display_name(jid, default_name) {

	      if (typeof default_name == "undefined") {
	        default_name = "Unknown";
	      }
	      if (!jid || typeof jid == "undefined") {
	        return default_name;
	      }

	      jid = this.bare_jid(jid);
	      var member = this.display_names[jid];
	      if (member) {
	        return member.name;
	      }

	      return default_name;
	    }

	  },

	  promise: {

	    defer: function defer() {
	      var result = {};
	      result.promise = new Promise(function (resolve, reject) {
	        result.resolve = resolve;
	        result.reject = reject;
	      });
	      return result;
	    }
	  },

	  timings: {
	    getPerfTiming: function getPerfTiming() {

	      var perfTimingKeys = [
	      //"navigationStart",
	      "unloadEventStart", "unloadEventEnd", "redirectStart", "redirectEnd", "fetchStart", "domainLookupStart", "domainLookupEnd", "connectStart", "connectEnd", "secureConnectionStart", "requestStart", "responseStart", "responseEnd", "domLoading", "domInteractive", "domContentLoadedEventStart", "domContentLoadedEventEnd", "domComplete", "loadEventStart", "loadEventEnd"];

	      if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart !== "undefined") {
	        var metrics = {};
	        perfTimingKeys.forEach(function (property) {
	          var value = window.performance.timing[property] - window.performance.timing.navigationStart;
	          if (value > 0) {
	            metrics[property] = value;
	          }
	        });

	        if (window.performance.now) {
	          metrics.readyForUser = Math.floor(window.performance.now());
	        }
	        return metrics;
	      } else {
	        return {};
	      }
	    }
	  }

	};

	module.exports = Utils;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var EMOTICON_FINDER = /\([A-Z0-9]+\)/gim;

	function getEmoteRegex(shortcut) {
	  // Capture space/beginning char in regex to avoid emoticoning links like
	  // http://coderwall.com/p/euwpig?i=3&p=1&t=git (& becomes &amp; and matches ;p)
	  return new RegExp("(?:<([A-Z][A-Z0-9]*)\\b.*?(?:\\/>|<\\/\\1>)|(" + shortcut + ")(?!\\w))", "gim");
	}

	var Emoticons = {
	  path_prefix: "/",
	  emoticons: {},
	  smileys: {},
	  resolution: Math.ceil(window.devicePixelRatio),

	  init: function init() {
	    this.addSmileys(this.emoticons);
	    return this;
	  },

	  addSmileys: function addSmileys(smileys) {
	    var _this = this;

	    this.smileys = smileys;
	    _.each(this.smileys, function (smiley) {
	      if (_this.resolution && ! ~smiley.file.indexOf("@" + _this.resolution + "x")) {
	        smiley.file = [smiley.file.split(".")[0] + (_this.resolution && _this.resolution > 1 ? "@" + _this.resolution + "x" : ""), smiley.file.split(".")[1]].join(".");
	      }
	      if (smiley.shortcut === ":") {
	        smiley.shortcut = ":\\";
	      }
	      smiley.regex = getEmoteRegex(smiley.regex);
	    });

	    return this.smileys;
	  },

	  /**
	   * Add an word-based emoticon to the list of emoticons to check for
	   *
	   * @param filename - Name of the image file (the full path is created in the emoticon_text function)
	   * @param shortcut - Text used to create the emoticon (e.g. "embarrassed" or "puking" )
	   * @param height - Height in pixels of the image
	   * @param width - Width in pixels of the image
	   **/
	  add: function add(filename, shortcut, height, width) {
	    var str = "(" + shortcut + ")";
	    // Capture optional space char in regex to be compatible with non paren emoticons
	    // We need to check for space with emoticons like ;p to avoid emoticoning links like
	    // http://coderwall.com/p/euwpig?i=3&p=1&t=git (& becomes &amp; and matches ;p)
	    this.emoticons[str] = {
	      file: filename,
	      height: height,
	      width: width,
	      shortcut: "(" + shortcut + ")"
	    };
	  },

	  addBulk: function addBulk(emoticons) {
	    var _this = this;

	    _.each(emoticons, function (emoticon) {
	      return _this.add(emoticon.path, emoticon.shortcut, emoticon.h, emoticon.w);
	    });

	    return this.emoticons;
	  },

	  getEmoticons: function getEmoticons(message) {
	    return message.match(EMOTICON_FINDER) || [];
	  },

	  /**
	   * Replace text emoticons with images
	   **/
	  render: function render(message) {
	    var _this = this;

	    var emoticons = this.getEmoticons(message);
	    if (emoticons.length) {
	      _.each(emoticons, function (shortcut) {
	        var emoticon = _this.emoticons[shortcut];
	        if (emoticon) {
	          message = _this._replaceWithImage(message, emoticon);
	        }
	      });
	    }

	    _.each(this.smileys, function (smiley) {
	      return message = _this._replaceWithImage(message, smiley);
	    });

	    return message;
	  },

	  _replaceWithImage: function _replaceWithImage(text, emoticon) {
	    var src = this.path_prefix + "/" + emoticon.file;
	    if (!emoticon.regex) {
	      emoticon.regex = getEmoteRegex("\\(" + emoticon.shortcut + "\\)");
	    }

	    // (not a word character)(smiley regex)(not a word character)
	    return text.replace(emoticon.regex, function (match, p1, p2) {
	      if (p2) {
	        return "<img class=\"remoticon\" title=\"" + emoticon.shortcut + "\" alt=\"" + emoticon.shortcut + "\" height=\"" + (parseInt(emoticon.height) > 26 ? 26 : emoticon.height) + "\" src=\"" + src + "\" />";
	      } else {
	        return match;
	      }
	    });
	  },

	  renderConsole: function renderConsole(message) {
	    try {
	      var emoticons = this.getEmoticons(message);
	      var font = "font-family: Helvetica Neue, Helvetica, Arial; font-size: 14px; font-weight: bold;";
	      var msg = "%c" + message,
	          args = [font];
	      _(emoticons).map(this._getEmoticonInfo.bind(this)).filter(_.identity).each(function (e) {
	        msg = msg.replace(e.regex, function (match, p1, p2) {
	          if (p2) return "%c%c";
	        });
	        args.push("font-size: " + e.height + "px; padding-left: " + (e.width + 5) + "px;" + " line-height: 30px; background: url(" + e.src + ") no-repeat 0/auto " + e.height + "px;");
	        args.push(font);
	      });
	      args.unshift(msg);
	      console.log.apply(console, args);
	    } catch (ignored) {}
	  },

	  _getEmoticonInfo: function _getEmoticonInfo(shortcut) {
	    var emoticon = this.emoticons[shortcut],
	        fileName = emoticon.file;
	    if (!emoticon) {
	      return;
	    }if (!emoticon.regex) {
	      emoticon.regex = getEmoteRegex("\\(" + emoticon.shortcut + "\\)");
	    }
	    if (this.resolution && ! ~fileName.indexOf("@" + this.resolution + "x")) {
	      fileName = fileName.split(".").join(this.resolution > 1 ? "@" + this.resolution + "x." : ".");
	    }
	    return {
	      src: this.path_prefix + "/" + fileName,
	      regex: emoticon.regex,
	      height: parseInt(emoticon.height, 10) > 26 ? 26 : emoticon.height,
	      width: parseInt(emoticon.width, 10) > 26 ? 26 : emoticon.width
	    };
	  }
	};

	if (console) console.emote = function (msg) {
	  Emoticons.renderConsole.call(Emoticons, msg);
	};

	module.exports = Emoticons;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RehackedPlaceholder = __webpack_require__(26);

	function Rehacked() {
	  this._hackRegistry = {};
	}

	Rehacked.prototype._getEntry = function (componentName) {
	  return this._hackRegistry[componentName];
	};

	Rehacked.prototype.isAnythingBeingHacked = function () {
	  return this._hackRegistry.length !== 0;
	};

	var _assert = function _assert(condition, message) {
	  if (!condition) throw message;
	};

	Rehacked.prototype.before = function (componentName, selector, opts) {
	  return this._hack(componentName, selector, _.extend({ before: true }, opts));
	};

	Rehacked.prototype.after = function (componentName, selector, opts) {
	  return this._hack(componentName, selector, _.extend({ after: true }, opts));
	};

	Rehacked.prototype.on = function (componentName, selector, opts) {
	  return this._hack(componentName, selector, _.extend({ on: true }, opts));
	};

	Rehacked.prototype.isBeingHacked = function (componentName) {
	  return typeof this._hackRegistry[componentName] !== "undefined";
	};

	Rehacked.prototype._hack = function (componentName, selector, opts) {
	  _assert(componentName, "You must specify a component type to hack");
	  _assert(selector, "A selector needs to be defined");
	  _assert(opts.before || opts.after || opts.on, "You gotta specify a place for the hack to appear");

	  var isComponentBeingHacked = this.isBeingHacked(componentName);
	  var entry = {
	    selector: Slick.parse(selector),
	    before: opts.before,
	    after: opts.after,
	    on: opts.on,
	    lifecycle: opts.lifecycle || {},
	    props: opts.props || {},
	    node: opts.node || "div"
	  };

	  if (isComponentBeingHacked) {
	    this._hackRegistry[componentName].push(entry);
	  } else {
	    this._hackRegistry[componentName] = [entry];
	  }
	};

	Rehacked.prototype._clear = function () {
	  this._hackRegistry = {};
	};

	var rehacked = new Rehacked();

	function wrapIfNeeded(val) {
	  return _.isArray(val) ? val : [val];
	}

	function binarySearch(expression, idx, nodeChildren, hack) {
	  var theEnd = expression.length === idx + 1;
	  var selector = expression[idx];
	  var foundChildren = [];
	  _(nodeChildren).each(function (child) {
	    if (_.isArray(child)) {
	      binarySearch(expression, idx, child, hack);
	    } else {
	      var matches = testAtNode(selector, child);
	      var hasChildren = child.props && child.props.children;
	      if (!matches && hasChildren) {
	        child.props.children = wrapIfNeeded(child.props.children);
	        binarySearch(expression, idx, child.props.children, hack);
	      } else if (matches && !theEnd && hasChildren) {
	        child.props.children = wrapIfNeeded(child.props.children);
	        binarySearch(expression, idx + 1, child.props.children, hack);
	      } else if (matches && theEnd) {
	        foundChildren.push(child);
	      }
	    }
	  });
	  _.each(foundChildren, function (foundChild) {
	    var idx = nodeChildren.indexOf(foundChild);
	    var hackedPlaceHolder = React.createElement(RehackedPlaceholder, { node: hack.node, props: hack.props, lifecycle: hack.lifecycle });
	    if (hack.before) {
	      nodeChildren.splice(idx, 0, hackedPlaceHolder);
	    } else if (hack.after) {
	      nodeChildren.splice(idx + 1, 0, hackedPlaceHolder);
	    } else if (hack.on) {
	      nodeChildren.splice(idx, 1, hackedPlaceHolder);
	    }
	  });
	}

	function testAtNode(selector, node) {
	  //TODO: Add support for modifiers (first child, etc.)
	  var matching = true;

	  if (matching && selector.tag && selector.tag !== "*") {
	    matching = node.type === selector.tag || node.type && node.type.displayName === selector.tag;
	  }

	  if (matching && selector.classes) {
	    matching = node.props && node.props.className && _(selector.classes).pluck("regexp").every(function (regexp) {
	      return regexp.test(node.props.className);
	    });
	  }

	  if (matching && selector.id) {
	    matching = node.props.id === selector.id;
	  }

	  if (matching && selector.pseudos) {
	    throw "rehacked doesn't understand pseudo classes (yet)";
	  }

	  if (matching && selector.attributes) {
	    matching = _(selector.attributes).every(function (attribute) {
	      var value = node.props[attribute.key];
	      return value && attribute.test(value);
	    });
	  }

	  return matching;
	}

	var _createClass = React.createClass;
	React.createClass = function (spec /*, arguments*/) {
	  var _render = spec.render;
	  var componentName = spec.displayName;
	  if (rehacked.isAnythingBeingHacked() && rehacked.isBeingHacked(componentName)) {

	    var hacks = rehacked._getEntry(componentName);

	    spec.render = function () {
	      var renderedComponent = _render.apply(this, arguments);

	      hacks.forEach(function (hack) {
	        var expressions = hack.selector.expressions;
	        expressions && expressions.forEach(function (expression) {
	          binarySearch(expression, 0, [renderedComponent], hack);
	        });
	      });

	      return renderedComponent;
	    };
	  }
	  return _createClass.apply(React, arguments);
	};

	module.exports = rehacked;
	/* arguments */

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AnalitycsDispatcher = __webpack_require__(62);

	module.exports = new AnalitycsDispatcher();

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var HCApiDispatcher = __webpack_require__(62);

	module.exports = new HCApiDispatcher();

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var HCApiClient = (function () {
	  function HCApiClient(token, api_root) {
	    var _this = this;

	    _classCallCheck(this, HCApiClient);

	    this.token = token;
	    this.api_root = "https://" + (api_root || "api.hipchat.com") + "/v2/";

	    this.room = {

	      recent_history: function (data, callback) {
	        _this.request("GET", "room/" + data.path.identifier + "/history/latest", data.params, callback);
	      },

	      invite_users: function (data, callback) {
	        _this.request("POST", "room/" + data.path.identifier + "/invite/" + data.user_id, data.params, callback);
	      },

	      update_room: function (data, callback) {
	        _this.request("PUT", "room/" + data.path.identifier, data.params, callback, true);
	      }

	    };

	    this.user = {

	      recent_history: function (data, callback) {
	        _this.request("GET", "user/" + data.path.identifier + "/history/latest", data.params, callback);
	      }

	    };
	  }

	  _prototypeProperties(HCApiClient, null, {
	    url: {
	      value: (function (_url) {
	        var _urlWrapper = function url() {
	          return _url.apply(this, arguments);
	        };

	        _urlWrapper.toString = function () {
	          return _url.toString();
	        };

	        return _urlWrapper;
	      })(function (path, query) {
	        var url = this.api_root + escape(path),
	            query = _.omit(query, function (val) {
	          return !val;
	        }),
	            queryString = function queryString(query) {
	          var query_string = !_.isEmpty(query) ? "?" : "";
	          for (var key in query) {
	            if (query[key]) query_string += key + "=" + query[key];
	            query_string += "&";
	          }
	          return query_string;
	        };
	        if (!query) {
	          return url;
	        } else if (typeof query === "object") {
	          return url + queryString(query);
	        }
	      }),
	      writable: true,
	      configurable: true
	    },
	    getUrl: {
	      value: function getUrl(path, payload, postJSON) {
	        if (postJSON) {
	          return this.url(path);
	        } else {
	          return this.url(path, payload);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    request: {
	      value: function request(method, path, payload, callback, postJSON) {
	        var xhr = new XMLHttpRequest(),
	            token = this.token,
	            handleSend = this.handleSend,
	            handleResponse = this.handleResponse,
	            url = this.getUrl(path, payload, postJSON);

	        xhr.onreadystatechange = function () {
	          if (xhr.readyState == 1) {
	            handleSend(xhr, token, payload, postJSON);
	          }
	          if (xhr.readyState == 4) {
	            handleResponse(xhr.response, callback);
	          }
	        };

	        if ("withCredentials" in xhr) {
	          xhr.open(method, url, true);
	        } else if (typeof XDomainRequest != "undefined") {
	          xhr = new XDomainRequest();
	          xhr.open(method, url);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleSend: {
	      value: function handleSend(xhr, token, payload, postJSON) {
	        xhr.setRequestHeader("Authorization", "Bearer " + token);

	        if (postJSON) {
	          xhr.setRequestHeader("Content-Type", "application/json");
	          xhr.send(JSON.stringify(payload));
	        } else {
	          xhr.send();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleResponse: {
	      value: function handleResponse(response, callback) {
	        if (response !== "") {
	          response = JSON.parse(response);
	        }
	        callback(response);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return HCApiClient;
	})();

	module.exports = HCApiClient;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {

	  uploadFile: function uploadFile(obj) {

	    var reader = new FileReader();
	    reader.readAsBinaryString(obj.file);
	    reader.onloadend = function (evt) {

	      var xhr = new XMLHttpRequest();

	      xhr.open("POST", "/api/upload_file", true);

	      XMLHttpRequest.prototype.mySendAsBinary = function (obj, text) {
	        var data = new ArrayBuffer(text.length),
	            ui8a = new Uint8Array(data, 0),
	            formData = new FormData(),
	            blob;
	        for (var i = 0; i < text.length; i++) ui8a[i] = text.charCodeAt(i) & 255;

	        blob = new Blob([data]);

	        formData.append("user_id", obj.user_id);
	        formData.append("group_id", obj.group_id);
	        formData.append("jid", obj.jid);
	        formData.append("token", obj.token);
	        formData.append("desc", obj.desc);
	        formData.append("Filedata", blob, obj.fileName);

	        this.send(formData);
	      };

	      var eventSource = xhr.upload || xhr;
	      eventSource.addEventListener("progress", function (e) {

	        var position = e.position || e.loaded,
	            total = e.totalSize || e.total,
	            pct = Math.round(position / total);
	        AJS.progressBars.update(obj.progressBarSelector, pct);
	      });

	      xhr.onreadystatechange = function () {
	        if (xhr.readyState == 4) {
	          if (xhr.responseXML.getElementsByTagName("error").length) {
	            obj.error(xhr.responseXML.getElementsByTagName("error")[0].firstChild.nodeValue);
	          } else {
	            obj.success(xhr);
	          }
	          AJS.progressBars.setIndeterminate(obj.progressBarSelector);
	        }
	      };

	      xhr.mySendAsBinary(obj, evt.target.result);
	    };
	  }
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var mousetrap = __webpack_require__(65);
	var KeyboardActions = __webpack_require__(27);
	var DialogActions = __webpack_require__(28);
	var KeyboardShortcutStrings = __webpack_require__(29);

	function focusLobby() {
	  KeyboardActions.openLobby();
	  return false;
	}

	function inviteUsersToRoom() {
	  KeyboardActions.inviteUsersToRoom();
	  return false;
	}

	function createRoom() {
	  KeyboardActions.createRoom();
	  return false;
	}

	function searchHistory() {
	  KeyboardActions.searchHistory();
	  return false;
	}

	function closeRoom() {
	  KeyboardActions.closeRoom();
	  return false;
	}

	function navigateRoomsUp() {
	  KeyboardActions.navigateRoomsUp();
	  return false;
	}

	function navigateRoomsDown() {
	  KeyboardActions.navigateRoomsDown();
	  return false;
	}

	function openSettings() {
	  KeyboardActions.openSettings();
	  return false;
	}

	function toggleSoundNotifications() {
	  KeyboardActions.toggleSoundNotifications();
	  return false;
	}

	function viewShortcuts() {
	  var shortcuts = KeyboardShortcuts.getShortcuts();
	  DialogActions.showKeyboardShortcutsDialog(shortcuts);
	  return false;
	}

	var KeyboardShortcuts = {

	  init: function init(platform) {
	    this.isMac = platform.toUpperCase().indexOf("MAC") !== -1;
	    this.bindEvents();
	  },

	  bindEvents: function bindEvents() {
	    var events = this.getShortcuts();

	    _.forOwn(events, function (data, event) {
	      mousetrap.bind(event, data.action);
	    });
	  },

	  getShortcuts: function getShortcuts() {
	    if (this.isMac) {
	      return this.macShortcuts;
	    } else {
	      return this.winShortcuts;
	    }
	  },

	  winShortcuts: {
	    "ctrl+j": {
	      title: KeyboardShortcutStrings.new_chat,
	      action: focusLobby,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: "J"
	      }]
	    },
	    "ctrl+i": {
	      title: KeyboardShortcutStrings.room_invite_users,
	      action: inviteUsersToRoom,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: "I"
	      }]
	    },
	    "ctrl+alt+w": {
	      title: KeyboardShortcutStrings.close_room,
	      action: closeRoom,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.alt
	      }, {
	        type: "normal",
	        name: "W"
	      }]
	    },
	    "ctrl+alt+up": {
	      title: KeyboardShortcutStrings.navigate_rooms_up,
	      action: navigateRoomsUp,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.alt
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.up_arrow
	      }]
	    },
	    "ctrl+alt+down": {
	      title: KeyboardShortcutStrings.navigate_rooms_down,
	      action: navigateRoomsDown,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.alt
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.down_arrow
	      }]
	    },
	    "ctrl+alt+f": {
	      title: KeyboardShortcutStrings.search_history,
	      action: searchHistory,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.alt
	      }, {
	        type: "normal",
	        name: "F"
	      }]
	    },
	    "ctrl+shift+s": {
	      title: KeyboardShortcutStrings.toggle_sound_notifications,
	      action: toggleSoundNotifications,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.shift
	      }, {
	        type: "normal",
	        name: "S"
	      }]
	    },
	    "ctrl+/": {
	      title: KeyboardShortcutStrings.view_shortcuts,
	      action: viewShortcuts,
	      keys: [{
	        type: "normal",
	        name: KeyboardShortcutStrings.control
	      }, {
	        type: "normal",
	        name: "/"
	      }]
	    }
	  },

	  macShortcuts: {
	    "command+j": {
	      title: KeyboardShortcutStrings.new_chat,
	      action: focusLobby,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: "J"
	      }]
	    },
	    "command+i": {
	      title: KeyboardShortcutStrings.room_invite_users,
	      action: inviteUsersToRoom,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: "I"
	      }]
	    },
	    "command+option+w": {
	      title: KeyboardShortcutStrings.close_room,
	      action: closeRoom,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.option
	      }, {
	        type: "normal",
	        name: "W"
	      }]
	    },
	    "command+option+up": {
	      title: KeyboardShortcutStrings.navigate_rooms_up,
	      action: navigateRoomsUp,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.option
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.up_arrow
	      }]
	    },
	    "command+option+down": {
	      title: KeyboardShortcutStrings.navigate_rooms_down,
	      action: navigateRoomsDown,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.option
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.down_arrow
	      }]
	    },
	    "command+option+f": {
	      title: KeyboardShortcutStrings.search_history,
	      action: searchHistory,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.option
	      }, {
	        type: "normal",
	        name: "F"
	      }]
	    },
	    "command+shift+s": {
	      title: KeyboardShortcutStrings.toggle_sound_notifications,
	      action: toggleSoundNotifications,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: KeyboardShortcutStrings.shift
	      }, {
	        type: "normal",
	        name: "S"
	      }]
	    },
	    "command+/": {
	      title: KeyboardShortcutStrings.view_shortcuts,
	      action: viewShortcuts,
	      keys: [{
	        type: "modifier",
	        name: KeyboardShortcutStrings.command
	      }, {
	        type: "normal",
	        name: "/"
	      }]
	    }
	  }

	};

	module.exports = KeyboardShortcuts;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var eventQueue = [];

	var AnalyticsEngine = __webpack_require__(30);
	var AnalyticsEvents = __webpack_require__(31);
	var AnalyticsDispatcher = __webpack_require__(7);
	var herment = __webpack_require__(32);
	var Utils = __webpack_require__(4);

	module.exports = function (initState) {
	  var analyticsEngine = new AnalyticsEngine(initState, AnalyticsEvents.events, AnalyticsDispatcher, eventQueue);
	  herment(eventQueue);

	  // App metrics consfiguration specifics which is in line with the custom implementation of herment here
	  var customPublish = function customPublish(key, data) {
	    eventQueue.push(analyticsEngine.makeEvent({ name: key, properties: data }));
	  };
	  var metrics = window["app-metrics"]({ publish: customPublish, unfold: true });

	  // This is an addition to the onOpenRoom callback in analytics-events
	  function handleOpenedRoom(properties) {
	    metrics.start({ key: "hc_web.room.open", id: properties.jid });
	    metrics.start({ key: "hc_web.room.files.load", id: properties.jid });
	    metrics.start({ key: "hc_web.room.members.load", id: properties.jid });
	  }

	  function handleChatMountEvent(properties) {
	    metrics.stop({ key: "hc_web.room.open", id: properties.id, size: properties.size });
	  }

	  AnalyticsDispatcher.register("analytics-chat-mount", handleChatMountEvent);
	  AnalyticsDispatcher.register("analytics-open-room", handleOpenedRoom);

	  function handleHistoryRequest(properties) {
	    metrics.start({ key: "hc_web.room.history.load", id: properties.jid });
	  }

	  function handleHistoryResponse(properties) {
	    metrics.stop({ key: "hc_web.room.history.load", id: properties.jid, size: properties.size });
	  }

	  AnalyticsDispatcher.register("analytics-request-history", handleHistoryRequest);
	  AnalyticsDispatcher.register("analytics-history-loaded", handleHistoryResponse);

	  function handleRosterMount(properties) {
	    metrics.stop({ key: "hc_web.room.members.load", id: properties.id, size: properties.size });
	  }

	  function handleFilesMount(properties) {
	    metrics.stop({ key: "hc_web.room.files.load", id: properties.id, size: properties.size });
	  }

	  AnalyticsDispatcher.register("analytics-roster-mount", handleRosterMount);
	  AnalyticsDispatcher.register("analytics-files-mount", handleFilesMount);

	  function handleLobbyOpen(properties) {
	    if (properties.jid === "lobby") {
	      metrics.start({ key: "hc_web.lobby.panel.open", id: properties.jid, size: 0 });
	    }
	  }

	  function handleLobbyMount(properties) {
	    metrics.stop({ key: "hc_web.lobby.panel.open", id: properties.id, size: 0 });
	  }

	  AnalyticsDispatcher.register("analytics-select-room", handleLobbyOpen);
	  AnalyticsDispatcher.register("analytics-lobby-mount", handleLobbyMount);

	  metrics.start({ key: "hc_web.app.load", id: "app", size: 0 });

	  function handleAppInit() {
	    var timings = Utils.timings.getPerfTiming();
	    metrics.stop({ key: "hc_web.app.load", id: "app", props: timings });
	  }

	  AnalyticsDispatcher.register("analytics-hc-init", handleAppInit);
	  return analyticsEngine;
	};

/***/ },
/* 13 */,
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  AppActions: __webpack_require__(44),
	  ChatHeaderActions: __webpack_require__(45),
	  ChatInputActions: __webpack_require__(46),
	  ChatWindowActions: __webpack_require__(33),
	  ConnectionActions: __webpack_require__(47),
	  AppHeaderActions: __webpack_require__(48),
	  DialogActions: __webpack_require__(28),
	  FlagActions: __webpack_require__(49),
	  FormActions: __webpack_require__(50),
	  InlineDialogActions: __webpack_require__(51),
	  LobbyActions: __webpack_require__(52),
	  PreferenceActions: __webpack_require__(53),
	  RoomDropdownActions: __webpack_require__(54),
	  RoomNavActions: __webpack_require__(55),
	  RosterActions: __webpack_require__(56),
	  TooltipActions: __webpack_require__(57)
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Header = __webpack_require__(34);
	var ConnectionNotification = __webpack_require__(35);
	var InlineDialogManagerMixin = __webpack_require__(36);
	var ModalDialogContainer = __webpack_require__(58);
	var InlineDialogContainer = __webpack_require__(59);
	var FlagsContainer = __webpack_require__(60);
	var BodyLayout = __webpack_require__(37);
	var FileViewer = __webpack_require__(61);
	var ClientPreferencesStore = __webpack_require__(38);
	var ClientPreferencesKeys = __webpack_require__(39);
	var AppDispatcher = __webpack_require__(1);

	module.exports = React.createClass({

	  displayName: "MainLayout",

	  mixins: [InlineDialogManagerMixin],

	  getInitialState: function getInitialState() {
	    return this._getClasses();
	  },

	  componentDidMount: function componentDidMount() {
	    AppDispatcher.register("save-client-preferences", this._onPrefsChanged);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    AppDispatcher.unregister("save-client-preferences", this._onPrefsChanged);
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.state, nextState);
	  },

	  _onPrefsChanged: function _onPrefsChanged() {
	    this.setState(this._getClasses());
	  },

	  _getClasses: function _getClasses() {
	    return {
	      classes: [ClientPreferencesStore.getDensity(), ClientPreferencesStore.getTheme()].join(" ")
	    };
	  },

	  render: function render() {

	    return React.createElement(
	      "div",
	      { id: "page", className: this.state.classes },
	      React.createElement(Header, null),
	      React.createElement(BodyLayout, null),
	      React.createElement(ConnectionNotification, null),
	      React.createElement(ModalDialogContainer, null),
	      React.createElement(InlineDialogContainer, null),
	      React.createElement(FlagsContainer, null),
	      React.createElement(FileViewer, { ref: "fileViewer", items: this.props.files })
	    );
	  }
	});

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var UI = __webpack_require__(40);
	var MessageList = __webpack_require__(41);
	var ChatWindowStore = __webpack_require__(42);
	var ClientPreferencesStore = __webpack_require__(38);
	var Utils = __webpack_require__(4);
	var WindowActions = __webpack_require__(33);

	function getChatsState() {
	  return ChatWindowStore.getAll();
	}

	var openLinkInNewTab = function openLinkInNewTab(e) {
	  if (!Utils.dot(window, "HC.isEmbeddedComponent")) {
	    $(this).attr("target", "_blank");
	  }
	};

	module.exports = React.createClass({

	  displayName: "ChatPanel",

	  getInitialState: function getInitialState() {
	    return getChatsState();
	  },

	  componentDidMount: function componentDidMount() {
	    $(document).on("click", ".hc-chat-msg a[href]", openLinkInNewTab);
	    ChatWindowStore.on(["change"], this._onChange);
	    var size = 0;
	    var members = Utils.dot(this.state.rooms[this.state.active_chat], "participants.members");
	    if (members) {
	      size = members.length;
	    }
	    WindowActions.chatPanelMounted({ id: this.state.active_chat, size: size });
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    $(document).off("click", ".hc-chat-msg a[href]", openLinkInNewTab);
	    ChatWindowStore.off(["change"], this._onChange);
	  },

	  _showSidebar: function _showSidebar() {
	    return UI.showSidebar(Utils.room.detect_chat_type(this.state.active_chat), this.state.groupchat_show_sidebar, this.state.chat_show_sidebar);
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        chat_classes = cx({
	      "hc-chat-panel": true,
	      "sidebar-hidden": !this._showSidebar()
	    }),
	        chat;

	    if (this.state.active_chat && !this.state.active_chat.match("lobby") && this.state.chats[this.state.active_chat]) {
	      chat = React.createElement(MessageList, { key: this.state.active_chat,
	        chat: this.state.chats[this.state.active_chat],
	        prefs: this.state.preferences,
	        initialized: this.state.initialized,
	        token: this.state.oauth2_token });
	    }

	    return React.createElement(
	      "div",
	      { className: chat_classes },
	      React.createElement(
	        "div",
	        { className: "aui-page-panel-inner" },
	        React.createElement(
	          "section",
	          { className: "aui-page-panel-content" },
	          chat
	        )
	      )
	    );
	  },

	  _onChange: function _onChange() {
	    this.setState(getChatsState());
	  }

	});

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	(function() {
	  var HipChat, Storage,
	    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	  Storage = (function() {
	    function Storage(opts) {
	      this.clear = __bind(this.clear, this);
	      this.unset = __bind(this.unset, this);
	      this.set = __bind(this.set, this);
	      this.get = __bind(this.get, this);
	      this.has = __bind(this.has, this);
	      var e;
	      this.prefix = 'hc.';
	      this.expiry_prefix = '_';
	      this.locations = ['local', 'session', 'global'];
	      this.ttl = opts.ttl || 60 * 60 * 24 * 1000;
	      try {
	        return 'localStorage' in window && window['localStorage'] === !null;
	      } catch (_error) {
	        e = _error;
	        window.localStorage = window.sessionStorage;
	      }
	    }

	    Storage.prototype.has = function(key) {
	      return _.first(this.locations, (function(_this) {
	        return function(location) {
	          return _.keys(window[location + 'Storage']).indexOf(_this.prefix + key) !== -1;
	        };
	      })(this))[0];
	    };

	    Storage.prototype.get = function(key) {
	      var e, expiry, location;
	      if (key.indexOf(this.expiry_prefix) !== 0) {
	        expiry = this.get(this.expiry_prefix + key);
	        if ((new Date).getTime() > expiry) {
	          this.unset(key);
	          return;
	        }
	      }
	      location = this.has(key);
	      if (location) {
	        try {
	          return JSON.parse(window[location + 'Storage'].getItem(this.prefix + key).toString());
	        } catch (_error) {
	          e = _error;
	          return;
	        }
	      }
	    };

	    Storage.prototype.set = function(key, val, location) {
	      window[(location || 'local') + 'Storage'].setItem(this.prefix + key, JSON.stringify(val, function(k, v) {
	        if (v instanceof RegExp) {
	          return v.toString();
	        }
	        return v;
	      }));
	      if (key.indexOf(this.expiry_prefix) !== 0) {
	        return this.set(this.expiry_prefix + key, (new Date).getTime() + this.ttl);
	      }
	    };

	    Storage.prototype.unset = function(key) {
	      var location;
	      location = this.has(key);
	      if (key.indexOf(this.expiry_prefix) !== 0) {
	        this.unset(this.expiry_prefix + key);
	      }
	      if (location) {
	        window[location + 'Storage'].removeItem(this.prefix + key);
	        return true;
	      }
	      return false;
	    };

	    Storage.prototype.clear = function() {
	      return _.each(this.locations, (function(_this) {
	        return function(location) {
	          return _.filter(_.keys(window[location + 'Storage']), function(key) {
	            return key.match(_this.prefix);
	          }).forEach(function(key) {
	            return window[location + 'Storage'].removeItem(key);
	          });
	        };
	      })(this));
	    };

	    return Storage;

	  })();

	  HipChat = (function() {
	    function HipChat(opts) {
	      this.makeAPIRequest = __bind(this.makeAPIRequest, this);
	      this.joinAutoJoinRooms = __bind(this.joinAutoJoinRooms, this);
	      this.joinChat = __bind(this.joinChat, this);
	      this.joinRoom = __bind(this.joinRoom, this);
	      this.once = __bind(this.once, this);
	      this.on = __bind(this.on, this);
	      this.onConnectionFail = __bind(this.onConnectionFail, this);
	      this.disconnect = __bind(this.disconnect, this);
	      this.onDisconnect = __bind(this.onDisconnect, this);
	      this.onConnect = __bind(this.onConnect, this);
	      this.connect = __bind(this.connect, this);
	      this.keepAlive = __bind(this.keepAlive, this);
	      this.checkSession = __bind(this.checkSession, this);
	      this.isXMPPSessionExpired = __bind(this.isXMPPSessionExpired, this);
	      this.isXMPPActive = __bind(this.isXMPPActive, this);
	      this.onUserAction = __bind(this.onUserAction, this);
	      this.onUserIdle = __bind(this.onUserIdle, this);
	      this.attachXmlListener = __bind(this.attachXmlListener, this);
	      this.onConnectChange = __bind(this.onConnectChange, this);
	      var log_prefix;
	      this.baseUrl = opts.baseUrl || "";
	      this.clientType = opts.clientType ? '/' + opts.clientType : '';
	      this.clientVersion = opts.clientVersion || 1;
	      this.is_initial_connect = true;
	      this.do_reconnect = true;
	      this.KEEP_ALIVE_MS = 25000;
	      this.HEARTBEAT_MS = 5000;
	      this.RECONNECT_BACKOFF_FACTOR = 2;
	      this.RECONNECT_DELAY_MS = 500;
	      this.RECONNECT_MAX_DELAY = 30000;
	      this.MAX_RECONNECT_BEFORE_RELOAD = 20;
	      this.CACHE_TTL = 90 * 24 * 60 * 60 * 1000;
	      this.reconnect_delay = this.RECONNECT_DELAY_MS;
	      this.reconnect_attempt_number = 0;
	      this.rooms_joined = [];
	      this.cached_profiles = {};
	      this.cachedRoomInfo = {};
	      this.token_info = {};
	      this.noop = function() {
	        return {};
	      };
	      this.onInitialConnectCallback = opts.onInitialConnect || this.noop;
	      this.onConnectionChangeCallback = opts.onConnectionChange || this.noop;
	      this.onConnectionFailCallback = opts.onConnectionFail || this.noop;
	      this.onConnectCallback = opts.onConnect || this.noop;
	      this.onServerDataCallback = opts.onServerData || this.noop;
	      this.onDisconnectCallback = opts.onDisconnect || this.noop;
	      this.onReconnectingCallback = opts.onReconnecting || this.noop;
	      this.onReconnectionSuccessCallback = opts.onReconnectionSuccess || this.noop;
	      this.onReconnectionFailCallback = opts.onReconnectionFail || this.noop;
	      this.onUserIdleCallback = opts.onUserIdle || this.noop;
	      this.onUserActiveCallback = opts.onUserActive || this.noop;
	      this.onStaleSessionCallback = opts.onStaleSession || this.noop;
	      this.onMaxReconnectAttemts = opts.onMaxReconnectAttemts || this.noop;
	      this.store = new Storage({
	        ttl: this.CACHE_TTL
	      });
	      this.previous_presence = this.current_presence = {
	        show: 'chat',
	        status: null,
	        type: 'available'
	      };
	      log_prefix = '[HipChatJS]';
	      Strophe.log = function(level, msg) {
	        if (typeof window !== 'undefined' && 'console' in window && window.HC_LOG) {
	          switch (level) {
	            case Strophe.LogLevel.DEBUG:
	              return console.debug(log_prefix, msg);
	            case Strophe.LogLevel.INFO:
	              return console.info(log_prefix, msg);
	            case Strophe.LogLevel.WARN:
	              return console.warn(log_prefix, msg);
	            case Strophe.LogLevel.ERROR:
	            case Strophe.LogLevel.FATAL:
	              return console.error(log_prefix, msg);
	          }
	        }
	      };
	      this.x2js = new X2JS;
	      this.init = (function(_this) {
	        return function(data) {
	          if (data.error) {
	            window.location.reload();
	          }
	          window.config = data;
	          if (_this.store.get('uid') !== config.user_id) {
	            _this.store.clear();
	          }
	          _this.store.set('uid', config.user_id);
	          _this.config = data;
	          if (data.prefs.isIdleTimeEnabled) {
	            if (!data.prefs.secondsToIdle || data.prefs.secondsToIdle && data.prefs.secondsToIdle < 900) {
	              data.prefs.secondsToIdle = 900;
	            }
	            _this.IDLE_DELAY_MS = data.prefs.secondsToIdle * 1000;
	          } else {
	            _this.IDLE_DELAY_MS = 60 * 60 * 24 * 365 * 1000;
	          }
	          _this.setupConnection();
	          _this.connect();
	          _this.setupIdleEvents();
	          return $(window).on('beforeunload', function() {
	            if (_this.is_connected) {
	              return _this.disconnect(true);
	            }
	          });
	        };
	      })(this);
	      this.parsedCallback = (function(_this) {
	        return function(data, once, cb) {
	          if (typeof once === 'function') {
	            cb = once;
	            once = false;
	          }
	          cb(_this.x2js.xml2json(data));
	          return !once;
	        };
	      })(this);
	      this.clearData = function() {
	        this.room_rosters = [];
	        this.room_history_loaded = {};
	        this.room_loaded = {};
	        this.roster = [];
	        return this.roster_loaded = false;
	      };
	      this.refreshReconnectTimer = (function(_this) {
	        return function() {
	          if (_this.reconnect_delay < _this.RECONNECT_MAX_DELAY) {
	            _this.reconnect_delay = _this.reconnect_delay * _this.RECONNECT_BACKOFF_FACTOR;
	          }
	          if (_this.reconnect_delay > _this.RECONNECT_MAX_DELAY) {
	            _this.reconnect_delay = _this.RECONNECT_MAX_DELAY;
	          }
	          _this.reconnect_timer = setTimeout(_.bind(_this.refreshReconnectTimer), _this.reconnect_delay);
	          if (_this.do_reconnect) {
	            return _this.reconnect();
	          }
	        };
	      })(this);
	      this.sendIQ = (function(_this) {
	        return function(stanza, cb) {
	          return _this.connection.sendIQ(stanza.tree(), function(data) {
	            return _this.parsedCallback(data, cb);
	          }, function(err) {
	            return _this.parsedCallback(err, cb);
	          });
	        };
	      })(this);
	      this.subscribe = (function(_this) {
	        return function(evt, once, opts, cb) {
	          var from, id, ns, type;
	          if (once == null) {
	            once = false;
	          }
	          if (opts == null) {
	            opts = null;
	          }
	          if (evt === 'roomChange') {
	            evt = 'iq';
	            type = 'set';
	            ns = 'jabber:client';
	          } else if (evt === 'joinRoom' || evt === 'createRoom') {
	            evt = 'presence';
	            type = null;
	            ns = null;
	          } else {
	            type = null;
	            ns = null;
	          }
	          if (opts) {
	            id = opts.id;
	            from = opts.from;
	          }
	          return _this.connection.addHandler(function(data) {
	            return _this.parsedCallback(data, once, cb);
	          }, ns, evt, type, id, from);
	        };
	      })(this);
	      this.toXMPPDate = function(dttm) {
	        if (typeof dttm === 'string') {
	          return dttm;
	        }
	        return (new Date(dttm.setMilliseconds(0))).toISOString().replace(/\.000/, '');
	      };
	      this.getJidType = function(jid) {
	        var re;
	        re = new RegExp(config.conference_server);
	        if (re.test(jid)) {
	          return 'groupchat';
	        } else {
	          return 'chat';
	        }
	      };
	      this.getJidFromNickname = (function(_this) {
	        return function(nickname) {
	          var rslts;
	          if (/\//.test(nickname)) {
	            nickname = nickname.split('/')[1];
	          }
	          rslts = _.where(_this.cached_profiles, {
	            query: {
	              name: nickname
	            }
	          });
	          return rslts[0];
	        };
	      })(this);
	      this.callIfCached = function(key, cb) {
	        var cached_val;
	        cached_val = this.store.get(key);
	        if (cached_val) {
	          cb(cached_val);
	          this.xmlListenerCallback(cached_val);
	        }
	        return cached_val;
	      };
	      if (opts.initState && !this.baseUrl) {
	        this.init(opts.initState);
	      } else {
	        $.getJSON(this.baseUrl + '/chat/session', this.init);
	      }
	    }

	    HipChat.prototype.onConnectChange = function(status, condition) {
	      if (status === Strophe.Status.CONNECTING) {
	        this.connection_failed = false;
	        Strophe.debug('[Strophe] is connecting]');
	      } else if (status === Strophe.Status.CONNFAIL) {
	        Strophe.debug('[Strophe] Offline. Condition: ' + condition);
	        this.connection_failed = true;
	        this.onConnectionFail(condition);
	      } else if (status === Strophe.Status.DISCONNECTING) {
	        Strophe.debug('[Strophe] is disconnecting. Condition: ' + condition);
	      } else if (status === Strophe.Status.DISCONNECTED) {
	        Strophe.debug('[Strophe] is disconnected.');
	        this.onDisconnect();
	      } else if (status === Strophe.Status.CONNECTED) {
	        Strophe.debug('[Strophe] is connected.');
	        this.connection_failed = false;
	        this.onConnect();
	      } else if (status === Strophe.Status.ATTACHED) {
	        Strophe.debug('[Strophe] is attached.');
	        this.connection_failed = false;
	      } else if (status === Strophe.Status.ERROR) {
	        Strophe.error('[Strophe] encountered error: ' + condition);
	      }
	      return this.onConnectionChangeCallback(status, condition);
	    };

	    HipChat.prototype.attachXmlListener = function(cb) {
	      if (cb == null) {
	        cb = this.noop;
	      }
	      this.xmlListenerCallback = cb;
	      return this.connection.xmlInput = (function(_this) {
	        return function(elem) {
	          _this.last_xmpp_activity = (new Date).getTime();
	          return cb(_this.x2js.xml2json(elem));
	        };
	      })(this);
	    };

	    HipChat.prototype.onUserIdle = function() {
	      if (!this.is_connected) {
	        return;
	      }
	      Strophe.info('Going idle');
	      this.is_idle = true;
	      this.setPresence('away', this.current_presence.status, this.IDLE_DELAY_MS / 1000);
	      return this.onUserIdleCallback(this);
	    };

	    HipChat.prototype.onUserActive = function() {
	      if (!this.is_connected) {
	        return;
	      }
	      Strophe.info('Returning from idle', this.previous_presence, this.current_presence);
	      this.is_idle = false;
	      this.setPresence(this.previous_presence.show, this.previous_presence.status);
	      return this.onUserActiveCallback(this);
	    };

	    HipChat.prototype.onUserAction = function(event) {
	      clearTimeout(this.idle_timeout);
	      if (this.is_idle) {
	        this.onUserActive();
	      }
	      this.idle_timeout = setTimeout(_.bind(this.onUserIdle), this.IDLE_DELAY_MS);
	      return this.throttledKeepAlive();
	    };

	    HipChat.prototype.setupIdleEvents = function() {
	      $(document).on('mousemove.idle keydown.idle DOMMouseScroll.idle mousewheel.idle mousedown.idle', _.bind(this.onUserAction));
	      this.idle_timeout = setTimeout(_.bind(this.onUserIdle), this.IDLE_DELAY_MS);
	      this.check_session_timer = setInterval(_.bind(this.checkSession), this.HEARTBEAT_MS);
	      return this.throttledKeepAlive = _.throttle((function(_this) {
	        return function() {
	          if (_this.isXMPPActive()) {
	            return;
	          }
	          return _this.keepAlive('userAction');
	        };
	      })(this), this.HEARTBEAT_MS);
	    };

	    HipChat.prototype.isXMPPActive = function() {
	      if (!this.last_xmpp_activity) {
	        return false;
	      }
	      return ((new Date).getTime() - this.last_xmpp_activity) > this.HEARTBEAT_MS;
	    };

	    HipChat.prototype.isXMPPSessionExpired = function() {
	      var age;
	      if (!this.last_xmpp_activity) {
	        return false;
	      }
	      age = (new Date).getTime() - this.last_xmpp_activity;
	      if (age > this.KEEP_ALIVE_MS) {
	        return age;
	      } else {
	        return false;
	      }
	    };

	    HipChat.prototype.checkSession = function() {
	      if (this.session_age = this.isXMPPSessionExpired()) {
	        Strophe.debug('[Strophe] Stale session detected. Session age: ' + this.session_age);
	        this.onStaleSessionCallback(this.session_age);
	        return this.keepAlive('checkSession');
	      }
	    };

	    HipChat.prototype.updateIdleTime = function(newIdleTime) {
	      clearTimeout(this.idle_timeout);
	      clearInterval(this.check_session_timer);
	      this.idle_timeout = null;
	      $(document).off('.idle');
	      this.IDLE_DELAY_MS = newIdleTime * 1000;
	      return this.setupIdleEvents();
	    };

	    HipChat.prototype.keepAlive = function(origin) {
	      var ping;
	      if (!this.is_connected) {
	        return;
	      }
	      Strophe.debug("[Strophe] Stayin' alive! Called from " + origin);
	      ping = $iq({
	        type: 'get',
	        to: config.chat_server
	      }).c('ping', {
	        xmlns: 'urn:xmpp:ping'
	      });
	      if (this.connection) {
	        this.connection.send(ping);
	      } else {
	        return;
	      }
	      return true;
	    };

	    HipChat.prototype.setupConnection = function() {
	      if (!this.is_connected) {
	        return this.connection = new Strophe.Connection(this.baseUrl + config.bind_url);
	      }
	    };

	    HipChat.prototype.connect = function() {
	      Strophe.debug('[Strophe] connect()');
	      if (!this.is_connected) {
	        this.connection.attach(config.jid, config.sid, config.rid, this.onConnectChange);
	      }
	      return this.onConnect();
	    };

	    HipChat.prototype.onConnect = function() {
	      this.do_reconnect = true;
	      this.is_connected = true;
	      clearTimeout(this.reconnect_timer);
	      this.reconnect_timer = null;
	      this.current_user_jid = config.user_jid;
	      this.current_user_nickname_jid = config.user_name + '@' + config.chat_server;
	      this.attachXmlListener(this.onServerDataCallback);
	      this.setPresence(null, null, null, true);
	      if (this.is_initial_connect) {
	        this.fetchInitData();
	        this.onInitialConnectCallback(this);
	      }
	      this.is_initial_connect = false;
	      return this.onConnectCallback(this);
	    };

	    HipChat.prototype.onDisconnect = function() {
	      this.is_connected = false;
	      this.reconnect_delay = this.RECONNECT_DELAY_MS;
	      this.reconnect_attempt_number = 0;
	      if (!this.reconnect_timer) {
	        this.refreshReconnectTimer();
	      }
	      return this.onDisconnectCallback(this);
	    };

	    HipChat.prototype.disconnect = function(should_not_reconnect) {
	      Strophe.debug('[Strophe] disconnect()');
	      if (should_not_reconnect) {
	        this.do_reconnect = false;
	      }
	      this.clearData();
	      if (this.connection) {
	        this.connection.disconnect();
	      }
	      if (this.timed_handler && this.connection) {
	        this.connection.deleteTimedHandler(this.timed_handler);
	      }
	      this.connection = null;
	      clearTimeout(this.auth_token_refresh_timer);
	      return this.auth_token_refresh_timer = null;
	    };

	    HipChat.prototype.onConnectionFail = function(condition) {
	      this.is_connected = false;
	      switch (condition) {
	        case 'conflict':
	          this.do_reconnect = false;
	          break;
	        case 'not-allowed':
	          location.reload(true);
	          break;
	        case 'plan-change':
	          break;
	        case 'system-shutdown':
	          break;
	        case 'see-other-host':
	          break;
	      }
	      return this.onConnectionFailCallback(condition);
	    };

	    HipChat.prototype.reconnect = function(cb) {
	      var errCb, opts, successCb;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (this.is_connected) {
	        return;
	      }
	      Strophe.debug('[Strophe] reconnect(). Next attempt in ' + this.reconnect_delay / 1000 + 's');
	      this.onReconnectingCallback(this.reconnect_attempt_number, this.reconnect_delay);
	      if (this.reconnect_attempt_number >= this.MAX_RECONNECT_BEFORE_RELOAD) {
	        this.onMaxReconnectAttemts(this);
	      }
	      this.reconnect_attempt_number++;
	      opts = {
	        is_guest: config.is_guest,
	        guest_key: config.guest_key,
	        uid: config.user_id
	      };
	      successCb = (function(_this) {
	        return function(data) {
	          if (data && !data.error) {
	            window.config = data;
	            _this.config = data;
	            _this.clearData();
	            _this.setupConnection();
	            _this.connect();
	            _this.fetchAuthToken();
	            _this.onReconnectionSuccessCallback(true);
	            return cb('success');
	          } else if (data && data.error) {
	            _this.onReconnectionFailCallback(data);
	            cb('fail');
	            if (data.refresh_page === true) {
	              return window.location.reload();
	            }
	          }
	        };
	      })(this);
	      errCb = (function(_this) {
	        return function(jqXHR, textStatus, errorThrown) {
	          return Strophe.error('Error trying to reconnect. Status: ' + textStatus + ' -- error: ' + errorThrown);
	        };
	      })(this);
	      return $.ajax({
	        url: this.baseUrl + '/chat/session',
	        dataType: 'json',
	        data: opts,
	        success: successCb,
	        error: errCb
	      });
	    };

	    HipChat.prototype.on = function(evt, opts, cb) {
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (typeof opts === 'function') {
	        cb = opts;
	        opts = null;
	      }
	      return this.subscribe(evt, false, opts, cb);
	    };

	    HipChat.prototype.once = function(evt, opts, cb) {
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (typeof opts === 'function') {
	        cb = opts;
	        opts = null;
	      }
	      return this.subscribe(evt, true, opts, cb);
	    };

	    HipChat.prototype.off = function(subscriptionRef) {
	      return this.connection.deleteHandler(subscriptionRef);
	    };

	    HipChat.prototype.setPresence = function(show, status, idle, send_caps) {
	      var stanza;
	      show = show || 'chat';
	      Strophe.info('Setting presence: ' + ' - ' + show + ' - ' + idle);
	      stanza = $pres({
	        roster_presences: 'false'
	      });
	      if (show && show !== 'chat') {
	        stanza.c('show').t(show).up();
	      }
	      if (typeof status === 'string') {
	        stanza.c('status').t(status).up();
	      }
	      if (idle) {
	        stanza.c('query', {
	          xmlns: 'jabber:iq:last',
	          seconds: idle
	        }).up();
	      }
	      if (send_caps) {
	        stanza.c('c', {
	          xmlns: 'http://jabber.org/protocol/caps',
	          node: 'http://hipchat.com/client/web' + this.clientType,
	          ver: this.clientVersion
	        }).up();
	      }
	      this.connection.send(stanza.tree());
	      this.previous_presence = this.current_presence;
	      return this.current_presence = {
	        type: 'available',
	        show: show,
	        status: status,
	        idle: idle,
	        send_caps: send_caps
	      };
	    };

	    HipChat.prototype.unsubscribeFromPresences = function() {
	      var stanza;
	      stanza = $pres({
	        roster_presences: 'false'
	      });
	      return this.connection.send(stanza.tree());
	    };

	    HipChat.prototype.leaveRoom = function(jid, type, message) {
	      var stanza;
	      if (type === 'chat') {
	        return this.sendStateMessage(jid, type, 'gone');
	      }
	      stanza = $pres({
	        to: jid + '/' + config.user_name,
	        type: 'unavailable'
	      });
	      if (message) {
	        stanza.c('status').t(message);
	      }
	      return this.connection.send(stanza.tree());
	    };

	    HipChat.prototype.fetchAuthToken = function(cb) {
	      var dt, stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      dt = new Date;
	      if (this.token_info && this.token_info.expiration > dt.getTime()) {
	        this.token_info.token;
	      }
	      stanza = $iq({
	        type: 'get',
	        to: config.chat_server
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/auth'
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(d) {
	          _this.token_info = {
	            token: d.query.token['__text'],
	            expiration: parseInt(d.query.token.expiration, 10) * 1000
	          };
	          _this.auth_token_refresh_timer = setTimeout(_this.fetchAuthToken.bind(_this), (_this.token_info.expiration - dt.getTime()) + 5000);
	          return cb(_this.token_info);
	        };
	      })(this));
	    };

	    HipChat.prototype.fetchInitData = function(cb) {
	      var stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      stanza = $iq({
	        type: 'get',
	        id: Math.random() * 10000000 | 0
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/startup',
	        send_auto_join_user_presences: true
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(d) {
	          var dt;
	          dt = new Date;
	          _this.token_info = {
	            token: d.query.token['__text'],
	            expiration: parseInt(d.query.token.expiration, 10) * 1000
	          };
	          _this.auth_token_refresh_timer = setTimeout(_this.fetchAuthToken.bind(_this), (_this.token_info.expiration - dt.getTime()) + 5000);
	          return cb(d);
	        };
	      })(this));
	    };

	    HipChat.prototype.fetchEmoticons = function(cb) {
	      var cached_val, stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      cached_val = this.callIfCached('emoticons', cb);
	      stanza = $iq({
	        type: 'get'
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/emoticons',
	        ver: cached_val && cached_val.query ? cached_val.query.ver : ''
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(d) {
	          if (d.query) {
	            cb(d);
	            if (!d.error) {
	              return _this.store.set('emoticons', {
	                iq: d
	              });
	            }
	          }
	        };
	      })(this));
	    };

	    HipChat.prototype.fetchRoster = function(cb, cbCached) {
	      var cached_val, stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      cached_val = this.callIfCached('roster', cb);
	      stanza = $iq({
	        type: 'get'
	      }).c('query', {
	        xmlns: 'jabber:iq:roster',
	        ver: cached_val && cached_val.query ? cached_val.query.ver : ''
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(d) {
	          if (d.query) {
	            cb(d);
	            if (!d.error) {
	              return _this.store.set('roster', {
	                iq: d
	              });
	            }
	          }
	        };
	      })(this));
	    };

	    HipChat.prototype.fetchPresence = function(uid, cb) {
	      var stanza;
	      if (uid == null) {
	        uid = [];
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (!Array.isArray(uid)) {
	        uid = [uid];
	      }
	      stanza = $iq({
	        type: 'get'
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/presence'
	      });
	      uid.forEach(function(id) {
	        return this.c('uid', id).up();
	      }, stanza);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.limitPresencesToUsers = function(uid, cb) {
	      var stanza;
	      if (uid == null) {
	        uid = [];
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (!Array.isArray(uid)) {
	        uid = [uid];
	      }
	      stanza = $iq({
	        type: 'set'
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/presence',
	        action: 'presence_filter'
	      });
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.inviteUsersToRoom = function(room_jid, user_jids, reason, id) {
	      var attrs, node;
	      if (user_jids == null) {
	        user_jids = [];
	      }
	      if (reason == null) {
	        reason = '';
	      }
	      if (id == null) {
	        id = null;
	      }
	      if (!Array.isArray(user_jids)) {
	        user_jids = [user_jids];
	      }
	      attrs = {
	        to: room_jid,
	        id: Math.random() * 10000000 | 0
	      };
	      if (id !== null) {
	        attrs['id'] = id;
	      }
	      node = $msg(attrs).c('x', {
	        xmlns: 'http://jabber.org/protocol/muc#user'
	      });
	      user_jids.forEach(function(jid) {
	        this.c('invite', {
	          to: jid
	        });
	        this.c('reason');
	        this.t(reason);
	        this.up();
	        return this.up();
	      }, node);
	      return this.connection.send(node.tree());
	    };

	    HipChat.prototype.removeUsersFromRoom = function(room_jid, user_jids, cb) {
	      var stanza;
	      if (user_jids == null) {
	        user_jids = [];
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (!Array.isArray(user_jids)) {
	        user_jids = [user_jids];
	      }
	      Strophe.info('Removing users from room');
	      stanza = $iq({
	        type: 'set',
	        to: room_jid
	      }).c('query', {
	        xmlns: 'http://hipchat.com'
	      });
	      user_jids.forEach(function(jid) {
	        this.c('item', {
	          jid: jid,
	          affiliation: "none"
	        });
	        return this.up();
	      }, stanza);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.fetchRooms = function(ignore_archived, cb) {
	      var key, stanza;
	      if (ignore_archived == null) {
	        ignore_archived = true;
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Getting room list');
	      key = !ignore_archived ? 'rooms-w-archived' : 'rooms-wo-archived';
	      this.callIfCached(key, cb);
	      stanza = $iq({
	        type: 'get',
	        to: config.conference_server
	      }).c('query', {
	        xmlns: 'http://jabber.org/protocol/disco#items',
	        ignore_archived: ignore_archived
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(d) {
	          cb(d);
	          if (!d.error) {
	            return _this.store.set(key, {
	              iq: d
	            });
	          }
	        };
	      })(this));
	    };

	    HipChat.prototype.fetchRoom = function(jid, cb) {
	      var stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      jid = jid.split('/')[0];
	      if (this.cachedRoomInfo[jid]) {
	        cb(this.cachedRoomInfo[jid]);
	        return;
	      }
	      Strophe.info('Getting room');
	      stanza = $iq({
	        type: 'get',
	        to: jid
	      }).c('query', {
	        xmlns: 'http://jabber.org/protocol/disco#info'
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(data) {
	          if (!data.error) {
	            _this.cachedRoomInfo[jid] = data;
	          }
	          return cb(data);
	        };
	      })(this));
	    };

	    HipChat.prototype.fetchHistory = function(jid, before, maxstanzas, id, cb) {
	      var opts, stanza;
	      if (maxstanzas == null) {
	        maxstanzas = 50;
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Getting history');
	      opts = {
	        xmlns: 'http://hipchat.com/protocol/history',
	        maxstanzas: maxstanzas,
	        type: this.getJidType(jid)
	      };
	      if (before != null) {
	        opts.before = this.toXMPPDate(before);
	      }
	      stanza = $iq({
	        type: 'get',
	        to: jid,
	        id: id
	      }).c('query', opts);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.fetchUserProfile = function(jid, cb) {
	      var getUserId, opts, stanza, user_id;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      if (!jid) {
	        return;
	      }
	      if (this.cached_profiles[jid] && cb) {
	        cb(this.cached_profiles[jid]);
	        return;
	      }
	      Strophe.info("Fetching profile for", jid);
	      getUserId = (function(_this) {
	        return function(jid) {
	          var id, node;
	          node = jid.split('@')[0];
	          id = node.substr(node.indexOf('_') + 1);
	          if (id.match(/[0123456789]+/)) {
	            return parseInt(id, 10);
	          }
	        };
	      })(this);
	      user_id = getUserId(jid);
	      opts = {
	        jid: jid,
	        profile_id: user_id
	      };
	      stanza = $iq({
	        type: 'get',
	        to: jid
	      }).c('query', {
	        xmlns: 'http://hipchat.com/protocol/profile'
	      });
	      return this.sendIQ(stanza, (function(_this) {
	        return function(data) {
	          if (!data.error) {
	            _this.cached_profiles[jid] = data;
	          }
	          if (cb) {
	            return cb(data);
	          }
	        };
	      })(this));
	    };

	    HipChat.prototype.joinRoom = function(room_jid, maxstanzas, cb) {
	      var pres;
	      if (maxstanzas == null) {
	        maxstanzas = 0;
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      pres = $pres({
	        type: 'available',
	        to: room_jid + '/' + config.user_name
	      }).c('x', {
	        xmlns: 'http://jabber.org/protocol/muc'
	      }).c('history', {
	        maxstanzas: maxstanzas
	      });
	      this.once('joinRoom', cb);
	      return this.connection.send(pres.tree());
	    };

	    HipChat.prototype.joinChat = function(jid, cb) {
	      if (cb == null) {
	        cb = this.noop;
	      }
	      return this.sendStateMessage(jid, 'chat', 'active');
	    };

	    HipChat.prototype.joinAutoJoinRooms = function(jidsArr, maxstanzas) {
	      return _.each(jidsArr || config.prefs.autoJoin, (function(_this) {
	        return function(room) {
	          _this.rooms_joined.push(room);
	          if (/@conf/.test(room.jid)) {
	            return _this.joinRoom(room.jid);
	          } else {
	            return _this.joinChat(room.jid);
	          }
	        };
	      })(this));
	    };

	    HipChat.prototype.sendMessage = function(jid, message, id) {
	      var attrs, node;
	      if (id == null) {
	        id = null;
	      }
	      attrs = {
	        to: jid,
	        type: this.getJidType(jid),
	        id: Math.random() * 10000000 | 0
	      };
	      if (id !== null) {
	        attrs['id'] = id;
	      }
	      node = $msg(attrs).c('body').t(message).up();
	      if (attrs.type === 'chat') {
	        attrs.from = this.current_user_jid;
	        node.c('active', {
	          xmlns: 'http://jabber.org/protocol/chatstates'
	        }).up().c('x', {
	          xmlns: 'http://hipchat.com'
	        }).c('echo');
	      }
	      return this.connection.send(node.tree());
	    };

	    HipChat.prototype.sendStateMessage = function(jid, type, state) {
	      var attrs, node;
	      attrs = {
	        to: jid,
	        type: type,
	        id: Math.random() * 10000000 | 0
	      };
	      node = $msg(attrs).c(state, {
	        xmlns: 'http://jabber.org/protocol/chatstates'
	      }).up();
	      return this.connection.send(node.tree());
	    };

	    HipChat.prototype.createRoom = function(name, topic, privacy, cb) {
	      var pres, room_jid, to_slug;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      to_slug = function(str) {
	        var from, i, to, _i, _ref;
	        str = str.replace(/^\s+|\s+$/g, "").toLowerCase();
	        from = "àáäâèéëêìíïîòóöôùúüûñç·/_,:;";
	        to = "aaaaeeeeiiiioooouuuunc------";
	        for (i = _i = i, _ref = from.length; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
	          str = str.replace(new RegExp(from.charAt(i), "g"), to.charAt(i));
	        }
	        str = str.replace(/[^a-z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
	        return str;
	      };
	      room_jid = config.group_id + '_' + to_slug(name) + '@' + config.conference_server;
	      pres = $pres({
	        type: 'available',
	        to: room_jid + '/' + config.user_name
	      }).c('x', {
	        xmlns: 'http://jabber.org/protocol/muc'
	      }).c('history', {
	        maxstanzas: 50
	      }).up().up().c('x', {
	        xmlns: 'http://jabber.org/protocol/muc#room'
	      }).c('name').t(name).up().c('topic').t(topic).up().c('privacy').t(privacy);
	      this.once('createRoom', cb);
	      return this.connection.send(pres.tree());
	    };

	    HipChat.prototype.renameRoom = function(jid, new_name, cb) {
	      var stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Renaming room');
	      stanza = $iq({
	        type: 'set',
	        to: jid
	      }).c('query', {
	        xmlns: 'http://hipchat.com'
	      }).c('rename').t(new_name);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.deleteRoom = function(jid, reason, cb) {
	      var stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Deleting room');
	      stanza = $iq({
	        type: 'set',
	        to: jid
	      }).c('query', {
	        xmlns: 'http://jabber.org/protocol/muc#owner'
	      }).c('destroy').c('reason').t(reason);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.changeRoomPrivacy = function(jid, new_privacy, cb) {
	      var stanza;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Changing room privacy');
	      stanza = $iq({
	        type: 'set',
	        to: jid
	      }).c('query', {
	        xmlns: 'http://hipchat.com'
	      }).c('privacy').t(new_privacy);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.makeAPIRequest = function(func, opts, cb) {
	      var payload;
	      if (cb == null) {
	        cb = this.noop;
	      }
	      payload = $.extend(opts, {
	        user_id: config.user_id,
	        group_id: config.group_id,
	        token: config.token.token,
	        format: 'json'
	      });
	      return $.ajax({
	        type: 'POST',
	        dataType: 'json',
	        url: this.baseUrl + '/api/' + func,
	        data: payload,
	        async: true,
	        success: cb
	      });
	    };

	    HipChat.prototype.prefs_changed = false;

	    HipChat.prototype.getBoolPref = function(name, default_val) {
	      var ret, val;
	      if (name in config.prefs) {
	        val = config.prefs[name];
	        ret = false;
	        if (val === "true" || val === true) {
	          ret = true;
	        } else if (val === "false" || val === false) {
	          ret = false;
	        } else {
	          ret = val;
	        }
	        return ret;
	      }
	      return default_val;
	    };

	    HipChat.prototype.getPref = function(name, default_val) {
	      if (config.prefs[name]) {
	        return config.prefs[name];
	      }
	      return default_val;
	    };

	    HipChat.prototype.savePreferences = function() {
	      if (this.prefs_changed) {
	        this.makeAPIRequest("save_preferences", {
	          pref_data: config.prefs
	        }, null);
	        this.prefs_changed = false;
	      }
	    };

	    HipChat.prototype.setPref = function(name, val, save_now) {
	      config.prefs[name] = val;
	      this.prefs_changed = true;
	      if (save_now) {
	        this.savePreferences();
	      }
	    };

	    HipChat.prototype.sendUploadMessage = function(data) {
	      var attrs, file_info, msg;
	      if (!this.is_connected) {
	        return false;
	      }
	      file_info = this.x2js.xml2json(data.file_info);
	      attrs = {
	        to: data.jid,
	        type: data.type
	      };
	      msg = $msg(attrs).c('x', {
	        xmlns: 'http://hipchat.com/protocol/muc#room'
	      }).c('file', {
	        'id': file_info.response.file_id
	      }).up().up();
	      if (data.type !== 'groupchat') {
	        msg.c('x', {
	          xmlns: 'http://hipchat.com'
	        }).c('echo').up().up();
	      }
	      return this.connection.send(msg.tree());
	    };

	    HipChat.prototype.fetchFiles = function(jid, before, after, limit, cb) {
	      var opts, stanza;
	      if (before == null) {
	        before = null;
	      }
	      if (after == null) {
	        after = null;
	      }
	      if (limit == null) {
	        limit = 50;
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Requesting files');
	      opts = {
	        xmlns: 'http://hipchat.com/protocol/files',
	        limit: limit
	      };
	      if (before != null) {
	        opts.before = this.toXMPPDate(before);
	      }
	      stanza = $iq({
	        type: 'get',
	        to: jid
	      }).c('query', opts);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.fetchLinks = function(jid, before, after, limit, cb) {
	      var opts, stanza;
	      if (before == null) {
	        before = null;
	      }
	      if (after == null) {
	        after = null;
	      }
	      if (limit == null) {
	        limit = 50;
	      }
	      if (cb == null) {
	        cb = this.noop;
	      }
	      Strophe.info('Requesting files');
	      opts = {
	        xmlns: 'http://hipchat.com/protocol/links',
	        limit: limit
	      };
	      if (before != null) {
	        opts.before = this.toXMPPDate(before);
	      }
	      stanza = $iq({
	        type: 'get',
	        to: jid
	      }).c('query', opts);
	      return this.sendIQ(stanza, cb);
	    };

	    HipChat.prototype.revokeOauth2Token = function() {
	      var opts, stanza;
	      opts = {
	        xmlns: "http://hipchat.com/protocol/auth",
	        action: "delete"
	      };
	      stanza = $iq({
	        type: 'set'
	      }).c('query', opts).c('type').t('oauth2');
	      return this.sendIQ(stanza, this.noop);
	    };

	    HipChat.prototype.setTopic = function(jid, topic) {
	      var attrs, msg;
	      attrs = {
	        to: jid,
	        type: 'groupchat'
	      };
	      msg = $msg(attrs).c('subject').t(topic);
	      return this.connection.send(msg.tree());
	    };

	    HipChat.prototype.setGuestAccess = function(jid, enabled) {
	      var opts, stanza, val;
	      val = enabled ? 1 : 0;
	      opts = {
	        xmlns: "http://hipchat.com"
	      };
	      stanza = $iq({
	        to: jid,
	        type: 'set'
	      }).c('query', opts).c('guest_access').t(val);
	      return this.sendIQ(stanza, this.noop);
	    };

	    return HipChat;

	  })();

	  if (true) {
	    module.exports = HipChat;
	  } else {
	    window.HipChat = HipChat;
	  }

	}).call(this);


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4),
	    moment = __webpack_require__(64),
	    notifier = __webpack_require__(66),
	    PreferencesStore = __webpack_require__(21),
	    AppDispatcher = __webpack_require__(1),
	    ClientPreferencesStore = __webpack_require__(38),
	    AppConfig = __webpack_require__(3),
	    strings = __webpack_require__(22);

	var MessageProcessor = (function () {
	  function MessageProcessor(data) {
	    _classCallCheck(this, MessageProcessor);

	    this.applicationData = data;
	    this.registerEventCallbacks();
	    _(Utils).assign({ formatMessageBody: _.bind(this.formatMessageBody, this) });
	  }

	  _prototypeProperties(MessageProcessor, null, {
	    update: {
	      value: function update(data) {
	        this.applicationData = null;
	        this.applicationData = data;
	        if (typeof data.mentionRegexUser == "string") {
	          this.applicationData.mentionRegexUser = new RegExp(data.mentionRegexUser.substring(1, data.mentionRegexUser.lastIndexOf(")") + 1), "ig");
	        }if (typeof data.mentionRegexMe == "string") {
	          this.applicationData.mentionRegexMe = new RegExp(data.mentionRegexMe.substring(1, data.mentionRegexMe.lastIndexOf(")") + 1), "g");
	        }
	        _(Utils).assign({ formatMessageBody: _.bind(this.formatMessageBody, this) });
	      },
	      writable: true,
	      configurable: true
	    },
	    registerEventCallbacks: {
	      value: function registerEventCallbacks() {
	        var _this = this;

	        AppDispatcher.register({
	          "application-blurred": function () {
	            _this.appBlurred = true;
	          },
	          "application-focused": function () {
	            _this.appBlurred = false;
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    processMessages: {
	      value: function processMessages(messages) {
	        var messagesObj = {};
	        if (messages.jid && messages.results) {
	          messagesObj = this.formatAPIMessages(messages);
	        } else {
	          messagesObj = this.formatXMPPMessages(messages);
	        }
	        return messagesObj;
	      },
	      writable: true,
	      configurable: true
	    },
	    _createSafePredicate: {
	      value: function _createSafePredicate(predicate, context) {
	        return function () {
	          try {
	            return predicate.apply(context, arguments);
	          } catch (e) {
	            return true;
	          }
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    formatXMPPMessages: {
	      value: function formatXMPPMessages(messages) {
	        var _this = this;

	        var messagesObj = {},
	            jid,
	            roomListsAreDefined,
	            predicate = this._createSafePredicate(AppConfig.message_filter_predicate, AppConfig);

	        _(Utils.toArray(messages)).filter(predicate).forEach(function (message) {
	          jid = Utils.jid.bare_jid(message.from);
	          roomListsAreDefined = _this.applicationData.allRooms[jid] && _this.applicationData.activeRooms[jid];

	          if (_this.checkMessageForAction(message, jid)) return;
	          _this.setMessageTypeAndFormat(message);

	          if (typeof message.mid == "undefined") {
	            message.mid = _.uniqueId();
	          }
	          if (typeof message.ts == "undefined") {
	            message.ts = Utils.getMoment();
	          }

	          if (typeof message.subject != "undefined") {
	            if (!message.delay) {
	              //We don't want previous topic change messages to change the room topic
	              if (!message.subject.length) {
	                return;
	              }
	              var sender = _this.getMessageSender(message);
	              if (!sender || _this.applicationData.allRooms[jid].topic == message.subject || _this.applicationData.activeRooms[jid].topic == message.subject) {
	                return;
	              }
	              _this.applicationData.allRooms[jid].topic = message.subject;
	              _this.applicationData.activeRooms[jid].topic = message.subject;
	              _.assign(message, {
	                sender: " ",
	                body: sender + " changed the topic to: " + message.subject
	              });
	            } else {
	              return;
	            }
	          }
	          var sender_id = _this.getMessageSenderId(message);
	          _.assign(message, {
	            room: jid,
	            sender: message.sender || _this.getMessageSender(message),
	            sender_id: sender_id,
	            date: moment.unix(message.ts).toISOString(),
	            sender_mention: message.sender_mention || _this.getMessageSenderMention(message),
	            sender_avatar: _this.getAvatar(sender_id),
	            display_time: _this.formatDate(message.ts),
	            time: parseFloat(message.ts),
	            is_history_message: Utils.isHistoryMessage(message),
	            status: "confirmed"
	          });

	          _this.setMessageColor(message);
	          message = _this.formatMessageBody(message);

	          if (_this.shouldNotify(message) && !Utils.isHistoryMessage(message)) {
	            var sender = message.sender || _this.getMessageSender(message);
	            notifier.notify({
	              jid: jid,
	              title: Utils.jid.is_room(message.room) ? sender + " - " + _this.applicationData.activeRooms[message.room].name : sender,
	              body: message.body && message.format === "text" ? message.body : strings.generic_message(sender),
	              icon: AppConfig.notification_icon
	            });
	            if (!PreferencesStore.getDisableSounds()) {
	              notifier.playSound();
	            }
	          }

	          messagesObj[message.mid] = message;
	          _this.applicationData.received_mids.push(message.mid);

	          var escapeAndLinkifyOptions = {
	            do_emoticons: ClientPreferencesStore.shouldReplaceTextEmoticons()
	          };

	          if (_.filter(message.x, "metadata").length) {
	            var meta = _.compact(_.pluck(message.x, "metadata"))[0];
	            var mid = message.mid || "",
	                msg = {},
	                time = parseFloat(message.ts);
	            _.assign(msg, {
	              room: jid,
	              mid: mid + "-link",
	              sender: Utils.getSenderFromMeta(meta.type),
	              sender_id: sender_id,
	              sender_mention: message.sender_mention || _this.getMessageSenderMention(message),
	              sender_avatar: _this.getAvatar(sender_id),
	              date: moment.unix(time).toISOString(),
	              display_time: _this.formatDate(time + 1),
	              time: time,
	              format: "html",
	              body: meta.text ? Utils.escapeAndLinkify(meta.text, escapeAndLinkifyOptions) : "",
	              type: meta.type,
	              link_details: meta,
	              color: "gray",
	              is_history_message: Utils.isHistoryMessage(message)
	            });
	            message.link_details = _.transform(message.link_details, function (result, val, key) {
	              result[Utils.camelToSnake(key)] = val;
	            });
	            messagesObj[msg.mid] = msg;
	          }
	        });
	        return messagesObj;
	      },
	      writable: true,
	      configurable: true
	    },
	    formatDate: {
	      value: function formatDate(date) {
	        return Utils.format_time(date, PreferencesStore.shouldUse24HrTime());
	      },
	      writable: true,
	      configurable: true
	    },
	    formatAPIMessages: {
	      value: function formatAPIMessages(messages) {
	        var _this = this;

	        var temp = {},
	            msgs = _.transform(messages.results, function (result, msg) {
	          if (msg.type == "topic") {
	            return;
	          }
	          temp = {
	            room: messages.jid,
	            mid: msg.id,
	            time: Utils.getMoment(msg.date),
	            display_time: _this.formatDate(msg.date),
	            date: moment(msg.date).toISOString(),
	            from: messages.jid,
	            sender: msg.from.name || msg.from,
	            sender_mention: msg.from.mention_name,
	            sender_id: msg.from.id,
	            sender_avatar: _this.getAvatar(msg.from.id),
	            type: msg.type == "unknown" || !msg.type ? "message" : msg.type,
	            color: msg.color,
	            format: msg.message_format,
	            is_history_message: true,
	            status: "confirmed"
	          };
	          if (msg.file) {
	            _.assign(temp, {
	              type: "file",
	              file: msg.file
	            });
	          }
	          if (AppConfig.slash_replacement_regex.test(msg.message)) {
	            var arr = msg.message.split("/");
	            AppDispatcher.dispatch("replacement-message-received", {
	              jid: messages.jid,
	              sender_id: msg.from.id,
	              text_to_replace: arr[1],
	              replacement_text: arr[2],
	              time: Utils.getMoment(msg.date),
	              mid: msg.id
	            });
	          }
	          _this.applicationData.received_mids.push(msg.id);
	          _this.setMessageTypeAndFormat(temp);

	          if (msg.message) {
	            _.assign(temp, {
	              body: msg.message
	            });
	          }
	          _this.setMessageColor(temp);
	          result.push(_this.formatMessageBody(temp));
	          if (msg.message_links && msg.message_links.length) {
	            var linkMsg = {},
	                index = 0;
	            _.map(msg.message_links, function (link) {
	              index++;
	              linkMsg = {
	                room: messages.jid,
	                mid: link.id || msg.id + "-link-" + index,
	                body: link[link.type].text || msg.message,
	                time: Utils.getMoment(msg.date) + index,
	                date: moment(msg.date).toISOString(),
	                display_time: _this.formatDate(msg.date),
	                from: messages.jid,
	                sender: Utils.getSenderFromMeta(link.type),
	                sender_mention: msg.from.mention_name,
	                sender_id: msg.from.id,
	                sender_avatar: _this.getAvatar(msg.from.id),
	                format: "html",
	                color: "gray",
	                type: link.type,
	                link_details: link[link.type],
	                is_history_message: true,
	                status: "confirmed"
	              };
	              linkMsg.link_details.url = link.url;
	              linkMsg.link_details = _.transform(linkMsg.link_details, function (result, val, key) {
	                result[Utils.camelToSnake(key)] = val;
	              });
	              result.push(linkMsg);
	            });
	          }
	        });
	        msgs = _.reject(msgs, function (msg) {
	          return msg.mid.split("-link-")[0] == messages.mid;
	        });
	        if (msgs.length) {
	          return _.indexBy(msgs, "mid");
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    processSentMessage: {
	      value: function processSentMessage(data) {
	        var msgObj = {},
	            sender_id = Utils.jid.user_id(this.applicationData.current_user.user_jid),
	            msg = {
	          jid: data.jid,
	          room: data.jid,
	          from: this.applicationData.current_user.user_jid,
	          sender: this.applicationData.current_user.user_name,
	          sender_id: sender_id,
	          sender_avatar: this.getAvatar(sender_id),
	          display_time: this.formatDate(),
	          color: "blue",
	          time: moment().unix(),
	          body: data.text,
	          type: "message",
	          mid: data.id.toString(),
	          status: "unconfirmed",
	          is_user_sent: true
	        };
	        if (this.checkMessageForAction(msg, data.jid)) {
	          return;
	        }this.setMessageTypeAndFormat(msg);
	        msg = this.formatMessageBody(msg);
	        msgObj[msg.mid] = msg;
	        return msgObj;
	      },
	      writable: true,
	      configurable: true
	    },
	    formatMessageBody: {
	      value: function formatMessageBody(message) {
	        var type = /message$/.test(message.type) ? "message" : message.type,
	            text = message.body,
	            do_escape = true;
	        if (typeof text == "string") {
	          do_escape = message.format == "html" ? false : true;
	          if (message.x) {
	            message.x = Utils.toArray(message.x);
	          }
	          if (type == "message" && text.match(/^(\/me\s|\/em\s)/)) {
	            message.type = "info";
	            message.isEmote = true;
	            text = message.sender + text.substr(3);
	          }
	          if (message.type == "file") {
	            var fileData = message.file || message.x[0].file;
	            fileData = _.transform(fileData, function (result, val, key) {
	              result[Utils.camelToSnake(key)] = val;
	            });
	            fileData.file_size = Utils.get_file_size_string(fileData.size);
	            fileData.url = fileData.url || fileData.file_url;
	            fileData.filetype = Utils.file.get_file_type(fileData.url, true);
	            message.file_data = fileData;
	            if (fileData.desc) {
	              text = fileData.desc;
	            }
	          }
	          // Check for monospace formatting (remove excess whitespace)
	          if (message.format == "monospace") {
	            text = Utils.formatMultilineBlock(text);
	          }

	          // Escape html and linkify
	          var matches = [];
	          // Don't linkify if we're going to truncate a pasted block by # of characters
	          // (links are fine if we're truncating by line)
	          var do_linkify = do_escape && message.format != "monospace" && message.format != "code";
	          var do_emoticons = do_escape && message.format != "monospace" && message.format != "code" && ClientPreferencesStore.shouldReplaceTextEmoticons();
	          var do_mentions = message.format != "monospace" && do_escape && message.format != "code";
	          var do_word_breaks = do_escape;
	          text = Utils.escapeAndLinkify(text, {
	            escape_whitespace: do_escape,
	            name_tag_regex: this.applicationData.mentionRegexMe,
	            mention_regex: this.applicationData.mentionRegexUser,
	            matches: matches,
	            emoticon_path: this.applicationData.emoticons.path_prefix,
	            do_escape: do_escape,
	            do_linkify: do_linkify,
	            do_emoticons: do_emoticons,
	            do_word_breaks: do_word_breaks,
	            do_mentions: do_mentions
	          });
	          message.rendered_body = text;
	          message.message_type = type;
	        }
	        return message;
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldGroupMessages: {
	      value: function shouldGroupMessages(mostRecent, message) {
	        var nonGroupingTypes = ["notification", "video", "twitter_user", "twitter_status", "file", "info"];
	        return mostRecent.display_time == message.display_time && mostRecent.sender == message.sender && mostRecent.color == message.color && nonGroupingTypes.indexOf(message.type) == -1;
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldNotify: {
	      value: function shouldNotify(message) {
	        if (message.x) {
	          var x = _.first(Utils.toArray(message.x));
	          if (x && x.notify === "0") {
	            return false;
	          }
	        }

	        if (message.type && message.type === "info") {
	          return false;
	        }

	        var preferences = PreferencesStore.getAll();
	        if (!preferences.showToasters || this.getMessageSender(message) == this.applicationData.current_user.user_name) {
	          return false;
	        } else {
	          if (!this.appBlurred && this.applicationData.active_chat == message.room) {
	            return false;
	          } else {
	            return this.shouldNotifyForPrivate(preferences, message) || this.shouldNotifyForPrivateRoom(preferences, message) || this.shouldNotifyForRoom(preferences, message) || this.shouldNotifyForTag(preferences, message);
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldNotifyForRoom: {
	      value: function shouldNotifyForRoom(preferences, message) {
	        // Public Groupchat
	        return preferences.notifyForRoom && Utils.jid.is_room(message.room) && this.applicationData.activeRooms[message.room].privacy == "public";
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldNotifyForPrivate: {
	      value: function shouldNotifyForPrivate(preferences, message) {
	        // OTO
	        return preferences.notifyForPrivate && Utils.jid.is_private_chat(message.room);
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldNotifyForPrivateRoom: {
	      value: function shouldNotifyForPrivateRoom(preferences, message) {
	        // Private Groupchat
	        return preferences.notifyForPrivateRoom && Utils.jid.is_room(message.room) && this.applicationData.activeRooms[message.room].privacy == "private";
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldNotifyForTag: {
	      value: function shouldNotifyForTag(preferences, message) {
	        // @mention
	        return preferences.notifyForTag && message.body.search(this.applicationData.mentionRegexMe) !== -1;
	      },
	      writable: true,
	      configurable: true
	    },
	    getMessageSender: {
	      value: function getMessageSender(message) {
	        var jid;
	        if (/@chat/.test(message.from)) {
	          message.delay ? jid = Utils.jid.bare_jid(message.delay.from_jid) : jid = Utils.jid.bare_jid(message.from);
	          var sender = this.applicationData.roster[jid];
	          return sender ? sender.name : "";
	        } else if (message.delay && message.delay.from_jid && this.applicationData.roster[Utils.jid.bare_jid(message.delay.from_jid)]) {
	          return this.applicationData.roster[Utils.jid.bare_jid(message.delay.from_jid)].name;
	        } else if (message.type === "link") {
	          return "Link";
	        } else if (message.from) {
	          return Utils.jid.resource(message.from);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getMessageSenderId: {
	      value: function getMessageSenderId(message) {
	        var jid;
	        if (/@chat/.test(message.from)) {
	          message.delay ? jid = Utils.jid.bare_jid(message.delay.from_jid) : jid = Utils.jid.bare_jid(message.from);
	          return Utils.jid.user_id(jid) || "";
	        } else if (message.delay && message.delay.from_jid) {
	          return Utils.jid.user_id(message.delay.from_jid);
	        } else {
	          var sender = _.findWhere(this.applicationData.roster, { name: this.getMessageSender(message) });
	          if (sender) {
	            return Utils.jid.user_id(sender.jid);
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getMessageSenderMention: {
	      value: function getMessageSenderMention(message) {
	        var jid, user;
	        if (/@chat/.test(message.from)) {
	          message.delay ? jid = Utils.jid.bare_jid(message.delay.from_jid) : jid = Utils.jid.bare_jid(message.from);
	          var sender = this.applicationData.roster[jid];
	          return sender ? sender.mention_name : "";
	        } else if (message.delay && message.delay.from_jid && this.applicationData.roster[Utils.jid.bare_jid(message.delay.from_jid)]) {
	          return this.applicationData.roster[Utils.jid.bare_jid(message.delay.from_jid)].mention_name;
	        } else if (message.from) {
	          user = _.first(_.where(this.applicationData.roster, function (item) {
	            return item.name == Utils.jid.resource(message.from);
	          }));
	          if (user) {
	            return user.mention_name;
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    checkMessageForAction: {
	      value: function checkMessageForAction(message, jid) {
	        var extra,
	            status = _.intersection(_.keys(message), this.applicationData.chat_states);
	        message.x ? extra = Utils.toArray(message.x) : extra = [{}];

	        if (!message.is_user_sent && message.mid && this.applicationData.received_mids.indexOf(message.mid) != -1) {
	          //do nothing for messages which have been cached in localStorage
	          return true;
	        }

	        if (message.type === "error") {
	          Utils.log("[ERROR]", message);
	          AppDispatcher.dispatch("error-message-received", message);
	          return true;
	        } else if (!message.delay && extra[0].file) {

	          this.addFile(jid, message);
	          return false;
	        } else if (message.x && message.x.is_archived && !message.body && !Utils.isHistoryMessage(message)) {
	          if (!!parseInt(message.x.is_archived)) {
	            AppDispatcher.dispatch("room-archived", { jid: jid });
	          } else if (!parseInt(message.x.is_archived)) {
	            AppDispatcher.dispatch("room-unarchived", { jid: jid });
	          }
	          return false;
	        } else if (!message.delay && !extra[0].file && extra[0].type !== "system" && this.applicationData.activeRooms[jid] && message.body && message.body.length && /https?:\/\//i.test(message.body)) {

	          this.addLink(jid, message);
	          return false;
	        } else if (status.length && (!message.body || message.body.length === 0)) {
	          status = _.first(status);
	          AppDispatcher.dispatch("status-message-received", {
	            type: status,
	            message: message
	          });
	          return true;
	        } else if (AppConfig.slash_replacement_regex.test(message.body)) {
	          var arr = message.body.split("/");
	          AppDispatcher.dispatch("replacement-message-received", {
	            jid: jid,
	            sender_id: this.getMessageSenderId(message),
	            text_to_replace: arr[1],
	            replacement_text: arr[2],
	            time: message.time || parseFloat(message.ts),
	            mid: message.mid
	          });
	          return false;
	        } else if (extra[0].invite) {
	          var cb = function cb(iq) {
	            AppDispatcher.dispatch("handle-cached-room", {
	              jid: iq.from,
	              name: Utils.dot(iq, "query.identity.name"),
	              x: Utils.dot(iq, "query.x")
	            });
	          };
	          AppDispatcher.dispatch("groupchat-invite-received", message, cb);
	          return true;
	        } else if (!this.applicationData.activeRooms[jid] && message.body && message.body.length > 0 && !message.is_user_sent && Utils.jid.is_private_chat(jid)) {
	          AppDispatcher.dispatch("private-chat-invite-received", message);
	          return false;
	        } else if (extra[0].guest_url) {
	          AppDispatcher.dispatch("guest-access-enabled", message);
	          return false;
	        } else if (extra[0].call) {
	          // TODO handle audio or video call
	          AppDispatcher.dispatch("invite-to-audio-video-call", message);
	          return true;
	        } else if (typeof extra[0].hangup != "undefined") {
	          // TODO handle audio or video hangup
	          AppDispatcher.dispatch("hangup-audio-video-call", message);
	          return true;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    setMessageColor: {
	      value: function setMessageColor(message) {
	        if (message.color || message.x && message.x.color) {
	          message.color = message.color || message.x.color;
	        } else if (message.sender == this.applicationData.current_user.user_name || message.delay && message.delay.from_jid == this.applicationData.current_user.user_jid) {
	          message.color = "blue";
	        } else if (message.type == "notification") {
	          message.color = "gray";
	        } else {
	          message.color = "nocolor";
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    setMessageTypeAndFormat: {
	      value: function setMessageTypeAndFormat(message) {
	        var type = message.x ? _.compact(_.pluck(Utils.toArray(message.x), "type"))[0] : message.type,
	            format = message.x ? _.compact(_.pluck(Utils.toArray(message.x), "message_format"))[0] : message.format;
	        if (message.subject || type == "topic") {
	          message.type = "info";
	        } else if (this.handleInfoMessage(message)) {
	          _.assign(message, {
	            type: "info",
	            sender: " ",
	            color: "nocolor"
	          });
	        } else if (type == "system" || type == "notification") {
	          message.type = "notification";
	        } else if (type == "room-presence") {
	          message.type = "info";
	          message.is_presence_message = true;
	        } else if (message.file || message.x && typeof message.x.file != "undefined") {
	          message.type = "file";
	          message.body = Utils.dot(message, "x.file.desc") || "";
	        } else if (type == "user_state") {
	          message.format = "html";
	        } else if (!_.isUndefined(message.body)) {
	          message.type = "message";
	          message.body = message.body.toString();
	          if (message.body.match(/^(\/quote\s)/)) {
	            _.assign(message, {
	              body: message.body.substr(7),
	              format: "monospace"
	            });
	            return;
	          } else if (message.body.match(/^(\/code\s)/)) {
	            _.assign(message, {
	              body: message.body.substr(6),
	              format: "code"
	            });
	            return;
	          }
	        }
	        message.format = format || "text";
	      },
	      writable: true,
	      configurable: true
	    },
	    handleInfoMessage: {
	      value: function handleInfoMessage(message) {
	        if (message.x && !message.body) {
	          if (message.x.is_archived) {
	            message.body = strings.user_changed_archive_status(this.getMessageSender(message), !!parseInt(message.x.is_archived) ? strings.archived : strings.unarchived);
	            return true;
	          } else if (typeof message.x.guest_url !== "undefined") {
	            message.body = strings.user_changed_guest_access(this.getMessageSender(message), message.x.guest_url ? strings.turned_on : strings.turned_off);
	            return true;
	          }
	        }
	        return false;
	      },
	      writable: true,
	      configurable: true
	    },
	    addLink: {
	      value: function addLink(jid, message) {
	        if (message.ts) {
	          var sender = this.getMessageSender(message);
	          var link = Utils.link.create_link_object(jid, message.ts, message.body, sender);
	          if (link) {
	            AppDispatcher.dispatch("add-link", {
	              room: jid,
	              link: link
	            });
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    addFile: {
	      value: function addFile(jid, message) {
	        if (message.ts) {
	          var sender = this.getMessageSender(message);
	          var file = Utils.file.create_file_object(jid, message.x.file, message.ts, sender);
	          if (file) {
	            AppDispatcher.dispatch("add-file", {
	              room: jid,
	              file: file
	            });
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getAvatar: {
	      value: function getAvatar(id) {
	        if (!id) {
	          return false;
	        }return "//api.hipchat.com/v2/user/" + id + "/photo/big?auth_token=" + this.applicationData.token;
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return MessageProcessor;
	})();

	module.exports = MessageProcessor;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);
	var generalErrorHelper = __webpack_require__(67);

	var otherStanzas = [];
	var requiredStanzas = ["jabber:iq:roster", "http://jabber.org/protocol/disco#items", "http://hipchat.com/protocol/emoticons"];
	var processedRequiredStanzas = {};
	var allRequiredStanzasProcessed = false;

	/**
	 * Stores an IQ stanza to be processed later.
	 *
	 * @param iq
	 */
	function queueStanza(iq) {
	  otherStanzas.push(iq);
	}

	/**
	 * Processes all IQ stanzas which have built up before the app is ready.
	 *
	 * @param store
	 */
	function flushStanzas(store) {
	  _.each(otherStanzas, function (iq) {
	    handleStanza(iq, store);
	  });

	  otherStanzas = [];
	}

	function handleStanza(iq, store) {
	  switch (iq.query.xmlns) {
	    case "jabber:iq:roster":
	      store.handleRoster(iq.query.item);
	      break;
	    case "http://jabber.org/protocol/disco#info":
	      var room = {
	        jid: iq.from,
	        name: Utils.dot(iq, "query.identity.name"),
	        x: Utils.dot(iq, "query.x")
	      };
	      store.handleRooms(room);
	      break;
	    case "http://jabber.org/protocol/disco#items":
	      store.handleRooms(iq.query.item);
	      break;
	    case "http://hipchat.com/protocol/profile":
	      store.handleProfile(iq);
	      break;
	    case "http://hipchat.com/protocol/files":
	      store.handleFiles(iq);
	      break;
	    case "http://hipchat.com/protocol/links":
	      store.handleLinks(iq);
	      break;
	    case "http://hipchat.com/protocol/emoticons":
	      store.handleEmoticons(iq.query);
	      break;
	    case "http://hipchat.com/protocol/muc#room":
	      store.determineRoomUpdate(iq.query.item);
	      break;
	    case "http://hipchat.com/protocol/startup":
	      // TODO fix this 'local' reference
	      if (!store.local.initialized) {
	        store.handleStartupIQ(iq.query);
	      }
	      break;
	    default:
	      return true;
	  }
	}

	/**
	 * Returns true if all required stanzas have arrived.
	 * @returns {*}
	 */
	function allRequiredStanzasArrived() {
	  return _.every(requiredStanzas, function (stanza) {
	    return processedRequiredStanzas[stanza];
	  });
	}

	/**
	 * Handles or stores an IQ stanza depending on the init-state of the app.
	 *
	 * If a non-required IQ stanza arrives before all of the required stanzas have been processed,
	 * it is stored it temporarily.
	 *
	 * Once all {@link requiredStanzas} have arrived, we process the stanzas stored in {@link otherStanzas}.
	 *
	 * @param iq The IQ stanza to process.
	 * @param store The store to receive the stanza.
	 */
	function handleOrStoreStanza(iq, store) {

	  if (allRequiredStanzasProcessed) {
	    handleStanza(iq, store);
	    return;
	  }

	  if (!allRequiredStanzasProcessed && _.contains(requiredStanzas, iq.query.xmlns)) {
	    if (iq.error) {
	      generalErrorHelper(iq);
	    } else {
	      handleStanza(iq, store);

	      processedRequiredStanzas[iq.query.xmlns] = true;
	      allRequiredStanzasProcessed = allRequiredStanzasArrived();

	      if (allRequiredStanzasProcessed) {
	        flushStanzas(store);
	        AppDispatcher.dispatch("app-state-ready");
	      }
	    }
	  } else {
	    queueStanza(iq);
	  }
	}

	module.exports = {

	  /**
	   * Handles an incoming IQ stanza.
	   *
	   * @param iq The IQ stanza
	   * @param store The store to receive the stanza.
	   */
	  handleIQ: function handleIQ(iq, store) {
	    _.forEach(Utils.toArray(iq), function (iq) {
	      if (iq.query) {
	        handleOrStoreStanza(iq, store);
	      } else if (/history:/.test(iq.id)) {
	        AppDispatcher.dispatch("history-loaded", {
	          jid: iq.from,
	          id: iq.id
	        });
	      } else if (iq.type && iq.type === "result") {
	        AppDispatcher.dispatch("ping-response");
	      }
	    });
	  },

	  /**
	   * Resets the IQProcessor to the initial state.
	   *
	   * Exposed for testing only.
	   *
	   * @private
	   */
	  __reset: function __reset() {
	    allRequiredStanzasProcessed = false;
	    processedRequiredStanzas = {};
	    otherStanzas = [];
	  },

	  /**
	   * Returns the current value of allRequiredStanzasProcessed.
	   *
	   * Exposed for testing only.
	   * @private
	   */
	  __isReady: function __isReady() {
	    return allRequiredStanzasProcessed;
	  }
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);

	function handleRoomPresences(presences) {
	  var jid;
	  _.map(presences, function (presence) {
	    jid = Utils.jid.bare_jid(presence.from);
	    if (presence.x) {
	      presence.x = Utils.toArray(presence.x);
	      if (presence.x[0].item) {
	        var item = presence.x[0].item;

	        if (presence.type == "unavailable" && _.isString(presence.status) && (item.affiliation === "member" || item.affiliation === "owner")) {

	          AppDispatcher.dispatch("remove-room-participant", {
	            room: jid,
	            participant: Utils.jid.bare_jid(item.jid),
	            role: item.role == "visitor" ? "guests" : "members",
	            status: presence.status
	          });
	        } else if (presence.x[0].status && presence.x[0].status.code == "307" && item.affiliation == "none") {

	          if (item.actor && Utils.jid.bare_jid(item.actor.jid) == item.jid) {
	            // Basic close room
	            AppDispatcher.dispatch("close-room", {
	              jid: jid
	            });
	          } else {
	            // User was removed by admin
	            AppDispatcher.dispatch("user-removed", {
	              room: jid,
	              user_jid: Utils.jid.bare_jid(item.jid),
	              role: item.role
	            });
	          }
	        } else if (item.role == "visitor") {

	          AppDispatcher.dispatch("add-room-visitor", {
	            room: jid,
	            participant: Utils.jid.bare_jid(item.jid),
	            user_name: Utils.jid.resource(presence.from),
	            user_mention: item.mention_name
	          });
	        } else if (item && item.jid) {

	          AppDispatcher.dispatch("room-presence-received", {
	            room: jid,
	            user_jid: Utils.jid.bare_jid(item.jid),
	            user_id: Utils.jid.user_id(item.jid),
	            role: item.role,
	            affiliation: item.affiliation,
	            type: presence.type || ""
	          });

	          if (presence.x[0].status && presence.x[0].status.code == "110") {
	            // Initial join presence received
	            AppDispatcher.dispatch("room-joined", presence);
	          }
	        }
	      }
	    } else if (presence.type === "error" && presence.error) {

	      AppDispatcher.dispatch("show-flag", {
	        type: "error",
	        title: presence.error.text.__text,
	        close: "auto"
	      });

	      AppDispatcher.dispatch("close-room", {
	        jid: jid,
	        type: "room",
	        doNotNotifyHC: true
	      });
	    }
	  });
	}

	function getState(presence) {
	  if (presence.type && presence.type === "unavailable" && presence.mobile) {
	    return "mobile";
	  } else if (presence.type && presence.type === "unavailable" && !presence.mobile) {
	    return "unavailable";
	  } else if (presence.show === "away" || presence.show === "xa") {
	    return "away";
	  } else if (presence.show) {
	    return presence.show;
	  } else {
	    return "chat";
	  }
	}

	function handleGlobalPresences(presences) {
	  var presObj = _.transform(presences, function (res, presence) {
	    var seconds = presence.query ? presence.query.seconds : false;
	    var delay = presence.delay ? presence.delay.stamp : false;
	    res[Utils.jid.bare_jid(presence.from)] = {
	      show: getState(presence),
	      status: presence.status || "",
	      seconds: seconds || "",
	      idleTime: getIdleTime(seconds, delay)
	    };
	  });
	  AppDispatcher.dispatch("global-presence-received", presObj);
	}

	function getIdleTime(seconds, delay) {
	  var result = "";
	  if (delay && seconds) {
	    var now = Utils.getMoment();
	    var seconds_diff = now - (Utils.getMoment(delay) - seconds);
	    result = Utils.user.format_idle_time(seconds_diff);
	  }
	  return result;
	}

	module.exports = {

	  handlePresence: function (presences) {
	    var presences = _.groupBy(Utils.toArray(presences), function (pres) {
	      if (Utils.jid.is_room(Utils.jid.bare_jid(pres.from))) {
	        return "room";
	      } else {
	        return "global";
	      }
	    });
	    handleRoomPresences(presences.room);
	    handleGlobalPresences(presences.global);
	  }

	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4);
	var Store = __webpack_require__(43);
	var AppDispatcher = __webpack_require__(1);
	var PreferencesKeys = __webpack_require__(68);

	var PreferencesStore = (function (Store) {
	  function PreferencesStore() {
	    _classCallCheck(this, PreferencesStore);

	    if (Store != null) {
	      Store.apply(this, arguments);
	    }
	  }

	  _inherits(PreferencesStore, Store);

	  _prototypeProperties(PreferencesStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          showUnreadDivider: true
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.registerOnce({
	          "hc-init": function (config) {
	            _this.data = _.assign(_this.getDefaults(), config.prefs, { features: config.features });
	          }
	        });
	        AppDispatcher.register({
	          "updated:active_chat": function (jid) {
	            _this.setChatToFocus(jid);
	          },
	          "updated:features": function (data) {
	            _this.data.features = data;
	          },
	          "save-preferences": function (prefs) {
	            var hasChange = _.any(_.keys(prefs), function (key) {
	              return !_.isEqual(_this.data[key], prefs[key]);
	            });
	            if (hasChange) {
	              _this.set(prefs);
	            }
	          },
	          "close-room": function (data) {
	            _this.removeRoom(data);
	          },
	          "toggle-sound-notifications": function () {
	            _this.toggleDisableSounds();
	          }
	        });

	        this.on("change", function () {
	          AppDispatcher.dispatch("updated:preferences", _this.getAll());
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    getAutoJoinRooms: {
	      value: function getAutoJoinRooms() {
	        return this.get("autoJoin");
	      },
	      writable: true,
	      configurable: true
	    },
	    getChatToFocus: {
	      value: function getChatToFocus() {
	        return this.get("chatToFocus");
	      },
	      writable: true,
	      configurable: true
	    },
	    getDisableSounds: {
	      value: function getDisableSounds() {
	        return this.get(PreferencesKeys.DISABLE_SOUNDS);
	      },
	      writable: true,
	      configurable: true
	    },
	    toggleDisableSounds: {
	      value: function toggleDisableSounds() {
	        this.set(PreferencesKeys.DISABLE_SOUNDS, !this.getDisableSounds());
	        this.savePrefs();
	      },
	      writable: true,
	      configurable: true
	    },
	    getHidePresenceMessages: {
	      value: function getHidePresenceMessages() {
	        return this.get(PreferencesKeys.HIDE_PRESENCE_MESSAGES);
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldUse24HrTime: {
	      value: function shouldUse24HrTime() {
	        return this.get(PreferencesKeys.USE_24_HR_FORMAT) || false;
	      },
	      writable: true,
	      configurable: true
	    },
	    setChatToFocus: {
	      value: function setChatToFocus(jid) {
	        this.set({
	          chatToFocus: jid ? jid.replace(/"/g, "") : ""
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    removeRoom: {
	      value: function removeRoom(data) {
	        var autoJoinRooms = _.filter(this.getAutoJoinRooms(), function (room) {
	          return room.jid !== data.jid;
	        });
	        AppDispatcher.dispatch("save-preferences", {
	          autoJoin: autoJoinRooms
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    savePrefs: {
	      value: function savePrefs() {
	        AppDispatcher.dispatch("save-preferences", this.getAll());
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return PreferencesStore;
	})(Store);

	module.exports = new PreferencesStore();

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  show_more: "Show more",
	  show_less: "Show less",
	  failed_message: "This message didn't make it. Nobody saw it.",
	  failed_message_retry: "Retry",
	  user_leave: function user_leave(name) {
	    return "" + name + " left the room";
	  },
	  user_join: function user_join(name) {
	    return "" + name + " joined the room";
	  },
	  user_removed: function user_removed(name) {
	    return "" + name + " was removed from the room";
	  },
	  user_added: function user_added(name) {
	    return "" + name + " was added to the room";
	  },
	  user_leave_reason: function user_leave_reason(name, reason) {
	    return "" + name + " left the room (" + reason + ")";
	  },
	  user_changed_guest_access: function user_changed_guest_access(name, action) {
	    return "" + name + " " + action + " guest access";
	  },
	  user_changed_archive_status: function user_changed_archive_status(name, action) {
	    return "" + name + " " + action + " the room";
	  },
	  generic_message: function generic_message(name) {
	    return "Message from " + name;
	  },
	  you_have_been_removed: "You have been removed from the room",
	  archived: "archived",
	  unarchived: "unarchived",
	  user_disconnected: "user disconnected",
	  not_allowed: "guest access unavailable",
	  lost_connection: "lost connection",
	  turned_on: "turned on",
	  turned_off: "turned off"
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  RE_EMAIL_PATTERN: "[a-z0-9!#$%&'*+/=?^_`{|}~\\-]+(?:[.][a-z0-9!#$%&'*+/=?^_`{|}~\\-]+)*@(?:[a-z0-9](?:[a-z0-9\\-]*[a-z0-9])?[.])+[a-z0-9](?:[a-z0-9\\-]*[a-z0-9])?",
	  // adapted from: http://daringfireball.net/2010/07/improved_regex_for_matching_urls
	  RE_URL: "\\b" + "(" + // capture entire URL
	  "(?:" + "((?!javascript)[a-z][\\w\\-]+:" + // URL protocol and colon (not javascript:) -- captured so we can add http if needed
	  "(?:" + "/{1,3}" + // 1-3 slashes
	  "))" + "|" + "(?:[a-z0-9.\\-]+[.]" + "(?:com|net|org|edu|gov|mil|aero|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|post|pro|tel|travel|xxx|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|ja|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw)" + "[/#?])" + ")" + "[\\w#?]" + // force a word char or #? char after the url scheme
	  "(?:" + "(?:%[0-9a-f]{2})" + // allow url encoded values
	  "|" + "(?::\\d+)" + // :port, insert no colons allowed joke here
	  "|" + "[a-z0-9\\-._~/?#[\\]@!$&'*+,:;=]" + // allowable chars per http://tools.ietf.org/html/rfc3986#section-2
	  "|" + "(?:\\([^\\s\\()]*?\\([^\\s\\()]+\\)[^\\s\\()]*?\\))" + // balanced parens, one level deep: (…(…)…)
	  "|" + "(?:\\([^\\s]+?\\))" + // balanced parens, non-recursive: (…)
	  ")+" + "(?:" + "(?:\\([^\\s()]*?\\([^\\s()]+\\)[^\\s()]*?\\))" + //balanced parens, one level deep: (…(…)…)
	  "|" + "(?:\\([^\\s]+?\\))" + // balanced parens, non-recursive: (…)
	  "|" + "[^\\s`!()\\[\\]:{};'\".,<>?«»“”‘’]" + // not a space or one of these punct chars
	  ")" + "|" + // OR, the following to match naked domains:
	  "(?:" + "[a-z0-9]+" + "(?:[.\\-][a-z0-9]+)*" + "[.]" +
	  // removed py and sh to avoid linking script filenames
	  "(?:com|net|org|edu|gov|mil|aero|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|post|pro|tel|travel|xxx|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|si|sj|ja|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw)" + "\\b/?" + "(?!@)" + // not succeeded by a @, avoid matching "foo.na" in "foo.na@example.com"
	  ")" + ")",

	  /**
	   * Linkify a string, replacing text urls with <a href="url">url</a>
	   * Note: init must be called before this function can be used
	   *
	   * @param text - String to be linkified
	   * @param matched_links - Return param (pass by ref) - Array of links matched during linkification
	   * @param config - Hash of options for linkifier
	   *          add_wbrs (bool) - Add <wbr> tags to displayed text to allow wrapping?
	   *          truncate_length (int) - Truncate displayed links to this length
	   *          link_target (str) - Target attribute for links
	   *          link_titles (bool) - Add titles for links?
	   **/
	  linkify: function linkify(text, matched_links, config) {
	    text = this.match_and_replace(this.RE_EMAIL_PATTERN, text, true, false, matched_links, config);
	    text = this.match_and_replace(this.RE_URL, text, false, true, matched_links, config);

	    return text;
	  },

	  /**
	   * Internal helper function for linkification
	   **/
	  match_and_replace: function match_and_replace(pattern, input, is_email, add_http, matched_links, config) {
	    var start = 0;
	    var offset = 0;
	    var match_length = 0;
	    var end_tag_pos = 0;
	    var close_anchor_re = /<\/[aA]>/;
	    var re = new RegExp(pattern, "gi");

	    // config
	    var add_wbrs = config.hasOwnProperty("add_wbrs") ? config.add_wbrs : null;
	    var truncate_length = config.hasOwnProperty("truncate_length") ? config.truncate_length : 100;
	    var link_target = config.hasOwnProperty("link_target") ? config.link_target : "_blank";
	    var link_titles = config.hasOwnProperty("link_titles") ? config.link_titles : null;

	    var match = {};
	    var max_iter = 20;
	    var cur_iter = 0;
	    while (match = re.exec(input)) {
	      cur_iter++;
	      if (cur_iter > max_iter) break;

	      start = match.index; // start of match
	      match_length = match[0].length;

	      // If we find an opening a tag, advance to its end and continue looking
	      var substr = input.substring(offset, start);
	      if (substr.search(/<[aA]/) >= 0) {
	        close_anchor_re.lastIndex = offset;
	        var close_anchor_pos = input.substring(offset, input.length).search(close_anchor_re);

	        // If we find an opening tag without a matching closing tag, just return the input we have
	        if (close_anchor_pos < 0) {
	          return input;
	        }end_tag_pos = close_anchor_pos + offset;

	        // RegExp.lastIndex is used to tell the regexp where to start matching
	        re.lastIndex = end_tag_pos + 4;
	        offset = end_tag_pos + 4;

	        continue;
	      }

	      // Do the actual replecement of text with anchor tag
	      var address = input.substr(start, match_length);

	      // Since we escape before linkifying, we need to make sure that the matched link
	      // doesn't actually end with an escaped character (&, <, or >)
	      // If it does, move the match backwards so as not to include the escaped character
	      // Then, keep moving the match back until it ends with a valid character (defined by RE_URL_ENDCHAR)
	      var escaped_char_match_pos = address.search(/&(amp|gt|lt)$/);
	      if (escaped_char_match_pos > 0 && input.length > start + match_length && input[start + match_length] == ";") {
	        var num_chars_matched = address.length - escaped_char_match_pos;
	        match_length -= num_chars_matched;
	        address = input.substr(start, match_length);
	        while (!address.match(this.RE_URL_ENDCHAR + "$") && match_length > 0) {
	          match_length--;
	          address = input.substr(start, match_length);
	        }
	      }
	      var actual = address;

	      if (add_http && !match[2]) {
	        actual = "http://" + actual;
	      }

	      var replacement = "<a";

	      // link target?
	      if (link_target) {
	        replacement += " target=\"" + link_target + "\"";
	      }

	      replacement += " href=\"";

	      if (is_email) {
	        replacement += "mailto:";
	      }

	      actual = actual.replace(/"/g, "%22");
	      replacement += actual + "\"";

	      // add title
	      if (link_titles) {
	        var title = is_email ? "Email " + actual : actual;
	        replacement += " title=\"" + title + "\"";
	      }

	      // Truncate displayed text if requested
	      if (truncate_length && address.length > truncate_length) {
	        address = address.substr(0, truncate_length) + "...";
	      }

	      // Add word break tags to allow wrapping where appropriate
	      if (add_wbrs) {
	        address = address.replace(new RegExp("([/=])", "g"), "<wbr>$1");
	      }

	      replacement += ">" + address + "</a>";

	      // Record what was matched
	      if (matched_links) {
	        matched_links.push(actual);
	      }

	      // Do the replacement
	      input = input.slice(0, start) + replacement + input.slice(start + match_length, input.length);
	      re.lastIndex = start + replacement.length;
	      offset = start + replacement.length;
	    }

	    return input;
	  }

	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  init: function init() {
	    return {
	      audio: ["aif", "aiff", "mp3", "wav", "wma"],
	      code: ["asp", "coffee", "css", "html", "htm", "java", "js", "json", "jsp", "less", "lib", "php", "prl", "py", "sass", "sh", "xml"],
	      doc: ["doc", "docm", "docx", "dotm", "dotx", "gdoc", "pages"],
	      ai: ["ai"],
	      psd: ["psd"],
	      img: ["bmp", "gif", "jpg", "jpeg", "png", "tif", "tiff"],
	      pdf: ["pdf"],
	      presentation: ["keynote", "ppam", "ppsm", "ppsx", "ppt", "pptm", "pptx"],
	      spreadsheet: ["numbers", "ods", "xlam", "xls", "xlsb", "xlsm", "xlsx", "xltm", "xltx"],
	      vector: ["dxf", "eps", "svg"],
	      video: ["flv", "m4v", "mov", "mp4", "wmv", "webm", "ogv"],
	      zip: ["apk", "gz", "rar", "tar", "zip", "zipx"]
	    };
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  init: function init() {
	    return {
	      "image/jpg": "jpg",
	      "image/png": "png",
	      "image/gif": "gif",
	      "image/svg+xml": "svg",
	      "audio/mpeg3": "mpg3",
	      "audio/wav": "wav",
	      "application/pdf": "pdf",
	      "application/text": "txt",
	      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
	      "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
	      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
	      "video/mp4": "mp4",
	      "video/quicktime": "mov"
	    };
	  }
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var lifecycleAwareMethods = ["componentWillMount", "componentDidMount", "componentWillReceiveProps", "componentWillUpdate", "componentDidUpdate", "componentWillUnmount"];

	var base = {
	  displayName: "RehackedPlaceholder",

	  render: function render() {
	    return React.createElement(this.props.node, this.props.props);
	  }
	};

	var proxyLifecycleMethods = function proxyLifecycleMethods(base) {
	  var lifecycleMethods = lifecycleAwareMethods.map(function (method) {
	    return function () {
	      var requested = this.props.lifecycle[method];
	      requested && requested.apply(this, arguments);
	    };
	  });
	  return _.extend(_.object(lifecycleAwareMethods, lifecycleMethods), base);
	};

	module.exports = React.createClass(proxyLifecycleMethods(base));
	/* arguments */

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * KeyboardShortcutActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AppStore = __webpack_require__(2);
	var ChatHeaderStore = __webpack_require__(70);
	var CurrentUserStore = __webpack_require__(71);
	var Utils = __webpack_require__(4);

	var KeyboardShortcutActions = {

	  openLobby: function openLobby() {
	    AppDispatcher.dispatch("select-room", {
	      jid: "lobby"
	    });
	  },

	  createRoom: function createRoom() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "create-room-dialog",
	      dialog_data: false
	    });
	  },

	  inviteUsersToRoom: function inviteUsersToRoom() {
	    var room = ChatHeaderStore.get("chat"),
	        jid = AppStore.get("active_chat"),
	        user = CurrentUserStore.get("user");

	    if (room.type !== "chat" && jid !== "lobby" && !Utils.room.is_archived(room)) {
	      if (room.privacy === "public" || room.privacy === "private" && Utils.user.is_admin(room.admins, room.owner, user)) {
	        AppDispatcher.dispatch("show-modal-dialog", {
	          dialog_type: "invite-users-dialog",
	          dialog_data: false
	        });
	      }
	    }
	  },

	  searchHistory: function searchHistory() {
	    AppDispatcher.dispatch("focus-search");
	  },

	  closeRoom: function closeRoom() {
	    var jid = AppStore.get("active_chat");
	    if (jid && jid !== "lobby") {
	      AppDispatcher.dispatch("close-room", {
	        jid: jid
	      });
	    }
	  },

	  navigateRoomsUp: function navigateRoomsUp() {
	    AppDispatcher.dispatch("navigate-rooms", {
	      direction: "up"
	    });
	  },

	  navigateRoomsDown: function navigateRoomsDown() {
	    AppDispatcher.dispatch("navigate-rooms", {
	      direction: "down"
	    });
	  },

	  openSettings: function openSettings() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "settings-dialog",
	      dialog_data: false
	    });
	  },

	  toggleSoundNotifications: function toggleSoundNotifications() {
	    AppDispatcher.dispatch("toggle-sound-notifications");
	  }

	};

	module.exports = KeyboardShortcutActions;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * DialogActions
	 *
	 * Exposed a window. Used for exposing actions to non react managed actions
	 * like mention clicks, etc.
	 */

	var AppDispatcher = __webpack_require__(1);

	module.exports = {

	  closeDialog: function closeDialog() {
	    AppDispatcher.dispatch("hide-modal-dialog");
	  },

	  startBtnLoading: function startBtnLoading() {
	    AppDispatcher.dispatch("modal-dialog-btn-loading", {
	      loading: true
	    });
	  },

	  stopBtnLoading: function stopBtnLoading() {
	    AppDispatcher.dispatch("modal-dialog-btn-loading", {
	      loading: false
	    });
	  },

	  showSettingDialog: function showSettingDialog() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "settings-dialog",
	      dialog_data: false
	    });
	  },

	  showInviteUsersDialog: function showInviteUsersDialog() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "invite-users-dialog",
	      dialog_data: false
	    });
	  },

	  showRemoveUsersDialog: function showRemoveUsersDialog() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "remove-users-dialog",
	      dialog_data: false
	    });
	  },

	  showCreateRoomDialog: function showCreateRoomDialog() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "create-room-dialog",
	      dialog_data: false
	    });
	  },

	  showRoomPrivacyDialog: function showRoomPrivacyDialog(data) {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "room-privacy-dialog",
	      dialog_data: data
	    });
	  },

	  showRenameRoomDialog: function showRenameRoomDialog(data) {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "rename-room-dialog",
	      dialog_data: data
	    });
	  },

	  showDeleteRoomDialog: function showDeleteRoomDialog(data) {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "delete-room-dialog",
	      dialog_data: data
	    });
	  },

	  showArchiveRoomDialog: function showArchiveRoomDialog(data) {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "archive-room-dialog",
	      dialog_data: data
	    });
	  },

	  showDisableGuestAccessDialog: function showDisableGuestAccessDialog() {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "disable-guest-dialog",
	      dialog_data: false
	    });
	  },

	  showKeyboardShortcutsDialog: function showKeyboardShortcutsDialog(shortcuts) {
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "keyboard-shortcuts-dialog",
	      dialog_data: {
	        shortcuts: shortcuts
	      }
	    });
	  }

	};

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  separator: "+",
	  control: "Ctrl",
	  alt: "Alt",
	  option: "Option",
	  shift: "Shift",
	  space: "Space",
	  command: "⌘",
	  up_arrow: "↑",
	  down_arrow: "↓",
	  new_chat: "New chat",
	  room_invite_users: "Invite to room",
	  search_history: "Search chat history",
	  close_room: "Close room",
	  navigate_rooms_up: "Navigate rooms up",
	  navigate_rooms_down: "Navigate rooms down",
	  toggle_sound_notifications: "Toggle sound notifications",
	  view_shortcuts: "View shortcuts"
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4);

	var AnalyticsEngine = (function () {
	  function AnalyticsEngine(initConfig, events, dispatcher, eventQueue) {
	    var _this = this;

	    _classCallCheck(this, AnalyticsEngine);

	    this.eventQueue = eventQueue;
	    this.baseEvent = {
	      server: "gid-" + initConfig.group_id,
	      product: "HipChat",
	      subproduct: "hc_web",
	      user: "uid-" + initConfig.user_id,
	      properties: {
	        client: "web",
	        isAdmin: initConfig.is_admin
	      }
	    };

	    _.forOwn(events, function (handler, hcWebEvent) {
	      if (typeof handler === "string") {
	        var eventName = handler;
	        handler = function () {
	          return {
	            name: eventName
	          };
	        };
	      }

	      dispatcher.register(hcWebEvent, function () {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        return _this.sendEvents(handler.apply(_this, args));
	      });
	    });
	  }

	  _prototypeProperties(AnalyticsEngine, null, {
	    getTime: {
	      value: function getTime() {
	        return new Date().getTime();
	      },
	      writable: true,
	      configurable: true
	    },
	    makeEvent: {

	      /**
	       * Decorates an event with the current server time and other required properties.
	       *
	       * @param event
	       * @return {*}
	       */

	      value: function makeEvent(event) {
	        this.processRoomType(event);
	        event.serverTime = this.getTime();
	        return _.merge({}, this.baseEvent, event);
	      },
	      writable: true,
	      configurable: true
	    },
	    sendEvents: {

	      /**
	       * Pushes the events onto the Herment stack.
	       * @param result
	       */

	      value: function sendEvents(result) {
	        var _this = this;

	        if (result) {

	          var events = Utils.toArray(result);
	          _.each(events, function (event) {
	            _this.eventQueue.push(_this.makeEvent(event));
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    processRoomType: {

	      /**
	       * Ensures we have a valid room type.
	       *
	       * We sometimes get an event type. This makes sure this doesn't get through to GAS.
	       *
	       * @param event The event.
	       * @return {*}
	       */

	      value: function processRoomType(event) {
	        if (event && event.properties && event.properties.type && typeof event.properties.type !== "string") {
	          delete event.properties.type;
	        }
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return AnalyticsEngine;
	})();

	module.exports = AnalyticsEngine;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var hasEnteredText = false;
	var Emoticons = __webpack_require__(5);
	var Linkify = __webpack_require__(23);

	var ALL_MENTION_REGEX = /(?=[^\\w>]|^)@all(?=[^\\w<]|$)/gi;
	var HERE_MENTION_REGEX = /(?=[^\\w>]|^)@here(?=[^\\w<]|$)/gi;
	var USER_MENTION_REGEX = /(?=[^\\w>]|^)@[a-z0-9\-]+(?=[^\\w<]|$)/gi;
	var URL_MENTION_REGEX = new RegExp(Linkify.RE_URL, "gi");

	/**
	 * Adds an input abandoned event if there is current text in the input field.
	 * @param events
	 */
	function checkChatAbandoned(events) {
	  if (hasEnteredText) {
	    events.push({
	      name: "hipchat.client.message.input.abandoned"
	    });
	  }
	}

	/**
	 * Can be called when a room is closed and a new one is subsequently selected.
	 * So please don't remove the isClose below. :)
	 *
	 * @param properties
	 * @return {*}
	 */
	function onSelectRoom(properties) {
	  var isLobby = properties.jid === "lobby";
	  var event = {
	    name: isLobby ? "hipchat.client.lobby.viewed" : "hipchat.client.chat.viewed"
	  };

	  var finalProps = {};

	  if (properties.isClose) {
	    finalProps.isClose = true;
	  }

	  if (!isLobby) {
	    finalProps.type = properties.type;
	  }

	  if (!_.isEmpty(finalProps)) {
	    event.properties = finalProps;
	  }

	  var events = [event];

	  checkChatAbandoned(events);

	  return events;
	}

	/**
	 * Called when a room is newly opened from the lobby.
	 *
	 * @param properties
	 * @return {*}
	 */
	function onOpenRoom(properties) {
	  return {
	    name: "hipchat.client.lobby.open.room",
	    properties: {
	      isNew: true,
	      type: properties.type
	    }
	  };
	}

	function onChatInputChanged(text) {
	  hasEnteredText = !_.isEmpty(text);
	}

	function messageContainsGroupMention(message) {
	  message = message.trim();
	  return ALL_MENTION_REGEX.test(message) || HERE_MENTION_REGEX.test(message);
	}

	/**
	 * TODO make this use the roster.
	 * @param message
	 * @returns {boolean}
	 */
	function messageContainsUserMention(message) {
	  message = message.trim();
	  return USER_MENTION_REGEX.test(message);
	}

	function onChatSent(data) {
	  var events = [];
	  if (hasEnteredText) {
	    var emoticons = Emoticons.getEmoticons(data.text);
	    if (emoticons.length > 0) {
	      events.push({
	        name: "hipchat.client.emoticon.used",
	        properties: {
	          emoticonCount: emoticons.length
	        }
	      });
	    }

	    if (messageContainsGroupMention(data.text)) {
	      events.push({
	        name: "hipchat.client.message.group.mentioned"
	      });
	    } else if (messageContainsUserMention(data.text)) {
	      events.push({
	        name: "hipchat.client.message.user.mentioned"
	      });
	    }

	    if (URL_MENTION_REGEX.test(data.text)) {
	      events.push({
	        name: "hipchat.client.message.url.sent"
	      });
	    }

	    hasEnteredText = false;
	    events.push({
	      name: "hipchat.client.message.input.changed"
	    });
	  }

	  return events;
	}

	function onCreateRoom() {
	  return {
	    name: "hipchat.client.room.created"
	  };
	}

	function onUpdatePresence(presence) {
	  var eventType;
	  switch (presence.show) {
	    case "xa":
	      eventType = "away";
	      break;
	    case "dnd":
	      eventType = "donotdisturb";
	      break;
	    case "chat":
	      eventType = "available";
	  }
	  if (eventType) {
	    return {
	      name: "hipchat.client.top.navigation.profile.status.clicked." + eventType
	    };
	  }
	}

	function handleAnalyticsEvent(event) {
	  return event;
	}

	function onFilterLobby(data) {
	  var type;

	  if (data && data.scope) {
	    switch (data.scope) {
	      case "all":
	        type = "search";
	        break;
	      default:
	        type = data.scope;
	    }
	    return {
	      name: "hipchat.client.lobby.filter." + type
	    };
	  }
	}

	module.exports = {
	  events: {
	    "analytics-select-room": onSelectRoom,
	    "analytics-open-room": onOpenRoom,
	    "analytics-set-message-value": onChatInputChanged,
	    "analytics-send-message": onChatSent,
	    "analytics-create-room": onCreateRoom,
	    "analytics-event": handleAnalyticsEvent,
	    "analytics-update-presence": onUpdatePresence,
	    "analytics-filter-lobby": onFilterLobby },

	  /**
	   * Exposed for testing
	   * @private
	   */
	  __reset: function __reset() {
	    hasEnteredText = false;
	  }
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = function (eventQueue) {
	  // Some basic configuration and checks
	  var STORAGE_KEY = "herment-storage-key";
	  var PUBLISH_INTERVAL = 45000;
	  eventQueue = eventQueue || [];
	  var SenderNS = {};
	  var MetricsCollectionEndpoint = "analytics.atlassian.com";

	  /**
	   * Does the actual ajax call to the server
	   *
	   * @param events {object[]}
	   * @param [ajaxCall] {function}
	   * @returns {*} ajax post result
	   */
	  SenderNS.pushToServer = function (events, ajaxCall) {
	    if (typeof window.$ === "undefined" && typeof ajaxCall === "undefined") {
	      return;
	    }
	    SenderNS.$ajax = window.$.ajax;

	    var postTo = "https://" + MetricsCollectionEndpoint + "/analytics/events";

	    var ajax = typeof ajaxCall !== "undefined" ? ajaxCall : SenderNS.$ajax;
	    var postObject = { events: events };
	    var postString = JSON.stringify(postObject);
	    if (typeof ajax !== "undefined") {
	      return ajax({
	        type: "POST",
	        url: postTo,
	        data: postString,
	        crossDomain: true,
	        contentType: "application/json",
	        dataType: "json"
	      });
	    }
	  };

	  /**
	   * Does trawl through the eventQueue events and if finds any packages them up
	   * and calls SenderNS.pushToServer for ajax post
	   *
	   * @param pushServer
	   */
	  SenderNS.publishFromQueueAndStorage = function (pushServer) {
	    var pushEvents = typeof pushServer !== "undefined" ? pushServer : SenderNS.pushToServer;
	    var events = [];

	    if (eventQueue.length < 1 && window.sessionStorage.length < 1) {
	      return;
	    }

	    var serverName = "unidentified";

	    if (typeof document.location !== "undefined") {
	      if (typeof document.location.hostname !== "undefined") {
	        serverName = document.location.hostname;
	      }
	    }

	    if (serverName === "") {
	      serverName = "unidentified";
	    }

	    var productName = serverName.replace(".com", "").replace(".net", "").replace(".org", "").replace(".au", "").replace(".io", "");

	    SenderNS.addEventsToArray(eventQueue, events, serverName, productName);
	    var storedEvents = SenderNS.popEventsFromStorage();
	    SenderNS.addEventsToArray(storedEvents, events, serverName, productName);

	    eventQueue.length = 0;

	    // POST events to the server
	    if (events && events.length) {
	      pushEvents(events);
	    }
	  };

	  /**
	   * Supplementary function; Adds all events from a given array, to the destination one.
	   * Adds a few common parameters to each of the events
	   *
	   * @param inputEvents Array to take events from
	   * @param resultingArray Array to add events to
	   */
	  SenderNS.addEventsToArray = function (inputEvents, resultingArray) {
	    resultingArray.push.apply(resultingArray, inputEvents);
	  };

	  /**
	   * Serialises events list to a string.
	   * @param events Array of event objects
	   * @returns {*} JSON string
	   */
	  SenderNS.serialiseEventsToString = function (events) {
	    return JSON.stringify(events);
	  };

	  /**
	   * De-serialises string to a JSON.
	   * @param eventsString - JSON string
	   * @returns {*} events Array of event objects
	   */
	  SenderNS.deserialiseEvents = function (eventsString) {
	    return JSON.parse(eventsString);
	  };

	  /**
	   * Stores events from the parameter to the sessionStorage
	   * @param events
	   */
	  SenderNS.storeEvents = function (events) {
	    if (typeof window.sessionStorage === "undefined") {
	      return;
	    }

	    if (!window.sessionStorage[STORAGE_KEY]) {
	      try {
	        window.sessionStorage.setItem(STORAGE_KEY, SenderNS.serialiseEventsToString(events));
	      } catch (e) {}
	    } else {
	      var olderEvents = SenderNS.deserialiseEvents(window.sessionStorage[STORAGE_KEY]) || [];
	      olderEvents.push.apply(olderEvents, events);
	      try {
	        window.sessionStorage.setItem(STORAGE_KEY, SenderNS.serialiseEventsToString(olderEvents));
	      } catch (e) {}
	    }
	  };

	  /**
	   * Takes all events from the sessionStorage, removes them from sessionStorage and returns them
	   * @returns {*} events Array
	   */
	  SenderNS.popEventsFromStorage = function () {
	    if (typeof window.sessionStorage === "undefined") {
	      return [];
	    }
	    if (window.sessionStorage[STORAGE_KEY]) {
	      var events = SenderNS.deserialiseEvents(window.sessionStorage[STORAGE_KEY]);
	      window.sessionStorage[STORAGE_KEY] = SenderNS.serialiseEventsToString([]);
	      return events;
	    } else {
	      return [];
	    }
	  };

	  /**
	   * Moves all of the events from the eventQueue to the sessionStorage
	   */
	  SenderNS.moveQueueToStorage = function () {
	    if (eventQueue.length === 0 || typeof window.sessionStorage === "undefined") {
	      return;
	    }
	    SenderNS.storeEvents(eventQueue);
	    eventQueue.length = 0;
	  };

	  /**
	   * Called when this script is sourced. Creates a timer to call SenderNS.publishFromQueueAndStorage in intervals.
	   * Also calls moveQueueToStorage each 1000ms to move any queued events to the storage, so to preserve any
	   * events in the queue in case user navigates away
	   */
	  SenderNS.startTimer = function () {
	    // Snapshot to storage periodically and post to server every PUBLISH_INTERVAL
	    setInterval(SenderNS.publishFromQueueAndStorage, PUBLISH_INTERVAL);
	    setInterval(SenderNS.moveQueueToStorage, 1000);
	  };
	  SenderNS.startTimer();

	  /**
	   * Saves any leftovers in the queue to the sessionStorage before user navigates away
	   */
	  if (typeof window.$ !== "undefined") {
	    window.$(window).unload(function () {
	      SenderNS.moveQueueToStorage();
	    });
	  }
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * ChatWindowActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);

	var ChatWindowActions = {

	  requestAncientHistory: function requestAncientHistory(data) {
	    AppDispatcher.dispatch("requesting-ancient-history", data);
	  },

	  setScrollValue: function setScrollValue(data) {
	    AppDispatcher.dispatch("set-scroll-value", data);
	  },

	  chatStartedScroll: function chatStartedScroll(jid) {
	    AppDispatcher.dispatch("chat-is-scrolling", { scrolling: true, jid: jid });
	  },

	  chatStoppedScroll: function chatStoppedScroll(jid) {
	    AppDispatcher.dispatch("chat-is-scrolling", { scrolling: false, jid: jid });
	  },

	  senderClick: function senderClick(data) {
	    AppDispatcher.dispatch("sender-clicked", data);
	  },

	  chatPanelMounted: function chatPanelMounted(data) {
	    AnalyticsDispatcher.dispatch("analytics-chat-mount", data);
	  }

	};

	module.exports = ChatWindowActions;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var UserStatus = __webpack_require__(72);
	var AppActions = __webpack_require__(44);
	var RoomNavActions = __webpack_require__(55);
	var AppHeaderStore = __webpack_require__(73);
	var AppDispatcher = __webpack_require__(1);
	var NotificationBanner = __webpack_require__(74);
	var InlineDialogActions = __webpack_require__(51);

	module.exports = React.createClass({

	  displayName: "AppHeader",

	  getInitialState: function getInitialState() {
	    return AppHeaderStore.getAll();
	  },

	  componentDidMount: function componentDidMount() {
	    AppHeaderStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    AppHeaderStore.off("change", this._onChange);
	  },

	  _onLogoClick: function _onLogoClick() {
	    AppActions.logoClicked();
	  },

	  _onNewChatClick: function _onNewChatClick(evt) {
	    RoomNavActions.openLobby();
	    evt.preventDefault();
	  },

	  _getUserStatus: function _getUserStatus() {
	    if (this.state.ready) {
	      return React.createElement(UserStatus, {
	        search_text: this.state.search_text,
	        focus_search: this.state.focus_search,
	        active_chat: this.state.active_chat });
	    }
	  },

	  _getNewChatButton: function _getNewChatButton() {
	    if (this.state.ready) {
	      return React.createElement(
	        "ul",
	        { className: "aui-nav", "data-skate-ignore": true },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._onNewChatClick, className: "aui-button aui-button-primary", title: "New chat" },
	            "New chat"
	          )
	        )
	      );
	    }
	  },

	  _getInviteUserButton: function _getInviteUserButton() {
	    if (this.state.ready) {
	      return React.createElement(
	        "ul",
	        { className: "aui-nav", "data-skate-ignore": true },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._onInviteUserClick, className: "aui-button aui-button-link hc-invite-users aui-inline-dialog-trigger", title: "Invite user" },
	            "Invite your team"
	          )
	        )
	      );
	    }
	  },

	  _onInviteUserClick: function _onInviteUserClick(evt) {
	    InlineDialogActions.showInviteNewUsersForm({ button: evt.target });
	  },

	  _onChange: function _onChange() {
	    this.setState(this.getInitialState());
	  },

	  render: function render() {

	    var userStatus = this._getUserStatus();
	    var newChatButton = this._getNewChatButton();
	    var inviteUsersButton = this._getInviteUserButton();

	    var banner;
	    if (this.state.notification_supported && !this.state.notification_dismissed_forever && !this.state.notification_permission) {
	      banner = React.createElement(NotificationBanner, { notification_supported: this.state.notification_supported,
	        notification_dismissed: this.state.notification_dismissed,
	        notification_preference: this.state.notification_preference,
	        notification_dismissed_forever: this.state.notification_dismissed_forever,
	        notification_permission: this.state.notification_permission });
	    }

	    return React.createElement(
	      "header",
	      { id: "header", role: "banner" },
	      banner,
	      React.createElement(
	        "nav",
	        { className: "aui-header aui-dropdown2-trigger-group", role: "navigation", "data-aui-responsive": "true" },
	        React.createElement(
	          "div",
	          { className: "aui-header-inner" },
	          React.createElement(
	            "div",
	            { className: "aui-header-primary" },
	            React.createElement(
	              "h1",
	              { id: "logo", className: "aui-header-logo aui-header-logo-hc" },
	              React.createElement(
	                "a",
	                { href: "/", onClick: this._onLogoClick },
	                React.createElement(
	                  "span",
	                  { className: "aui-header-logo-device" },
	                  "HipChat"
	                )
	              )
	            ),
	            newChatButton,
	            inviteUsersButton
	          ),
	          userStatus
	        )
	      )
	    );
	  }
	});

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ConnectionStore = __webpack_require__(75),
	    ConnectionActions = __webpack_require__(47),
	    strings = __webpack_require__(76),
	    Spinner = __webpack_require__(77);

	var getConnectionState = function getConnectionState() {
	  return ConnectionStore.getAll();
	};

	module.exports = React.createClass({

	  displayName: "ConnectionNotification",

	  getInitialState: function getInitialState() {
	    return getConnectionState();
	  },

	  componentDidMount: function componentDidMount() {
	    ConnectionStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    ConnectionStore.off("change", this._onChange);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-box-shadow hc-message warning hc-connection-notification " + (this._shouldHideNotification() ? "transparent " : " ") + (this.state.connection.reconnecting ? "waiting" : "") },
	      React.createElement(
	        "div",
	        { className: "spin-wrap" },
	        React.createElement(Spinner, { spin: this.state.connection.reconnecting, className: "reconnect-spinner", size: "small" })
	      ),
	      React.createElement(
	        "p",
	        { className: "title" },
	        React.createElement(
	          "strong",
	          null,
	          strings.failed_connection
	        )
	      ),
	      React.createElement(
	        "p",
	        null,
	        React.createElement(
	          "a",
	          { href: "javascript:void(0)", onClick: this._onClick, className: this.state.connection.reconnecting ? "inactive" : "" },
	          this.state.connection.reconnecting ? strings.attempt_reconnect : strings.reconnect_now
	        )
	      )
	    );
	  },

	  _onChange: function _onChange() {
	    this.setState(getConnectionState());
	  },

	  _onClick: function _onClick(e) {
	    if (!$(e.currentTarget).hasClass("inactive")) {
	      ConnectionActions.handleReconnectLinkClick();
	    }
	  },

	  _shouldHideNotification: function _shouldHideNotification() {
	    return this.state.force_hide || this.state.connection.connected && this.state.connection.disconnecting || this.state.connection.connected;
	  }

	});

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var InlineDialogActions = __webpack_require__(51);

	module.exports = {
	  componentDidMount: function componentDidMount() {
	    window.addEventListener("keydown", _hideLayerFromEscKeypress);
	    window.addEventListener("click", _hideLayerFromClick);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    window.removeEventListener("keydown", _hideLayerFromEscKeypress);
	    window.removeEventListener("click", _hideLayerFromClick);
	  },

	  _onKeyDown: _hideLayerFromEscKeypress
	};

	function _hideLayerFromEscKeypress(e) {
	  var intKey = window.Event ? e.which : e.keyCode;
	  if (intKey === 27) {
	    InlineDialogActions.hideInlineDialog();
	  }
	}

	function _hideLayerFromClick(e) {
	  var $target = $(e.target);
	  if ($target.closest(".aui-inline-dialog-trigger").length === 0 && $target.parents(".aui-inline-dialog").length === 0) {
	    InlineDialogActions.hideInlineDialog();
	  }
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1),
	    GeneralErrorsStore = __webpack_require__(78),
	    LayoutStore = __webpack_require__(79),
	    LeftSidebar = __webpack_require__(80),
	    MainCol = __webpack_require__(81),
	    RandomLoadMessage = __webpack_require__(82),
	    GeneralErrorDisplay = __webpack_require__(83),
	    appConfig = __webpack_require__(3),
	    LayoutActions = __webpack_require__(84);

	module.exports = React.createClass({

	  displayName: "BodyLayout",

	  getInitialState: function getInitialState() {
	    return {
	      errors: GeneralErrorsStore.get("errors"),
	      ready: LayoutStore.get("ready"),
	      bannerShowing: LayoutStore.get("bannerShowing"),
	      leftColumnWidth: LayoutStore.get("leftColumnWidth")
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    GeneralErrorsStore.on("change:errors", this._onChange);
	    LayoutStore.on("change", this._onChange);
	    window.addEventListener("resize", this._resizeColumns);
	    this._resizeColumns();
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this._resizeColumns();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    GeneralErrorsStore.off("change:errors", this._onChange);
	    LayoutStore.off("change", this._onChange);
	    window.removeEventListener("resize", this._resizeColumns);
	  },

	  _onChange: function _onChange() {
	    this.setState(this.getInitialState());
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        layoutClasses = cx({
	      "hc-layout": true,
	      "banner-showing": this.state.bannerShowing
	    }),
	        body;

	    if (this.state.errors.length) {
	      body = React.createElement(GeneralErrorDisplay, { errors: this.state.errors });
	    } else if (this.state.ready) {
	      body = React.createElement(
	        "div",
	        { className: layoutClasses },
	        React.createElement(
	          "div",
	          { className: "hc-left-sidebar-col", ref: "left_column" },
	          React.createElement(LeftSidebar, null),
	          React.createElement("div", { className: "resize-handle", onMouseDown: this._onResizeStart })
	        ),
	        React.createElement(MainCol, { ref: "main_column" })
	      );
	    } else {
	      body = React.createElement(RandomLoadMessage, null);
	    }

	    return body;
	  },

	  _resizeColumns: function _resizeColumns() {
	    if (this.state.ready && !this.state.errors.length) {
	      this.refs.left_column.getDOMNode().style.width = this.state.leftColumnWidth + "px";
	      this.refs.main_column.getDOMNode().style.width = Math.floor(document.querySelector("body").clientWidth - this.state.leftColumnWidth) + "px";
	    }
	  },

	  _onResizeStart: function _onResizeStart(e) {
	    e.preventDefault();
	    this.beginX = e.pageX;
	    this.beginWidth = this.state.leftColumnWidth;
	    document.addEventListener("mouseup", this._onResizeEnd);
	    document.addEventListener("mousemove", this._onHandleDrag);
	  },

	  _onHandleDrag: function _onHandleDrag(e) {
	    var diff = e.pageX - this.beginX;
	    if (this.beginWidth + diff >= appConfig.column_width_limits.left.min && this.beginWidth + diff <= appConfig.column_width_limits.left.max) {
	      this.setState({
	        leftColumnWidth: this.beginWidth + diff
	      });
	    }
	  },

	  _onResizeEnd: function _onResizeEnd(e) {
	    e.preventDefault();
	    document.removeEventListener("mouseup", this._onResizeEnd);
	    document.removeEventListener("mousemove", this._onHandleDrag);
	    this._resizeColumns();
	    LayoutActions.saveLeftColumnWidth({
	      leftColumnWidth: this.state.leftColumnWidth
	    });
	  }
	});

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var PersistentStore = __webpack_require__(85);
	var AppDispatcher = __webpack_require__(1);
	var ClientPreferencesKeys = __webpack_require__(39);
	var AppConfig = __webpack_require__(3);

	var CLIENT_PREFERENCES_STORE_ID = "client-preferences";

	var ClientPreferencesStore = (function (PersistentStore) {
	  function ClientPreferencesStore() {
	    _classCallCheck(this, ClientPreferencesStore);

	    if (PersistentStore != null) {
	      PersistentStore.apply(this, arguments);
	    }
	  }

	  _inherits(ClientPreferencesStore, PersistentStore);

	  _prototypeProperties(ClientPreferencesStore, null, {
	    getStoreId: {
	      value: function getStoreId() {
	        return CLIENT_PREFERENCES_STORE_ID;
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register("save-client-preferences", function (prefs) {
	          _this.setIfNotEqual(prefs);
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    getDefaults: {
	      value: function getDefaults() {
	        var defaults = {};
	        defaults[ClientPreferencesKeys.HIDE_GIFS_BY_DEFAULT] = false;
	        defaults[ClientPreferencesKeys.REPLACE_TEXT_EMOTICONS] = true;
	        defaults[ClientPreferencesKeys.SHOW_UNREAD_DIVIDER] = true;
	        defaults[ClientPreferencesKeys.SHOW_CHAT_SIDEBAR] = true;
	        defaults[ClientPreferencesKeys.SHOW_GROUPCHAT_SIDEBAR] = true;
	        defaults[ClientPreferencesKeys.CHAT_ACTIVE_PANEL] = "files";
	        defaults[ClientPreferencesKeys.GROUPCHAT_ACTIVE_PANEL] = "roster";
	        defaults[ClientPreferencesKeys.THEME] = "clean";
	        defaults[ClientPreferencesKeys.DENSITY] = "normal";
	        defaults[ClientPreferencesKeys.SHOW_AVATARS] = false;
	        defaults[ClientPreferencesKeys.LEFT_COLUMN_WIDTH] = AppConfig.column_width_limits.left["default"];
	        defaults[ClientPreferencesKeys.RIGHT_COLUMN_WIDTH] = AppConfig.column_width_limits.right["default"];

	        return defaults;
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldHideGifsByDefault: {
	      value: function shouldHideGifsByDefault() {
	        return this.get(ClientPreferencesKeys.HIDE_GIFS_BY_DEFAULT);
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldReplaceTextEmoticons: {
	      value: function shouldReplaceTextEmoticons() {
	        return this.get(ClientPreferencesKeys.REPLACE_TEXT_EMOTICONS);
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldShowUnreadMessageDivider: {
	      value: function shouldShowUnreadMessageDivider() {
	        return this.get(ClientPreferencesKeys.SHOW_UNREAD_DIVIDER);
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldShowChatSidebar: {
	      value: function shouldShowChatSidebar() {
	        return this.get(ClientPreferencesKeys.SHOW_CHAT_SIDEBAR);
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldShowGroupChatSidebar: {
	      value: function shouldShowGroupChatSidebar() {
	        return this.get(ClientPreferencesKeys.SHOW_GROUPCHAT_SIDEBAR);
	      },
	      writable: true,
	      configurable: true
	    },
	    getChatActivePanel: {
	      value: function getChatActivePanel() {
	        return this.get(ClientPreferencesKeys.CHAT_ACTIVE_PANEL);
	      },
	      writable: true,
	      configurable: true
	    },
	    getGroupChatActivePanel: {
	      value: function getGroupChatActivePanel() {
	        return this.get(ClientPreferencesKeys.GROUPCHAT_ACTIVE_PANEL);
	      },
	      writable: true,
	      configurable: true
	    },
	    getLeftColumnWidth: {
	      value: function getLeftColumnWidth() {
	        return this.get(ClientPreferencesKeys.LEFT_COLUMN_WIDTH);
	      },
	      writable: true,
	      configurable: true
	    },
	    getRightColumnWidth: {
	      value: function getRightColumnWidth() {
	        return this.get(ClientPreferencesKeys.RIGHT_COLUMN_WIDTH);
	      },
	      writable: true,
	      configurable: true
	    },
	    getShowAvatars: {
	      value: function getShowAvatars() {
	        return this.get(ClientPreferencesKeys.SHOW_AVATARS);
	      },
	      writable: true,
	      configurable: true
	    },
	    getTheme: {
	      value: function getTheme() {
	        return this.get(ClientPreferencesKeys.THEME);
	      },
	      writable: true,
	      configurable: true
	    },
	    getThemeOptions: {
	      value: function getThemeOptions() {
	        return ["clean", "dark"];
	      },
	      writable: true,
	      configurable: true
	    },
	    getDensity: {
	      value: function getDensity() {
	        return this.get(ClientPreferencesKeys.DENSITY);
	      },
	      writable: true,
	      configurable: true
	    },
	    getDensityOptions: {
	      value: function getDensityOptions() {
	        return ["normal", "tighter"];
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return ClientPreferencesStore;
	})(PersistentStore);

	module.exports = new ClientPreferencesStore();

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  HIDE_GIFS_BY_DEFAULT: "hideGifsByDefault",
	  REPLACE_TEXT_EMOTICONS: "replaceTextEmoticons",
	  SHOW_UNREAD_DIVIDER: "showUnreadMessagesDivider",
	  SHOW_CHAT_SIDEBAR: "showChatSidebar",
	  SHOW_GROUPCHAT_SIDEBAR: "showGroupChatSidebar",
	  CHAT_ACTIVE_PANEL: "chatActivePanel",
	  GROUPCHAT_ACTIVE_PANEL: "groupChatActivePanel",
	  LEFT_COLUMN_WIDTH: "leftColumnWidth",
	  RIGHT_COLUMN_WIDTH: "rightColumnWidth",
	  THEME: "theme",
	  DENSITY: "density",
	  SHOW_AVATARS: "showAvatars"
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	* Helper for UI related tasks...
	* Some of these helpers use jQuery. These should not be used inside
	* components that are to be used in the native clients
	*/
	module.exports = {

	  resizePanelHeight: function resizePanelHeight(container, bottomAnchor, pad) {
	    var $this = $(container);
	    if (!$this.length) {
	      return;
	    }
	    $this.each(function (i, el) {
	      $(el).height($(window).height() - ($this.offset().top + $(bottomAnchor).height() + (pad || 0)));
	    });
	  },

	  resizeChatPanel: function resizeChatPanel() {
	    this.resizePanelHeight(".hc-chat-panel .message-list.visible", ".hc-chat-box", 10);
	  },

	  detectImgPosition: function detectImgPosition(elem, viewport) {
	    return elem.getBoundingClientRect().top >= viewport.getBoundingClientRect().top ? "above" : "below";
	  },

	  showSidebar: function showSidebar(chat_type, groupchat_show_sidebar, chat_show_sidebar) {
	    return chat_type === "groupchat" && groupchat_show_sidebar || chat_type === "chat" && chat_show_sidebar;
	  }

	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var MessageGroup = __webpack_require__(86),
	    EmptyState = __webpack_require__(87),
	    ui = __webpack_require__(40),
	    utils = __webpack_require__(4),
	    ChatWindowActions = __webpack_require__(33),
	    appConfig = __webpack_require__(3),
	    AppDispatcher = __webpack_require__(1),
	    PreferencesStore = __webpack_require__(21),
	    Promise = __webpack_require__(69).Promise,
	    ClientPreferencesKeys = __webpack_require__(39),
	    ClientPreferencesStore = __webpack_require__(38),
	    PreferencesKeys = __webpack_require__(68);

	var CLIENT_PREFS_CHANGE_KEYS = ["change:" + ClientPreferencesKeys.HIDE_GIFS_BY_DEFAULT, "change:" + ClientPreferencesKeys.SHOW_AVATARS];
	var PREFS_CHANGE_KEY = "change:" + PreferencesKeys.HIDE_PRESENCE_MESSAGES;
	module.exports = React.createClass({

	  displayName: "ChatWindowMessageList",

	  getInitialState: function getInitialState() {
	    return {
	      initialized: false,
	      use24hrTime: PreferencesStore.shouldUse24HrTime(),
	      shouldHideGifs: ClientPreferencesStore.shouldHideGifsByDefault(),
	      show_join_leave_messages: !PreferencesStore.getHidePresenceMessages(),
	      show_avatars: ClientPreferencesStore.getShowAvatars(),
	      has_scrolled_initial: false
	    };
	  },

	  componentWillMount: function componentWillMount() {
	    this._createDebounced();
	  },

	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (!nextProps.chat.fetching_ancient) {
	      if (this.refs.history_spinner) {
	        var spinner = this.refs.history_spinner.getDOMNode();
	        AJS.$(spinner).spinStop();
	        $(spinner).hide();
	      }
	    }
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (!this.is_scrolling && !this.props.chat.scroll_frozen && !this.props.chat.ancient_history_is_empty && !this.will_freeze) {
	      this.debouncedSetScroll();
	    } else if (this.props.chat.scroll_frozen || this.props.chat.ancient_history_is_empty || this.will_freeze) {
	      this.debouncedUnfreezeAbove();
	    }
	    this._shouldSpin();
	    this._loadImages();
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    this.props.chat.isScrolledToBottom = false;
	    this.should_interrupt_autoscroll = false;
	    this.scroll_is_bound = false;
	    this.is_animating = false;
	    this.will_freeze = false;
	    this.is_scrolling = false;
	    this.scrollbox = this.refs.scrollbox.getDOMNode();
	    this.$scrollbox = $(this.scrollbox);
	    AppDispatcher.register("remove-chat-state-message", this._removeChatStateMessage);
	    ClientPreferencesStore.on(CLIENT_PREFS_CHANGE_KEYS, this._clientPrefsChanged);
	    PreferencesStore.on(PREFS_CHANGE_KEY, this._hideShowPresenceMessages);
	    this._resize();
	    _.forEach(["click", "mousewheel", "DOMMouseScroll"], function (event) {
	      _this.scrollbox.addEventListener(event, _this.debouncedOnUserAction);
	    });
	    this._loadImages();

	    $(window).on("resize", this.debouncedResize);
	    this._shouldSpin();
	  },

	  _clientPrefsChanged: function _clientPrefsChanged() {
	    this.setState({
	      shouldHideGifs: ClientPreferencesStore.shouldHideGifsByDefault(),
	      show_avatars: ClientPreferencesStore.getShowAvatars()
	    });
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    var _this = this;

	    ChatWindowActions.setScrollValue({
	      scrollTop: this.getDOMNode().scrollTop,
	      should_scroll_to_bottom: this.props.chat.should_scroll_to_bottom,
	      isScrolledToBottom: this._isScrolledToBottom(),
	      jid: this.props.chat.jid
	    });
	    AppDispatcher.unregister("remove-chat-state-message", this._removeChatStateMessage);
	    ClientPreferencesStore.off(CLIENT_PREFS_CHANGE_KEYS, this._clientPrefsChanged);
	    PreferencesStore.off(PREFS_CHANGE_KEY, this._hideShowPresenceMessages);
	    ChatWindowActions.chatStoppedScroll(this.props.chat.jid);
	    _.forEach(["click", "mousewheel", "DOMMouseScroll"], function (event) {
	      _this.scrollbox.removeEventListener(event, _this.debouncedOnUserAction);
	    });
	    $(window).off("resize", this.debouncedResize);
	    this.debouncedUnfreezeAbove.cancel();
	    this.debouncedUnfreezeBelow.cancel();
	    this.debouncedFreezeAbove.cancel();
	    this.debouncedFreezeBelow.cancel();
	    this.debouncedResize.cancel();
	    this.debouncedSetScroll.cancel();
	    this.debouncedOnUserAction.cancel();
	    this.throttledSetScrollPosition.cancel();
	    this._unbindScroll();
	    clearTimeout(this.imageLoadTimeout);
	  },

	  _hideShowGifs: function _hideShowGifs() {
	    this.setState({
	      shouldHideGifs: ClientPreferencesStore.shouldHideGifsByDefault()
	    });
	  },

	  _hideShowPresenceMessages: function _hideShowPresenceMessages() {
	    this.setState({
	      show_join_leave_messages: !PreferencesStore.getHidePresenceMessages()
	    });
	  },

	  _resize: function _resize() {
	    var node = this.getDOMNode();
	    ui.resizePanelHeight(node, ".hc-chat-box", 15);
	    if (!this.is_scrolling && !this.is_animating) {
	      if (this.props.chat.should_scroll_to_bottom) {
	        this._scrollToWithoutTrigger();
	      } else {
	        this.debouncedSetScroll();
	        this._bindScroll();
	      }
	    }
	  },

	  render: function render() {

	    var cx = React.addons.classSet,
	        composingMessageClasses = cx({
	      hidden: !this.props.chat.is_composing,
	      "hc-composing-message": true,
	      "show-avatars": this.state.show_avatars
	    }),
	        panel;

	    if (_.isEmpty(this.props.chat.ordered_messages) && this.props.chat.fetching_ancient) {
	      panel = React.createElement(
	        "div",
	        { className: "spinwrap" },
	        React.createElement("div", { className: "hc-loading-spinner medium-spinner", ref: "loading_spinner" })
	      );
	    } else if (this.props.chat.has_no_message_history) {
	      panel = React.createElement(EmptyState, { chat: this.props.chat });
	    } else {
	      panel = React.createElement(
	        "div",
	        { className: "scroll-wrap" },
	        this.props.chat.ancient_history_is_empty ? React.createElement("div", { style: { display: "none" } }) : React.createElement("div", { className: "hc-chat-spinner medium-spinner", style: { display: "none" }, ref: "history_spinner" }),
	        this._generateNodeList(this.props.chat.ordered_messages),
	        React.createElement(
	          "div",
	          { className: composingMessageClasses, ref: "composing_msg" },
	          this.props.chat.name + " is typing..."
	        ),
	        React.createElement("br", { className: "clear" })
	      );
	    }

	    return React.createElement(
	      "div",
	      { className: "hc-chat-scrollbox message-list", ref: "scrollbox" },
	      panel
	    );
	  },

	  _generateNodeList: function _generateNodeList(message_groups) {
	    var use24hrTime = this.state.use24hrTime;

	    var dates = _.keys(message_groups).sort(function (a, b) {
	      return new Date(a) - new Date(b);
	    }),
	        that = this;

	    var date_group;
	    return _.map(dates, function (date) {
	      date_group = _(message_groups[date]).reject(function (msg) {
	        return !that.state.show_join_leave_messages && msg.is_presence_message;
	      });
	      return date_group.value().length ? React.createElement(
	        "div",
	        { className: "date-block", key: date.replace(/\s/g, "") },
	        React.createElement(
	          "div",
	          { className: "date-divider" },
	          React.createElement(
	            "span",
	            null,
	            date
	          )
	        ),
	        date_group.map(function (msg) {
	          return React.createElement(MessageGroup, { msg: msg,
	            key: msg.key,
	            shouldHideGifs: that.state.shouldHideGifs,
	            _setScroll: that._shouldSetScroll,
	            use24hrTime: use24hrTime,
	            show_unread_divider: that.props.prefs.showUnreadDivider,
	            last_viewed_mid: that.props.chat.last_viewed_mid,
	            token: that.props.token,
	            show_avatars: that.state.show_avatars });
	        }, this)
	      ) : false;
	    });
	  },

	  _checkScrollForHistoryFetch: function _checkScrollForHistoryFetch() {
	    if (!this.props.chat.ancient_history_is_empty && this.getDOMNode().style.overflowY != "hidden" && this.getDOMNode().scrollTop == 0) {
	      this.fetchHistory();
	      return true;
	    }
	  },

	  _checkScrollForScrolledToBottom: function _checkScrollForScrolledToBottom() {
	    this.props.chat.should_scroll_to_bottom = this._isScrolledToBottom();
	  },

	  _isScrolledToBottom: function _isScrolledToBottom() {
	    var node = this.getDOMNode();
	    return node.scrollHeight - node.scrollTop - node.offsetHeight <= 40;
	  },

	  _setScrollPosition: function _setScrollPosition() {
	    this._checkScrollForScrolledToBottom();
	    var node = this.getDOMNode(),
	        scrollVal = this.props.chat.should_scroll_to_bottom ? node.scrollHeight : node.scrollTop;
	    if (!this.is_animating && !this.props.chat.scroll_frozen && this.props.chat.has_scrolled_initial) {
	      ChatWindowActions.setScrollValue({
	        scrollTop: scrollVal,
	        isScrolledToBottom: this._isScrolledToBottom(),
	        oldestVisibleMessageMid: this._getOldestVisibleMessageMid(),
	        should_scroll_to_bottom: this.props.chat.should_scroll_to_bottom,
	        jid: this.props.chat.jid
	      });
	    }
	  },

	  _getOldestVisibleMessageMid: function _getOldestVisibleMessageMid() {
	    return $(".msg-line:visible:first").data("mid");
	  },

	  _loadImages: function _loadImages() {
	    var _this = this;

	    var node = this.getDOMNode(),
	        images = $(this.getDOMNode()).find(".hc-chat-msg img").not(".remoticon");
	    var unfreeze = function (pos) {
	      if (_this.props.chat.should_scroll_to_bottom) {
	        _this._scrollToWithoutTrigger();
	      }
	      pos === "above" ? _this.debouncedUnfreezeAbove() : _this.debouncedUnfreezeBelow();
	    };
	    _.forEach(images, function (img) {
	      if ((!img.complete || typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) && img.getAttribute("data-loaded") != "true") {
	        var pos = img.getBoundingClientRect().top >= node.getBoundingClientRect().bottom ? "below" : "above";
	        if (!_this.props.chat.scroll_frozen) {
	          if (_this.props.chat.should_scroll_to_bottom) {
	            _this._scrollToWithoutTrigger();
	          } else {
	            pos === "above" ? _this.debouncedFreezeAbove() : _this.debouncedFreezeBelow();
	          }
	          $(img).one("load error", function (e) {
	            e.target.setAttribute("data-loaded", "true");
	            unfreeze(pos);
	          });
	          clearTimeout(_this.imageLoadTimeout);
	          _this.imageLoadTimeout = setTimeout((function () {
	            unfreeze(pos);
	          }).bind(_this), 2000);
	        }
	      }
	    });
	  },

	  _maintainScrollPosition: function _maintainScrollPosition(action, position, should_scroll_to_bottom) {
	    if (!this.isMounted()) {
	      return;
	    } else if (should_scroll_to_bottom && action == "unfreeze") {
	      this._unbindScroll();
	      $(this.getDOMNode()).find(".scroll-wrap").css({
	        position: "relative",
	        bottom: "",
	        top: ""
	      }).parent(".message-list").css({
	        overflowY: "auto"
	      });
	      this._scrollToWithoutTrigger(this.getDOMNode().scrollHeight);
	      this._bindScroll();
	      this.props.chat.scroll_frozen = false;
	      return;
	    }
	    var node = this.getDOMNode();
	    this._unbindScroll();
	    var top,
	        scrollWrap = $(node).find(".scroll-wrap")[0],
	        bottom = scrollWrap.getBoundingClientRect().bottom - node.getBoundingClientRect().bottom;
	    switch (action) {
	      case "freeze":
	        if (!this.props.chat.scroll_frozen) {
	          this.$scrollbox.off("scrollstart");
	          this.$scrollbox.off("scrollstop");
	          this.props.chat.scroll_frozen = true;
	          top = scrollWrap.getBoundingClientRect().top - node.getBoundingClientRect().top;
	          switch (position) {
	            case "above":
	              $(scrollWrap).css({
	                position: "absolute",
	                bottom: -bottom,
	                top: ""
	              }).parent(".message-list").css({
	                overflowY: "hidden"
	              });
	              break;
	            case "below":
	              $(scrollWrap).css({
	                position: "absolute",
	                top: top,
	                bottom: ""
	              }).parent(".message-list").css({
	                overflowY: "hidden"
	              });
	              break;
	          }
	        }
	        break;
	      case "unfreeze":
	        if (this.props.chat.scroll_frozen && !this.props.chat.fetching_ancient) {
	          this.props.chat.scroll_frozen = false;
	          top = scrollWrap.getBoundingClientRect().top - node.getBoundingClientRect().top;
	          $(scrollWrap).css({
	            position: "relative",
	            bottom: "",
	            top: ""
	          }).parent(".message-list").css({
	            overflowY: "auto"
	          });
	          this._checkScrollForScrolledToBottom();
	          this._scrollToWithoutTrigger(-top);
	          this.props.chat.scrollTop = -top;
	          this._bindScroll();
	        }
	        break;
	    }
	  },

	  _createDebounced: function _createDebounced() {
	    function unfreezeAbove() {
	      this._maintainScrollPosition("unfreeze", "above", this.props.chat.should_scroll_to_bottom);
	    }
	    function unfreezeBelow() {
	      this._maintainScrollPosition("unfreeze", "below", this.props.chat.should_scroll_to_bottom);
	    }
	    function freezeAbove() {
	      this._maintainScrollPosition("freeze", "above", this.props.chat.should_scroll_to_bottom);
	    }
	    function freezeBelow() {
	      this._maintainScrollPosition("freeze", "below", this.props.chat.should_scroll_to_bottom);
	    }
	    this.debouncedUnfreezeAbove = _.debounce(unfreezeAbove, 600, { leading: false, trailing: true });
	    this.debouncedUnfreezeBelow = _.debounce(unfreezeBelow, 600, { leading: false, trailing: true });
	    this.debouncedFreezeAbove = _.debounce(freezeAbove, 500, { leading: true, trailing: false });
	    this.debouncedFreezeBelow = _.debounce(freezeBelow, 500, { leading: true, trailing: false });
	    this.debouncedResize = _.debounce(this._resize, 200, { leading: false, trailing: true });
	    this.debouncedSetScroll = _.debounce(this._setScroll, 300, { leading: true, trailing: false });
	    this.throttledSetScrollPosition = _.throttle(this._setScrollPosition, 100, { leading: false, trailing: true });
	    this.debouncedOnUserAction = _.throttle(this._onUserAction, 200, { leading: true, trailing: true });
	    this.initialized = true;
	  },

	  _shouldSetScroll: function _shouldSetScroll() {
	    if (!this.is_scrolling && !this.props.chat.scroll_frozen && !this.props.chat.ancient_history_is_empty && !this.will_freeze) {
	      this.debouncedSetScroll();
	    }
	  },

	  _setScroll: function _setScroll() {
	    var node = this.getDOMNode();
	    if (!this.is_scrolling) {
	      if (!this.props.chat.scroll_frozen && !this.is_animating) {
	        if (this.props.chat.should_scroll_to_bottom) {
	          if (this.props.chat.has_scrolled_initial) {
	            this._animateScroll();
	          } else {
	            this._scrollToWithoutTrigger();
	            if (!this.props.chat.has_scrolled_initial) {
	              this.props.chat.has_scrolled_initial = true;
	              this._setScrollPosition();
	            }
	          }
	        } else {
	          this._bindScroll();
	          if (!this.props.chat.has_scrolled_initial) {
	            this.props.chat.has_scrolled_initial = true;
	          }
	          node.scrollTop = this.props.chat.scrollTop;
	          this._setScrollPosition();
	        }
	      }
	    }
	  },

	  _animateScroll: function _animateScroll(val) {
	    var _this = this;

	    var node = this.getDOMNode();
	    if (val || this.scrollbox.scrollHeight - node.offsetHeight > 2) {
	      var promise = new Promise(function (resolve, reject) {
	        _this._unbindScroll();
	        var duration = appConfig.chat_scroll_duration,
	            scrollTo = (val || _this.scrollbox.scrollHeight) - node.offsetHeight;
	        _this.interruptAutoscroll();
	        var originalScollTop = node.scrollTop,
	            delta = scrollTo - originalScollTop,
	            count = 0,
	            start,
	            incrementValue;
	        _this.is_animating = true;
	        var step = function (timestamp) {
	          if (!start) start = timestamp;
	          var progress = timestamp - start;
	          if (progress < duration && !_this.should_interrupt_autoscroll) {
	            count = count + 1;
	            //Ease-in-out trig function here
	            incrementValue = Math.cos(Math.PI * progress / duration - Math.PI) + 1;
	            node.scrollTop = originalScollTop + delta / 2 * incrementValue;
	            requestAnimationFrame(step);
	          } else {
	            if (!_this.should_interrupt_autoscroll) {
	              _this._scrollToWithoutTrigger();
	            }
	            _this.should_interrupt_autoscroll = false;
	            node.scrollTop = node.scrollHeight;
	            _this.props.chat.should_scroll_to_bottom = true;
	            _this.is_animating = false;
	            resolve();
	          }
	        };
	        requestAnimationFrame(step);
	      });
	      promise.then(function () {
	        _.debounce(_this._bindScroll, 300, { leading: false, trailing: true });
	      });
	    }
	  },

	  _removeChatStateMessage: function _removeChatStateMessage(data) {
	    if (this.props.chat.should_scroll_to_bottom && this.props.chat.jid === data.jid && this.props.chat.is_composing) {
	      var composing_height = this.getDOMNode().getBoundingClientRect().bottom - this.refs.composing_msg.getDOMNode().getBoundingClientRect().top;
	      if (composing_height) this._animateScroll(this.getDOMNode().scrollHeight - composing_height);
	    }
	  },

	  _scrollToWithoutTrigger: function _scrollToWithoutTrigger(val) {
	    var _this = this;

	    if (!this.is_scrolling) {
	      var promise = new Promise(function (resolve) {
	        _this._unbindScroll();
	        var node = _this.getDOMNode();
	        $(node).scrollTop(val || node.scrollHeight);
	        _this.props.chat.scrollTop = node.scrollTop;
	        _this.props.chat.should_scroll_to_bottom = true;
	        _this.props.chat.isScrolledToBottom = true;
	        _this.$scrollbox.bind("scroll.resolver", function () {
	          resolve();
	        });
	      });
	      promise.then(function () {
	        _this.$scrollbox.unbind("scroll.resolver");
	        _.debounce(_this._bindScroll, 300, { leading: false, trailing: true });
	      });
	    }
	  },

	  interruptAutoscroll: function interruptAutoscroll() {
	    if (this.is_animating) this.should_interrupt_autoscroll = true;
	  },

	  _onUserAction: function _onUserAction() {
	    this.should_interrupt_autoscroll = true;
	    this._bindScroll();
	  },

	  _shouldSpin: function _shouldSpin() {
	    if (this.refs.loading_spinner && this.props.initialized) {
	      var spinner = this.refs.loading_spinner.getDOMNode();
	      AJS.$(spinner).spin("medium", { zIndex: 100 });
	    }
	  },

	  fetchHistory: function fetchHistory() {
	    var _this = this;

	    if (!this.props.chat.ancient_history_is_empty) {
	      this._unbindScroll();
	      var spinner = this.refs.history_spinner.getDOMNode();
	      this.props.chat.should_scroll_to_bottom = false;
	      this.props.chat.scrollTop = 0;
	      this.should_interrupt_autoscroll = true;
	      this.will_freeze = true;
	      ChatWindowActions.requestAncientHistory({
	        jid: this.props.chat.jid
	      });
	      $(spinner).slideDown(200, function () {
	        if (!_this.props.chat.ancient_history_is_empty) {
	          _this.will_freeze = false;
	          _this.debouncedFreezeAbove();
	          AJS.$(spinner).spin("medium", { zIndex: 100 });
	        }
	      });
	    }
	  },

	  _chatIsScrolling: function _chatIsScrolling() {
	    ChatWindowActions.chatStartedScroll(this.props.chat.jid);
	    this.is_scrolling = true;
	  },

	  _scrollStop: function _scrollStop() {
	    this.should_interrupt_autoscroll = false;
	    this.is_animating = false;
	    this.is_scrolling = false;
	    ChatWindowActions.chatStoppedScroll(this.props.chat.jid);
	    this._checkScrollForHistoryFetch();
	    this._checkScrollForScrolledToBottom();
	    this._setScrollPosition();
	  },

	  _unbindScroll: function _unbindScroll() {
	    this.$scrollbox.unbind("scroll.resolver");
	    if (this.scroll_is_bound) {
	      this.$scrollbox.off();
	      this.scroll_is_bound = false;
	    }
	  },

	  _bindScroll: function _bindScroll() {
	    if (!this.scroll_is_bound) {
	      this.$scrollbox.on("scrollstart", this._chatIsScrolling);
	      this.$scrollbox.on("scrollstop", this._scrollStop);
	      this.$scrollbox.on("scroll", this.throttledSetScrollPosition);
	      this.scroll_is_bound = true;
	    }
	  }
	});

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4),
	    moment = __webpack_require__(64),
	    Store = __webpack_require__(43),
	    PreferencesStore = __webpack_require__(21),
	    ClientPreferencesStore = __webpack_require__(38),
	    AppDispatcher = __webpack_require__(1),
	    HCApiDispatcher = __webpack_require__(8),
	    AnalyticsDispatcher = __webpack_require__(7),
	    appConfig = __webpack_require__(3),
	    Promise = __webpack_require__(69).Promise;

	var ChatWindowStore = (function (Store) {
	  function ChatWindowStore() {
	    _classCallCheck(this, ChatWindowStore);

	    this.local = {
	      should_queue_changes: {},
	      queued_messages: {},
	      initial_join_presences: {},
	      echoed_chats: {},
	      replacement_messages: {}
	    };

	    this.defaults = {
	      chat: {
	        name: "",
	        jid: "",
	        messages: {},
	        ordered_messages: {},
	        oldest_timestamp: "",
	        newest_timestamp: Utils.format_time_for_history(moment().unix()),
	        oldest_mid: "",
	        newest_mid: "",
	        last_viewed_mid: "",
	        scrollTop: "",
	        isScrolledToBottom: true,
	        active: false,
	        fully_initialized: false,
	        fetching_recent: false,
	        fetching_ancient: false,
	        ancient_history_is_empty: false,
	        has_no_message_history: false,
	        should_scroll_to_bottom: true,
	        ancient_msgs: {},
	        recent_msgs: {},
	        is_composing: false,
	        last_active: false,
	        has_been_cleared: false
	      }
	    };

	    this.data = {
	      current_user: {},
	      chats: {},
	      active_chat: false,
	      mentionRegex: null,
	      emoticons: {},
	      preferences: {},
	      initialized: false,
	      chat_show_sidebar: ClientPreferencesStore.shouldShowChatSidebar(),
	      groupchat_show_sidebar: ClientPreferencesStore.shouldShowGroupChatSidebar()
	    };

	    this.registerListeners();
	  }

	  _inherits(ChatWindowStore, Store);

	  _prototypeProperties(ChatWindowStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.registerOnce({
	          "hc-init": function () {
	            _this.set("active_chat", PreferencesStore.getChatToFocus());
	          }
	        });
	        AppDispatcher.register({
	          "updated:emoticons": function (emoticons) {
	            _this.updateEmoticons(emoticons);
	          },
	          "updated:current_user": function (user) {
	            _this.data.current_user = user;
	          },
	          "updated:mentionRegex": function (regex) {
	            _this.data.mentionRegex = regex;
	          },
	          "updated:activeRooms": function (rooms) {
	            _this.updateRooms(rooms);
	          },
	          "updated:newMessages": function (messages) {
	            _this.updateChatMessages(messages);
	          },
	          "updated:preferences": function (prefs) {
	            _this.set({
	              active_chat: prefs.chatToFocus,
	              preferences: prefs
	            });
	          },
	          "before:select-room": function (data) {
	            if (!data.jid != _this.data.active_chat && _this.data.chats[_this.data.active_chat]) {
	              _this.flushQueue(_this.data.active_chat);
	              _this.updateLastViewedMid(_this.data.active_chat);
	              _this.data.chats[_this.data.active_chat].last_active = new Date();
	            }
	          },
	          "select-room": function (data) {
	            if (data.jid != "lobby" && !/^lobby@/.test(data.jid)) {
	              _this.handleRoomSelect(data.jid);
	            }
	          },
	          "send-message": function (data) {
	            _this.data.chats[data.jid].should_scroll_to_bottom = true;
	            if (!_this.data.chats[data.jid].fetching_ancient) {
	              _this.flushQueue(data.jid);
	            }
	          },
	          "resend-message": function (msg) {
	            msg.status = "unconfirmed";
	            _this.updateChats(msg.room);
	            _this.scheduleConfirmationFailed(msg);
	          },
	          "clear-messages": function (data) {
	            if (_this.data.chats[data.jid]) {
	              _this.data.chats[data.jid].messages = _this.data.chats[data.jid].ordered_messages = {};
	              _this.data.chats[data.jid].has_been_cleared = true;
	              _this.updateChats(data.jid);
	            }
	          },
	          "app-state-ready": function () {
	            if (_this.data.active_chat && _this.data.chats[_this.data.active_chat] && Utils.jid.is_private_chat(_this.data.active_chat)) {
	              _this.fetchXMPPHistory(_this.data.active_chat);
	            }
	            _this.set("initialized", true);
	          },
	          "initial-join-presence-sent": function (data) {
	            if (_this.data.chats[data.jid] && data.with_history) {
	              _this.initialJoinWithHistory(data.jid);
	              _this.handleRoomSelect(data.jid);
	            }
	          },
	          "room-joined": function (data) {
	            var jid = Utils.jid.bare_jid(data.from);
	            if (!_this.local.initial_join_presences[jid]) {
	              _this.local.initial_join_presences[jid] = 0;
	            }
	            _this.local.initial_join_presences[jid]++;
	            if (_this.local.initial_join_presences[jid] !== 0 && _this.local.initial_join_presences[jid] % 2 === 0) {
	              if (_this.data.chats[jid] && _this.data.chats[jid].fetching_ancient) {
	                _this.handleAncientHistoryLoaded({ jid: jid });
	              }
	              _this.local.initial_join_presences[jid] = 0;
	              AppDispatcher.dispatch("show-join-messages", { jid: jid });
	            }
	          },
	          "open-room": function (data) {
	            _this.data.active_chat = data.jid;
	            _this.handleRoomSelect(_this.data.active_chat);
	          },
	          "set-scroll-value": function (data) {
	            _.assign(_this.data.chats[data.jid], {
	              scrollTop: data.scrollTop,
	              isScrolledToBottom: data.isScrolledToBottom,
	              should_scroll_to_bottom: data.should_scroll_to_bottom
	            });
	          },
	          "chat-is-scrolling": function (data) {
	            _this.local.should_queue_changes[data.jid] = data.scrolling;
	            if (!data.scrolling) {
	              _this.flushQueue(data.jid);
	            }
	          },
	          "requesting-ancient-history": function (data) {
	            _this.fetchXMPPHistory(data.jid);
	          },
	          "history-loaded": function (data) {
	            _this.handleAncientHistoryLoaded(data);
	          },
	          "reconnect-success": function () {
	            AppDispatcher.dispatch("hide-join-messages");
	            _.forEach(_.filter(_this.data.chats, "fully_initialized"), function (room) {
	              _this.fetchAPIHistory(room.jid);
	            });
	          },
	          "show-empty-state": function (data) {
	            _this.data.chats[data.jid].ancient_history_is_empty = true;
	            _this.set("chats", _this.data.chats);
	          },
	          "status-message-received": function (data) {
	            _this.handleUserStateMessage(data);
	          },
	          "save-client-preferences": function () {
	            _this.set({
	              chat_show_sidebar: ClientPreferencesStore.shouldShowChatSidebar(),
	              groupchat_show_sidebar: ClientPreferencesStore.shouldShowGroupChatSidebar()
	            });
	          },
	          "replacement-message-received": function (data) {
	            _this.local.replacement_messages[data.jid] ? _this.local.replacement_messages[data.jid].push(data) : _this.local.replacement_messages[data.jid] = [data];
	          }
	        });

	        HCApiDispatcher.register({
	          "before:API:fetched-recent-history": function (data) {
	            if (_this.data.chats[data.jid]) {
	              _this.data.chats[data.jid].fetching_recent = false;
	              // Blow away all messages if the fetched messages begin with a mid that we haven't received yet
	              if (data.mid && _this.data.chats[data.jid].newest_mid !== data.mid) {
	                _this.data.chats[data.jid].ordered_messages = {};
	              }
	            }
	          },
	          "API:fetched-recent-history": function (data) {
	            _this.data.chats[data.jid].populated_recent = true;
	            _this.checkIfEmpty(data.jid);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    updateEmoticons: {
	      value: function updateEmoticons(emoticons) {
	        Utils.emoticons.path_prefix = emoticons.path_prefix;
	        this.data.emoticons = emoticons;
	      },
	      writable: true,
	      configurable: true
	    },
	    updateRooms: {
	      value: function updateRooms(rooms) {
	        var _this = this;

	        this.data.rooms = rooms;
	        var hasChanged,
	            jids = _.keys(rooms),
	            deleted = _.difference(_.keys(this.data.rooms), jids);
	        if (deleted.length) {
	          this.data.chats = _.omit(this.data.chats, deleted);
	          hasChanged = true;
	        } else {
	          _.forEach(jids, function (jid) {
	            if (_this.data.chats[jid]) {
	              // Update Room Name
	              if (_this.data.chats[jid].name !== rooms[jid].name) {
	                _this.data.chats[jid].name = rooms[jid].name;
	                hasChanged = true;
	              }
	            } else {
	              _this.data.chats[jid] = _.assign({}, _.cloneDeep(_this.defaults.chat), {
	                name: rooms[jid].name,
	                jid: jid,
	                active: jid == _this.data.active_chat,
	                last_active: new Date()
	              });
	              hasChanged = true;
	            }
	          });
	        }
	        if (hasChanged) this.set("chats", this.data.chats);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomSelect: {
	      value: function handleRoomSelect(jid) {
	        if (!this.data.chats[jid].fully_initialized) {
	          this.fetchXMPPHistory(jid);
	        }
	        this.updateMessageBounds(this.data.active_chat);
	        this.data.active_chat = jid;
	        if (!this.data.chats[jid].has_been_cleared) {
	          this.checkIfEmpty(jid);
	        }
	        this.updateChats(jid);
	      },
	      writable: true,
	      configurable: true
	    },
	    updateMessageBounds: {
	      value: function updateMessageBounds(jid) {
	        var chat = this.data.chats[jid];
	        if (_.isEmpty(this.data.chats[jid].messages)) {
	          return;
	        }
	        var sorted = this.sortAndRejectPresenceMessages(this.data.chats[jid].messages);
	        if (sorted.length) {
	          var first = _.first(sorted),
	              last = _.last(sorted);
	          _.assign(chat, {
	            newest_timestamp: Utils.format_time_for_history(last.time),
	            newest_mid: last.mid.split("-link")[0],
	            oldest_timestamp: Utils.format_time_for_history(first.time),
	            oldest_mid: first.mid.split("-link")[0]
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getMessageCountToPreserve: {
	      value: function getMessageCountToPreserve(jid, sortedMessages) {
	        var chat = this.getChat(jid);
	        var unreadMessagesCount = chat.unreadCount || 0;
	        if (chat.isScrolledToBottom) {
	          return appConfig.chat_room_trim_buffer + unreadMessagesCount;
	        } else {
	          var numberToPreserve = _.last(sortedMessages, function (message) {
	            return message.mid !== chat.oldestVisibleMessageMid;
	          }).length + 1;
	          return appConfig.chat_room_trim_buffer + unreadMessagesCount + numberToPreserve;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    trimMessages: {
	      value: function trimMessages(jid) {
	        var chat = this.getChat(jid);
	        var messages = chat.messages;
	        if (this.chatIsBackgrounded(jid)) {
	          var sortedMessages = this.sortAndRejectPresenceMessages(messages);
	          var messageCount = sortedMessages.length;
	          var numMessagesToPreserve = this.getMessageCountToPreserve(jid, sortedMessages);

	          if (messageCount > numMessagesToPreserve) {
	            var numMessagesToDelete = messageCount - numMessagesToPreserve;
	            var messageMidsToDelete = _.map(_.first(sortedMessages, numMessagesToDelete), function (message) {
	              return message.mid;
	            });
	            messages = _.omit(messages, messageMidsToDelete);
	          }
	        }

	        return messages;
	      },
	      writable: true,
	      configurable: true
	    },
	    chatIsBackgrounded: {
	      value: function chatIsBackgrounded(jid) {
	        var chat = this.getChat(jid);
	        var ninetyMinutesAgo = moment().subtract(appConfig.chat_room_idle_timeout_minutes, "minutes");
	        return chat && chat.jid !== this.data.active_chat && chat.last_active !== false && moment(chat.last_active).isBefore(ninetyMinutesAgo);
	      },
	      writable: true,
	      configurable: true
	    },
	    getChat: {
	      value: function getChat(jid) {
	        return this.data.chats[jid];
	      },
	      writable: true,
	      configurable: true
	    },
	    updateLastViewedMid: {
	      value: function updateLastViewedMid(jid) {
	        this.data.chats[jid].last_viewed_mid = this.data.chats[jid].newest_mid;
	      },
	      writable: true,
	      configurable: true
	    },
	    updateChatMessages: {
	      value: function updateChatMessages(messages) {
	        var _this = this;

	        var chat;
	        _.forEach(messages, function (messages, jid) {
	          chat = _this.data.chats[jid];
	          if (chat) {
	            var chat_is_backgrounded_and_empty = jid != _this.data.active_chat && _.isEmpty(chat.messages);
	            if (chat.fetching_ancient || chat_is_backgrounded_and_empty) {
	              _.merge(chat.ancient_msgs, messages);
	              if (chat_is_backgrounded_and_empty && !HC.isEmbeddedComponent) _this.fetchXMPPHistory(jid);
	            }
	            _this.addMessages(jid, _.indexBy(messages, "mid"));
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    scheduleConfirmationFailed: {
	      value: function scheduleConfirmationFailed(message) {
	        var _this = this;

	        if (message.status !== "unconfirmed") {
	          return;
	        }message.timer = setTimeout(function () {
	          var msg = _this.data.chats[message.room].messages[message.mid];
	          if (msg) {
	            msg.status = "failed";
	            _this.updateChats(msg.room);
	          }
	        }, appConfig.message_confirmation_timeout);
	      },
	      writable: true,
	      configurable: true
	    },
	    cancelConfirmationFailed: {
	      value: function cancelConfirmationFailed(timerid) {
	        clearTimeout(timerid);
	      },
	      writable: true,
	      configurable: true
	    },
	    addMessages: {
	      value: function addMessages(jid, messages) {
	        if (!_.isEmpty(messages)) {
	          if (this.local.should_queue_changes[jid]) {
	            if (!this.local.queued_messages[jid]) this.local.queued_messages[jid] = {};
	            _.merge(this.local.queued_messages[jid], messages);
	          } else {
	            _.forEach(messages, this.scheduleConfirmationFailed.bind(this));
	            this.filterMessages(jid, messages);
	            _.merge(this.data.chats[jid].messages, messages);
	            this.data.chats[jid].messages = this.trimMessages(jid);
	            this.data.chats[jid].messages = this.replaceMessageContent(jid);
	            this.data.chats[jid].ordered_messages = this.sortMergeAndGroupMessages(this.data.chats[jid].messages);
	            this.updateMessageBounds(jid);
	            if (this.data.chats[jid].fully_initialized) this.updateChats(jid);
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    flushQueue: {
	      value: function flushQueue(jid) {
	        this.local.should_queue_changes[jid] = false;
	        this.addMessages(jid, this.local.queued_messages[jid]);
	        this.local.queued_messages[jid] = {};
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldGroupMessages: {
	      value: function shouldGroupMessages(mostRecent, message) {
	        var nonGroupingTypes = ["notification", "video", "twitter_user", "twitter_status", "file", "info"];
	        return mostRecent.sender === message.sender && message.time - mostRecent.time <= 300 && mostRecent.color === message.color && ! ~nonGroupingTypes.indexOf(message.type) && ! ~nonGroupingTypes.indexOf(mostRecent.type);
	      },
	      writable: true,
	      configurable: true
	    },
	    updateChats: {
	      value: function updateChats(jid) {
	        if (this.data.chats[jid]) {
	          this.set("chats", this.data.chats);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleUserStateMessage: {
	      value: function handleUserStateMessage(data) {
	        var _this = this;

	        var jid = Utils.jid.bare_jid(data.message.from),
	            chat = this.data.chats[jid],
	            user = Utils.jid.bare_jid(Utils.dot(data, "message.delay.from_jid")) || Utils.jid.bare_jid(Utils.dot(data, "message.from"));
	        if (chat && user) {
	          switch (data.type) {
	            case "active":
	              if (user != this.data.current_user.user_jid) {
	                this.removeChatStateMessage(jid);
	                clearTimeout(this.local.composing_timeout);
	              }
	              break;
	            case "composing":
	              if (user != this.data.current_user.user_jid) {
	                var last_received = chat.messages[chat.newest_mid];
	                if (!last_received || data.message.ts - last_received.ts > 1) {
	                  //don't show composing message if it's been received less than a second from the last message
	                  this.data.chats[jid].is_composing = true;
	                  if (jid === this.data.active_chat) {
	                    clearTimeout(this.local.composing_timeout);
	                    this.local.composing_timeout = setTimeout(function () {
	                      _this.removeChatStateMessage(jid);
	                    }, appConfig.composing_message_linger_timeout);
	                  }
	                }
	              }
	              break;
	            default:
	              break;
	          }
	          this.updateChats(jid);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    fetchAPIHistory: {
	      value: function fetchAPIHistory(jid) {
	        if (this.data.chats[jid]) {
	          this.data.chats[jid].fetching = true;
	          HCApiDispatcher.dispatch("API:fetch-recent-history", {
	            params: {
	              "not-before": this.data.chats[jid].newest_mid || "",
	              "max-results": 75
	            },
	            path: {
	              identifier: /@chat/.test(jid) ? jid.split("@")[0].split("_")[1] : this.data.chats[jid].name,
	              type: /@chat/.test(jid) ? "user" : "room"
	            },
	            jid: jid
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    initialJoinWithHistory: {
	      value: function initialJoinWithHistory(jid) {
	        this.data.chats[jid].fetching_ancient = true;
	        this.local.should_queue_changes[jid] = true;
	      },
	      writable: true,
	      configurable: true
	    },
	    fetchXMPPHistory: {
	      value: function fetchXMPPHistory(jid) {
	        AnalyticsDispatcher.dispatch("analytics-request-history", { jid: jid });
	        if (!this.data.chats[jid].fetching_ancient) {
	          this.data.chats[jid].fetching_ancient = true;
	          this.local.should_queue_changes[jid] = true;
	          AppDispatcher.dispatch("request-ancient-history", {
	            jid: jid,
	            oldest: this.data.chats[jid].oldest_timestamp
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleAncientHistoryLoaded: {
	      value: function handleAncientHistoryLoaded(data) {
	        var chat = this.data.chats[data.jid];
	        chat.fetching_ancient = false;
	        var queueSize = 0;
	        this.flushQueue(data.jid);
	        if (_.isEmpty(this.data.chats[data.jid].ancient_msgs)) {
	          this.data.chats[data.jid].ancient_history_is_empty = true;
	        } else {
	          queueSize = Object.keys(this.data.chats[data.jid].ancient_msgs).length;
	          this.data.chats[data.jid].ancient_msgs = {};
	        }
	        if (!this.data.chats[data.jid].fully_initialized) {
	          this.data.chats[data.jid].fully_initialized = true;
	          AppDispatcher.dispatch("chat-fully-initialized");
	        }
	        this.checkIfEmpty(data.jid);
	        this.updateChats(data.jid);
	        AnalyticsDispatcher.dispatch("analytics-history-loaded", { jid: data.jid, size: queueSize });
	      },
	      writable: true,
	      configurable: true
	    },
	    checkIfEmpty: {
	      value: function checkIfEmpty(jid) {
	        var chat = this.data.chats[jid];
	        if (chat && !chat.fetching_ancient && !chat.fetching_recent && _.isEmpty(chat.messages) && _.isEmpty(chat.ordered_messages) && (!this.local.queued_messages[jid] || _.isEmpty(this.local.queued_messages[jid]))) {
	          chat.has_no_message_history = true;
	          if (!chat.fully_initialized) {
	            chat.fully_initialized = true;
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    filterMessages: {
	      value: function filterMessages(jid, messages) {
	        var _this = this;

	        _.forEach(messages, function (msg) {
	          if (_this.data.chats[jid].messages[msg.id]) {
	            // messages is echo of previously sent message
	            _this._markEchoedMessage(jid, msg);
	            delete _this.data.chats[jid].messages[msg.id];
	          } else if (appConfig.slash_replacement_regex.test(msg.body) && msg.id && !msg.is_history_message) {
	            var replacement = _.findWhere(_this.local.replacement_messages[jid], { mid: msg.mid });
	            _.pull(_this.local.replacement_messages[jid], replacement); // delete echoed replacement message
	            delete messages[msg.mid];
	          } else if (messages[msg.id]) {
	            // echo exists in current messages set
	            _this._markEchoedMessage(jid, msg);
	            delete messages[msg.id];
	          } else if (_this._wasMessagesAlreadyEchoed(jid, msg)) {
	            // echo has already been received
	            _this._markEchoedMessage(jid, msg);
	            delete messages[msg.mid];
	          } else if (_this.data.chats[jid].jid === Utils.jid.bare_jid(msg.from)) {
	            _this.data.chats[jid].is_composing = false;
	            clearTimeout(_this.local.composing_timeout);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    _wasMessagesAlreadyEchoed: {
	      value: function _wasMessagesAlreadyEchoed(jid, msg) {
	        return this.local.echoed_chats[jid] && this.local.echoed_chats[jid].messages[msg.id];
	      },
	      writable: true,
	      configurable: true
	    },
	    _markEchoedMessage: {
	      value: function _markEchoedMessage(jid, msg) {
	        this.cancelConfirmationFailed(msg.timer);
	        msg.is_echo = true;
	        if (!this.local.echoed_chats[jid]) {
	          this.local.echoed_chats[jid] = { messages: {} };
	        }
	        this.local.echoed_chats[jid].messages[msg.id] = msg;
	      },
	      writable: true,
	      configurable: true
	    },
	    sortMessages: {
	      value: function sortMessages(messages) {
	        var person;
	        return _.sortBy(messages, function (msg) {
	          return msg.time;
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    sortAndRejectPresenceMessages: {
	      value: function sortAndRejectPresenceMessages(messages) {
	        return _(messages).reject(function (obj) {
	          return obj.is_presence_message;
	        }).sortBy(function (msg) {
	          return parseFloat(msg.time);
	        }).value();
	      },
	      writable: true,
	      configurable: true
	    },
	    sortMergeAndGroupMessages: {
	      value: function sortMergeAndGroupMessages(unsortedMessages) {
	        var _this = this;

	        var grouped = _.groupBy(this.sortMessages(unsortedMessages), function (msg) {
	          return Utils.format_time_for_separator(msg.time);
	        });
	        return _.forOwn(grouped, function (messages, date) {
	          var i = 0;
	          grouped[date] = _.reduce(_this.sortMessages(messages), function (result, message) {
	            if (i > 0 && _this.shouldGroupMessages(result[i - 1], message)) {
	              result[i - 1].messages.push(message);
	              return result;
	            }
	            result[i] = _.assign({
	              key: message.mid,
	              messages: [message]
	            }, message);
	            i++;
	            return result;
	          }, [{ messages: [] }]);
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    removeChatStateMessage: {
	      value: function removeChatStateMessage(jid) {
	        if (jid === this.data.active_chat) {
	          this.smoothRemoveChatStateMessage(jid);
	        } else {
	          this.data.chats[jid].is_composing = false;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    smoothRemoveChatStateMessage: {
	      value: function smoothRemoveChatStateMessage(jid) {
	        var _this = this;

	        this.local.should_queue_changes[jid] = true;
	        var promise = new Promise(function (res) {
	          setTimeout(function () {
	            res(jid);
	          }, appConfig.chat_scroll_duration);
	          AppDispatcher.dispatch("remove-chat-state-message", { jid: jid });
	        });
	        promise.then(function (jid) {
	          _this.data.chats[jid].is_composing = false;
	          _this.flushQueue(jid);
	          _this.updateChats(jid);
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    replaceMessageContent: {
	      value: function replaceMessageContent(jid) {
	        var messages = this.data.chats[jid].messages;
	        if (this.local.replacement_messages[jid] && this.local.replacement_messages[jid].length) {
	          messages = _.omit(messages, _.pluck(this.local.replacement_messages[jid], "mid"));
	          var ordered = _.sortBy(messages, function (msg) {
	            return msg.time;
	          }),
	              lastBy;
	          _(this.local.replacement_messages[jid]).forEach(function (msg) {
	            lastBy = _.last(_(ordered).reject(function (entry) {
	              return entry.time > msg.time || entry.sender_id != msg.sender_id;
	            }).value());
	            if (lastBy) {
	              lastBy.body = lastBy.body.replace(msg.text_to_replace, msg.replacement_text);
	              messages[lastBy.mid] = Utils.formatMessageBody(lastBy);
	            }
	          }, this);
	          this.local.replacement_messages[jid] = [];
	        }
	        return messages;
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return ChatWindowStore;
	})(Store);

	module.exports = new ChatWindowStore();

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Emitter = __webpack_require__(88);
	var AppDispatcher = __webpack_require__(1);

	var Store = (function (Emitter) {
	  function Store() {
	    _classCallCheck(this, Store);

	    this.data = this.getDefaults();

	    this.registerListeners();
	  }

	  _inherits(Store, Emitter);

	  _prototypeProperties(Store, null, {
	    has: {
	      value: function has(key) {
	        return this.data.hasOwnProperty(key);
	      },
	      writable: true,
	      configurable: true
	    },
	    get: {
	      value: function get(key) {
	        return this.data[key];
	      },
	      writable: true,
	      configurable: true
	    },
	    getAll: {
	      value: function getAll() {
	        return this.data;
	      },
	      writable: true,
	      configurable: true
	    },
	    setIfNotEqual: {
	      value: function setIfNotEqual(key, value) {
	        var data = key;

	        if (value !== undefined) {
	          data = {};
	          data[key] = value;
	        }

	        this.doSet(data, true);
	      },
	      writable: true,
	      configurable: true
	    },
	    set: {
	      value: function set(key, value) {
	        var data = key;

	        if (value !== undefined) {
	          data = {};
	          data[key] = value;
	        }

	        this.doSet(data, false);
	      },
	      writable: true,
	      configurable: true
	    },
	    doSet: {
	      value: function doSet(data, doEqualityCheck) {
	        var changeset = {};
	        var hasChange = false;

	        _.keys(data).forEach(function (key) {

	          var shouldSet = !doEqualityCheck || doEqualityCheck && !_.isEqual(data[key], this.data[key]);

	          if (shouldSet) {
	            hasChange = true;
	            var oldValue = this.get(key),
	                value = data[key];

	            this.data[key] = value;
	            changeset[key] = value;
	            this.emit("change:" + key, value, oldValue);
	          }
	        }, this);

	        if (!doEqualityCheck || doEqualityCheck && hasChange) {
	          this.emit("change", changeset);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    unset: {
	      value: function unset(key) {
	        if (this.has(key)) {
	          var oldValue = this.get(key);
	          delete this.data[key];

	          this.emit("change:" + key, undefined, oldValue);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    clear: {
	      value: function clear() {
	        var changeset = {};

	        _.keys(this.data).forEach(function (key) {
	          changeset[key] = this.get(key);
	          this.unset(key);
	        }, this);

	        this.emit("change", changeset);
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {

	      /**
	       * Registers listeners.
	       */

	      value: function registerListeners() {},
	      writable: true,
	      configurable: true
	    },
	    getDefaults: {

	      /**
	       * Returns the default value of the store
	       */

	      value: function getDefaults() {
	        return {};
	      },
	      writable: true,
	      configurable: true
	    },
	    reset: {
	      value: function reset() {
	        this.data = this.getDefaults();
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return Store;
	})(Emitter);

	module.exports = Store;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * AppActions
	 *
	 * Exposed a window. Used for exposing actions to non react managed actions
	 * like mention clicks, etc.
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);
	var AppStore = __webpack_require__(2);

	module.exports = {

	  openChat: function openChat(target) {
	    var user = _.find(AppStore.data.roster, function (u) {
	      return u.mention_name.toLowerCase() === target.dataset.mentionName.toLowerCase();
	    });
	    var data = {
	      jid: user.jid,
	      name: user.name
	    };
	    AppDispatcher.dispatch("open-room", data);
	    AnalyticsDispatcher.dispatch("analytics-open-room", data);
	  },

	  logoClicked: function logoClicked() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.logo.clicked"
	    });
	  }

	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * ChatHeaderActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var ChatHeaderActions = {

	  handlePanelSelect: function handlePanelSelect(data) {
	    AppDispatcher.dispatch("select-panel", {
	      activePanel: data.type
	    });
	  },
	  handleTopicDoubleClick: function handleTopicDoubleClick() {
	    AppDispatcher.dispatch("edit-topic");
	  },
	  dismissTopicEdit: function dismissTopicEdit() {
	    AppDispatcher.dispatch("dismiss-topic-edit");
	  },
	  setInputValue: function setInputValue(data) {
	    AppDispatcher.dispatch("set-topic-input-value", data.text);
	  },
	  changeTopic: function changeTopic(data) {
	    AppDispatcher.dispatch("set-topic", data);
	  }

	};

	module.exports = ChatHeaderActions;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * ChatHeaderActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);

	var ChatInputActions = {

	  sendMessage: function sendMessage(data) {
	    AppDispatcher.dispatch("send-message", data);
	    AnalyticsDispatcher.dispatch("analytics-send-message", data);
	  },

	  clearChat: function clearChat(data) {
	    AppDispatcher.dispatch("clear-messages", data);
	  },

	  uploadFile: function uploadFile(data) {
	    AppDispatcher.dispatch("upload-file", data);
	  },

	  setMsgValue: function setMsgValue(data) {
	    AppDispatcher.dispatch("set-message-value", data.text);
	    AnalyticsDispatcher.dispatch("analytics-set-message-value", data.text);
	  },

	  expandAttachment: function expandAttachment(data) {
	    AppDispatcher.dispatch("expand-attachment", data);
	  },

	  closeAttachment: function closeAttachment() {
	    AppDispatcher.dispatch("close-attachment");
	  },

	  changeFileName: function changeFileName(data) {
	    AppDispatcher.dispatch("change-filename", data);
	  },

	  toggleTooltip: function toggleTooltip(data) {
	    AppDispatcher.dispatch("toggle-tooltip", data);
	  },

	  openTooltip: function openTooltip(data) {
	    AppDispatcher.dispatch("open-tooltip", data);
	  },

	  closeTooltip: function closeTooltip(data) {
	    AppDispatcher.dispatch("close-tooltip", data);
	  },

	  dispatchFileError: function dispatchFileError(message_key) {
	    AppDispatcher.dispatch("file-error", message_key);
	  },

	  clearErrors: function clearErrors() {
	    AppDispatcher.dispatch("clear-errors");
	  },

	  setUserState: function setUserState(data) {
	    AppDispatcher.dispatch("set-user-state", {
	      jid: data.jid,
	      type: data.type,
	      state: data.state
	    });
	  }

	};

	module.exports = ChatInputActions;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * ConnectionActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var ConnectionActions = {

	  handleReconnectLinkClick: function handleReconnectLinkClick() {
	    AppDispatcher.dispatch("attempt-reconnect");
	  }

	};

	module.exports = ConnectionActions;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * AppHeaderActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);
	var DialogActions = __webpack_require__(28);
	var InlineDialogActions = __webpack_require__(51);

	var AppHeaderActions = {

	  requestPreferencesDialog: function requestPreferencesDialog() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.profile.settings.clicked"
	    });
	    DialogActions.showSettingDialog();
	  },

	  /**
	   * Sets the user's presence and status.
	   * @param presence
	   */
	  setPresence: function setPresence(presence) {
	    var data = {
	      show: presence.show,
	      status: presence.status
	    };
	    AppDispatcher.dispatch("update-presence", data);
	    AnalyticsDispatcher.dispatch("analytics-update-presence", data);
	  },

	  /**
	   * Updates the user's status and hides the user status form.
	   * @param {Object} presence
	   */
	  setStatus: function setStatus(presence) {
	    this.setPresence(presence);
	    InlineDialogActions.hideInlineDialog();
	  },

	  /**
	   * Updates the users presence and displays the user status form
	   * @param  {Object} presence
	   */
	  updatePresence: function updatePresence(presence) {
	    this.setPresence(presence);
	    InlineDialogActions.showUserStatusMessage({
	      presence: presence
	    });
	  },

	  hideStatusMessageForm: function hideStatusMessageForm() {
	    InlineDialogActions.hideInlineDialog();
	  },

	  signout: function signout() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.profile.signout.clicked"
	    });
	    AppDispatcher.dispatch("signout");
	  },

	  helpButtonClicked: function helpButtonClicked() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.help.clicked"
	    });
	  },

	  userProfileDropdownClicked: function userProfileDropdownClicked() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.top.navigation.profile.clicked"
	    });
	  },

	  searchHistory: function searchHistory(jid) {
	    AppDispatcher.dispatch("search-history", { jid: jid });
	  },

	  setSearchText: function setSearchText(data) {
	    AppDispatcher.dispatch("set-search-text", data);
	  },

	  searchBlurred: function searchBlurred() {
	    AppDispatcher.dispatch("blur-search");
	  },

	  dismissNotificationBanner: function dismissNotificationBanner() {
	    AppDispatcher.dispatch("dismiss-notification-banner");
	  },

	  dismissNotificationBannerForever: function dismissNotificationBannerForever() {
	    AppDispatcher.dispatch("dismiss-notification-banner-forever");
	  },

	  requestNotificationPermission: function requestNotificationPermission() {
	    AppDispatcher.dispatch("request-notification-permission");
	  }

	};

	module.exports = AppHeaderActions;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * FlagActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var FlagActions = {

	  showFlag: function showFlag(flag_data) {
	    AppDispatcher.dispatch("show-flag", flag_data);
	  },

	  removeFlag: function removeFlag(flag_index) {
	    AppDispatcher.dispatch("remove-flag", flag_index);
	  }

	};

	module.exports = FlagActions;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * FormActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);

	var FormActions = {

	  changeRoomPrivacy: function changeRoomPrivacy(submit_data, callback) {
	    AppDispatcher.dispatch("change-room-privacy", submit_data, callback);
	  },

	  changeRoomName: function changeRoomName(submit_data, callback) {
	    AppDispatcher.dispatch("change-room-name", submit_data, callback);
	  },

	  createRoom: function createRoom(submit_data, callback) {
	    AppDispatcher.dispatch("create-room", submit_data, callback);
	    AnalyticsDispatcher.dispatch("analytics-create-room", submit_data);
	  },

	  inviteUsers: function inviteUsers(submit_data) {
	    AppDispatcher.dispatch("invite-users", submit_data);
	  },

	  removeUsers: function removeUsers(submit_data, callback) {
	    AppDispatcher.dispatch("remove-users", submit_data, callback);
	  }

	};

	module.exports = FormActions;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1),
	    InlineDialogStore = __webpack_require__(89);

	module.exports = {

	  hideInlineDialog: function hideInlineDialog() {
	    AppDispatcher.dispatch("hide-inline-dialog", {
	      dialog_type: InlineDialogStore.getCurrentInlineDialog()
	    });
	  },

	  toggleInlineDialog: function toggleInlineDialog(dialogType, data) {
	    AppDispatcher.dispatch("toggle-inline-dialog", {
	      dialog_type: dialogType,
	      current_dialog_type: InlineDialogStore.getCurrentInlineDialog(),
	      dialog_data: data
	    });
	  },

	  showUserStatusMessage: function showUserStatusMessage(data) {
	    AppDispatcher.dispatch("show-inline-dialog", {
	      dialog_type: "user-status-message-inline-dialog",
	      dialog_data: data
	    });
	  },

	  showInviteNewUsersForm: function showInviteNewUsersForm(data) {
	    AppDispatcher.dispatch("show-inline-dialog", {
	      dialog_type: "invite-users-inline-dialog",
	      dialog_data: data
	    });
	  }
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * LobbyActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);

	var LobbyActions = {

	  /**
	   * @param  {object} data
	   */
	  applyFilter: function applyFilter(data) {
	    AppDispatcher.dispatch("filter-lobby", data);
	    AnalyticsDispatcher.dispatch("analytics-filter-lobby", data);
	  },

	  openChat: function openChat(data) {
	    AppDispatcher.dispatch("open-room", data);
	    AnalyticsDispatcher.dispatch("analytics-open-room", data);
	  },

	  showCreateRoomDialog: function showCreateRoomDialog() {
	    AnalyticsDispatcher.dispatch("analytics-event", {
	      name: "hipchat.client.lobby.create.room.dialog.open"
	    });
	    AppDispatcher.dispatch("show-modal-dialog", {
	      dialog_type: "create-room-dialog",
	      dialog_data: false
	    });
	  },

	  lobbyMounted: function lobbyMounted() {
	    AnalyticsDispatcher.dispatch("analytics-lobby-mount", { id: "lobby" });
	  }
	};

	module.exports = LobbyActions;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);

	module.exports = {

	  savePreferences: function savePreferences(data) {
	    AppDispatcher.dispatch("save-preferences", data);
	  },

	  saveClientPreferences: function saveClientPreferences(data) {
	    AppDispatcher.dispatch("save-client-preferences", data);
	  }

	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Room Dropdown Actions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AppStore = __webpack_require__(2);

	module.exports = {

	  openIntegrations: function openIntegrations(room_id) {
	    var current_user = AppStore.get("current_user"),
	        url = "/rooms/addons/" + room_id + "?required_email=" + encodeURIComponent(current_user.email);
	    window.open(url, "_blank");
	  },

	  editTopic: function editTopic() {
	    AppDispatcher.dispatch("edit-topic");
	  },

	  deleteRoom: function deleteRoom(data, cb) {
	    AppDispatcher.dispatch("delete-room", {
	      jid: data.jid,
	      reason: "Admin is deleting the room"
	    }, cb);
	  },

	  archiveRoom: function archiveRoom(data, cb) {
	    AppDispatcher.dispatch("archive-room", {
	      jid: data.jid,
	      id: data.id
	    }, cb);
	  },

	  unarchiveRoom: function unarchiveRoom(data, cb) {
	    AppDispatcher.dispatch("unarchive-room", {
	      jid: data.jid,
	      id: data.id
	    }, cb);
	  },

	  enableGuestAccess: function enableGuestAccess(data) {
	    AppDispatcher.dispatch("set-guest-access", {
	      jid: data.jid,
	      enable: true
	    });
	  },

	  disableGuestAccess: function disableGuestAccess(data) {
	    AppDispatcher.dispatch("set-guest-access", {
	      jid: data.jid,
	      enable: false
	    });
	  }

	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * RoomNavActions
	 */

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);

	var RoomNavActions = {

	  /**
	   * @param  {string} jid
	   */
	  select: function select(jid, type) {
	    var data = {
	      jid: jid,
	      type: type
	    };
	    AppDispatcher.dispatch("select-room", data);
	    AnalyticsDispatcher.dispatch("analytics-select-room", data);
	  },

	  /**
	   * @param  {string} jid
	   */
	  close: function close(jid, type) {
	    AppDispatcher.dispatch("close-room", {
	      jid: jid,
	      type: type
	    });
	  },

	  openLobby: function openLobby() {
	    var data = {
	      jid: "lobby"
	    };
	    AppDispatcher.dispatch("select-room", data);
	    AnalyticsDispatcher.dispatch("analytics-select-room", data);
	  },

	  update_room_order: function update_room_order(room_jids) {
	    AppDispatcher.dispatch("update-room-order", room_jids);
	  }

	};

	module.exports = RoomNavActions;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * LobbyRosterActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var LobbyRosterActions = {

	  fetchPresence: function fetchPresence() {
	    AppDispatcher.dispatch("fetch-presence");
	  }

	};

	module.exports = LobbyRosterActions;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * TooltipActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var TooltipActions = {

	  showTooltip: function showTooltip(data) {
	    AppDispatcher.dispatch("show-tooltip", data);
	  },

	  smileyChosen: function smileyChosen(data) {
	    AppDispatcher.dispatch("smiley-chosen", data);
	  }

	};

	module.exports = TooltipActions;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var ModalDialogStore = __webpack_require__(95),
	    SettingsDialog = __webpack_require__(97),
	    InviteUserDialog = __webpack_require__(98),
	    RemoveUserDialog = __webpack_require__(99),
	    CreateRoomDialog = __webpack_require__(100),
	    RoomPrivacyDialog = __webpack_require__(101),
	    RenameRoomDialog = __webpack_require__(102),
	    DeleteRoomDialog = __webpack_require__(103),
	    RoomInviteDialog = __webpack_require__(104),
	    ArchiveRoomDialog = __webpack_require__(105),
	    DisableGuestAccessDialog = __webpack_require__(106),
	    KeyboardShortcutsDialog = __webpack_require__(107),
	    ModalBackdrop = __webpack_require__(96);

	module.exports = React.createClass({

	  displayName: "ModalDialogContainer",

	  componentDidMount: function componentDidMount() {
	    ModalDialogStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    ModalDialogStore.off("change", this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return ModalDialogStore.getAll();
	  },

	  _onChange: function _onChange() {
	    this.setState(ModalDialogStore.getAll());
	  },

	  _getDialogBackdrop: function _getDialogBackdrop() {
	    return React.createElement(ModalBackdrop, { btnLoading: this.state.btnLoading });
	  },

	  _getDialog: function _getDialog() {
	    var currentDialogId = ModalDialogStore.getCurrentModalDialog();
	    var currentDialog = false;

	    if (currentDialogId) {
	      switch (currentDialogId) {
	        case "settings-dialog":
	          currentDialog = React.createElement(SettingsDialog, this.state.dialogData);
	          break;

	        case "invite-users-dialog":
	          currentDialog = React.createElement(InviteUserDialog, this.state.dialogData);
	          break;

	        case "remove-users-dialog":
	          currentDialog = React.createElement(RemoveUserDialog, this.state.dialogData);
	          break;

	        case "create-room-dialog":
	          currentDialog = React.createElement(CreateRoomDialog, _extends({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;

	        case "room-privacy-dialog":
	          currentDialog = React.createElement(RoomPrivacyDialog, _extends({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;

	        case "rename-room-dialog":
	          currentDialog = React.createElement(RenameRoomDialog, _extends({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;

	        case "delete-room-dialog":
	          currentDialog = React.createElement(DeleteRoomDialog, _extends({}, this.state.dialogData, { btnLoading: this.state.btnLoading }));
	          break;

	        case "room-invite-dialog":
	          currentDialog = React.createElement(RoomInviteDialog, this.state.dialogData);
	          break;

	        case "archive-room-dialog":
	          currentDialog = React.createElement(ArchiveRoomDialog, this.state.dialogData);
	          break;

	        case "disable-guest-dialog":
	          currentDialog = React.createElement(DisableGuestAccessDialog, this.state.dialogData);
	          break;

	        case "keyboard-shortcuts-dialog":
	          currentDialog = React.createElement(KeyboardShortcutsDialog, this.state.dialogData);
	          break;
	      }
	    }

	    return currentDialog;
	  },

	  render: function render() {

	    var dialogBackdrop;
	    var dialog = this._getDialog();

	    if (dialog) {
	      dialogBackdrop = this._getDialogBackdrop();
	    }

	    return React.createElement(
	      "div",
	      null,
	      dialog,
	      dialogBackdrop
	    );
	  }
	});

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var InlineDialogStore = __webpack_require__(89);
	var InviteUsersInlineDialog = __webpack_require__(92);
	var UserStatusMessageForm = __webpack_require__(93);
	var AceStpInlineDialog = __webpack_require__(94);

	module.exports = React.createClass({

	  displayName: "InlineDialogContainer",

	  componentDidMount: function componentDidMount() {
	    InlineDialogStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    InlineDialogStore.off("change", this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return InlineDialogStore.getAll();
	  },

	  _onChange: function _onChange() {
	    this.setState(InlineDialogStore.getAll());
	  },

	  _getDialog: function _getDialog() {
	    var currentDialogId = this.state.visibleDialog;
	    var currentDialog = false;

	    if (currentDialogId) {
	      switch (currentDialogId) {
	        case "invite-users-inline-dialog":
	          currentDialog = React.createElement(InviteUsersInlineDialog, this.state.dialogData);
	          break;

	        case "user-status-message-inline-dialog":
	          currentDialog = React.createElement(UserStatusMessageForm, this.state.dialogData);
	          break;
	      }
	    }

	    return currentDialog;
	  },

	  _isDialogInvisible: function _isDialogInvisible(dialogId) {
	    return this.state.visibleDialog !== dialogId;
	  },

	  render: function render() {

	    var dialog = this._getDialog();

	    return React.createElement(
	      "div",
	      null,
	      dialog,
	      React.createElement(AceStpInlineDialog, _extends({}, this.state.dialogData, { invisible: this._isDialogInvisible("ace-stp-inline-dialog") }))
	    );
	  }
	});

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var FlagsStore = __webpack_require__(108),
	    Flag = __webpack_require__(109);

	module.exports = React.createClass({

	  displayName: "FlagsContainer",

	  componentDidMount: function componentDidMount() {
	    FlagsStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    FlagsStore.off("change", this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return FlagsStore.getAll();
	  },

	  _onChange: function _onChange() {
	    this.setState(FlagsStore.getAll());
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-flags-container" },
	      _.map(this.state.flags, function (flag, index) {
	        return React.createElement(Flag, { flag_index: index, title: flag.title, type: flag.type, body: flag.body, close: flag.close });
	      }, this)
	    );
	  }
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var AnalyticsDispatcher = __webpack_require__(7);
	var fileHelper = __webpack_require__(90);
	var rosterStore = __webpack_require__(91);

	var matchItem = function matchItem(item) {
	  return item.src;
	};
	var normalize = fileHelper.transformForFileViewer.bind(fileHelper);
	var isSupported = fileHelper.fileViewerSupports.bind(fileHelper);

	module.exports = React.createClass({

	  displayName: "FileViewer",

	  componentWillMount: function componentWillMount() {
	    AppDispatcher.register("open-in-file-viewer", this._open);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    AppDispatcher.unregister("open-in-file-viewer", this._open);
	  },

	  render: function render() {
	    var styles = {
	      display: "none"
	    };
	    return React.createElement("div", { style: styles });
	  },

	  _viewer: null,

	  _open: function _open(item) {
	    var normalized = normalize(item);

	    if (!FileViewer) {
	      return;
	    }
	    if (!this._viewer) {
	      this._setupViewer();
	    }

	    this._viewer.updateFiles([normalized]);
	    this._viewer.open({ src: normalized.src }, "main");

	    this._updateCollection();
	  },

	  _setupViewer: function _setupViewer() {
	    this._viewer = new FileViewer({
	      moduleBackend: getModuleLoader(),
	      analyticsBackend: this._sendAnalytics
	    });

	    videojs.options.techOrder = ["html5", "youtube"];

	    AppDispatcher.register({
	      "files-fetched": this._updateCollection,
	      "links-fetched": this._updateCollection
	    });

	    this._viewer.on("fv.open", function () {
	      var eventData = { room: rosterStore.data.active_chat };

	      if (!rosterStore.get("files").length) {
	        AppDispatcher.dispatch("fetch-files", eventData);
	      }
	      if (!rosterStore.get("links").length) {
	        AppDispatcher.dispatch("fetch-links", eventData);
	      }
	    });
	  },

	  _updateCollection: function _updateCollection() {
	    if (!this._viewer.isOpen()) {
	      return;
	    }

	    var files = rosterStore.get("files");
	    var links = rosterStore.get("links").filter(isSupported);
	    var combined = _.sortBy(files.concat(links), "date").map(normalize);

	    this._viewer.updateFiles(combined, matchItem);

	    var currentSrc = this._viewer.getCurrentFile().get("src");
	    var q = this._viewer._fileState.collection.findWhere({ src: currentSrc });
	    if (q) {
	      this._viewer._fileState.setCurrentWithCID(q.cid);
	    }
	  },

	  _sendAnalytics: function _sendAnalytics(key, data) {
	    AnalyticsDispatcher.dispatch(key, data);
	  }

	});

	function getModuleLoader() {

	  var toInternal = function toInternal(name) {
	    return ({
	      "pdf-viewer": "pdf-view"
	    })[name];
	  };

	  var toResource = function toResource(name) {
	    return ({
	      "pdf-viewer": "/wc/vendor/fileviewer-1.0.1/fileviewer-document.custom.min.js",
	      "pdf-viewer-css": "/wc/vendor/fileviewer-1.0.1/fileviewer-document.custom.min.css"
	    })[name];
	  };

	  var fetchJsResource = function fetchJsResource(resource) {
	    $("head").append("<script async src=\"" + resource + "\"></script>");
	  };

	  var fetchCssResource = function fetchCssResource(resource) {
	    $("head").append("<link rel=\"stylesheet\" href=\"" + resource + "\" media=\"all\">");
	  };

	  var modules = {
	    "pdf-config": {
	      workerSrc: "/wc/vendor/pdfjs/pdf.worker.min.js",
	      viewer: "/wc/vendor/pdfjs/"
	    },
	    "pdf-viewer": null
	  };

	  return function (moduleName) {

	    if (!modules[moduleName]) {
	      var dfd = new $.Deferred();

	      if (!window.defer) {
	        window.defer = [];
	        fetchJsResource("/wc/vendor/defer-1.1.0.min.js");
	      }

	      fetchJsResource(toResource(moduleName));
	      fetchCssResource(toResource(moduleName + "-css"));

	      window.defer.push({
	        p: function p() {
	          return typeof FileViewer._modules[toInternal(moduleName)] !== "undefined";
	        },
	        h: function h() {
	          dfd.resolve(FileViewer.require(toInternal(moduleName)));
	        },
	        o: {}
	      });

	      modules[moduleName] = dfd.promise();
	    }

	    return modules[moduleName];
	  };
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var EventEmitter = __webpack_require__(110).EventEmitter;

	var Dispatcher = (function (EventEmitter) {
	  function Dispatcher() {
	    _classCallCheck(this, Dispatcher);

	    if (EventEmitter != null) {
	      EventEmitter.apply(this, arguments);
	    }
	  }

	  _inherits(Dispatcher, EventEmitter);

	  _prototypeProperties(Dispatcher, null, {
	    dispatch: {
	      value: function dispatch(action /*, ...args */) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        if (window.HC_LOG && typeof window != "undefined" && "console" in window) {
	          console.debug("[HC Web:" + action + "]", args || "no arguments");
	        }
	        this.emit.apply(this, ["before:" + action].concat(args));
	        this.emit.apply(this, arguments);
	        this.emit.apply(this, ["after:" + action].concat(args));
	      },
	      writable: true,
	      configurable: true
	    },
	    registerOnce: {
	      value: function registerOnce(action, callback) {
	        var _this = this;

	        if (_.isString(action)) {
	          this.once(action, callback);
	        } else if (_.isObject(action)) {
	          _.forOwn(action, function (val, key) {
	            _this.once(key, val);
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    register: {
	      value: function register(action, callback) {
	        var _this = this;

	        if (_.isString(action)) {
	          this.on(action, callback);
	        } else if (_.isObject(action)) {
	          _.forOwn(action, function (val, key) {
	            _this.on(key, val);
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    unregister: {
	      value: function unregister(action, callback) {
	        var _this = this;

	        if (_.isString(action)) {
	          this.removeListener(action, callback);
	        } else if (_.isObject(action)) {
	          _.forOwn(action, function (val, key) {
	            _this.removeListener(key, val);
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return Dispatcher;
	})(EventEmitter);

	module.exports = Dispatcher;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	;!function(undefined) {

		var ObjectPath = {
			parse: function(str){
				if(typeof str !== 'string'){
					throw new TypeError('ObjectPath.parse must be passed a string');
				}

				var i = 0;
				var parts = [];
				var d, b, q, c;
				while (i < str.length){
					d = str.indexOf('.', i);
					b = str.indexOf('[', i);

					// we've reached the end
					if (d === -1 && b === -1){
						parts.push(str.slice(i, str.length));
						i = str.length;
					}

					// dots
					else if (b === -1 || (d !== -1 && d < b)) {
						parts.push(str.slice(i, d));
						i = d + 1;
					}

					// brackets
					else {
						if (b > i){
							parts.push(str.slice(i, b));
							i = b;
						}
						q = str.slice(b+1, b+2);
						if (q !== '"' && q !=='\'') {
							c = str.indexOf(']', b);
							if (c === -1) c = str.length;
							parts.push(str.slice(i + 1, c));
							i = (str.slice(c + 1, c + 2) === '.') ? c + 2 : c + 1;
						} else {
							c = str.indexOf(q+']', b);
							if (c === -1) c = str.length;
							while (str.slice(c - 1, c) === '\\' && b < str.length){
								b++;
								c = str.indexOf(q+']', b);
							}
							parts.push(str.slice(i + 2, c).replace(new RegExp('\\'+q,'g'), q));
							i = (str.slice(c + 2, c + 3) === '.') ? c + 3 : c + 2;
						}
					}
				}
				return parts;
			},

			// root === true : auto calculate root; must be dot-notation friendly
			// root String : the string to use as root
			stringify: function(arr, quote){

				if(!Array.isArray(arr))
					arr = [arr.toString()];

				quote = quote === '"' ? '"' : '\'';

				return arr.map(function(n){ return '[' + quote + (n.toString()).replace(new RegExp(quote, 'g'), '\\' + quote) + quote + ']'; }).join('');
			},

			normalize: function(data, quote){
				return ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);
			},

			// Angular
			registerModule: function(angular) {
				angular.module('ObjectPath', []).provider('ObjectPath', function(){
					this.parse = ObjectPath.parse;
					this.stringify = ObjectPath.stringify;
					this.normalize = ObjectPath.normalize;
					this.$get = function(){
						return ObjectPath;
					};
				});
			}
		};

		// AMD
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return ObjectPath;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}

		// CommonJS
		else if (module && typeof module.exports === 'object') {
			module.exports = ObjectPath;
		}

		// Browser global
		else {
			window.ObjectPath = ObjectPath;
		}

	}();

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {//! moment.js
	//! version : 2.9.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	(function (undefined) {
	    /************************************
	        Constants
	    ************************************/

	    var moment,
	        VERSION = '2.9.0',
	        // the global-scope this is NOT the global object in Node.js
	        globalScope = (typeof global !== 'undefined' && (typeof window === 'undefined' || window === global.window)) ? global : this,
	        oldGlobalMoment,
	        round = Math.round,
	        hasOwnProperty = Object.prototype.hasOwnProperty,
	        i,

	        YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,

	        // internal storage for locale config files
	        locales = {},

	        // extra moment internal properties (plugins register props here)
	        momentProperties = [],

	        // check for nodeJS
	        hasModule = (typeof module !== 'undefined' && module && module.exports),

	        // ASP.NET json date format regex
	        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
	        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

	        // format tokens
	        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

	        // parsing token regexes
	        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
	        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
	        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
	        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
	        parseTokenDigits = /\d+/, // nonzero number of digits
	        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
	        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        parseTokenT = /T/i, // T (ISO separator)
	        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
	        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

	        //strict parsing regexes
	        parseTokenOneDigit = /\d/, // 0 - 9
	        parseTokenTwoDigits = /\d\d/, // 00 - 99
	        parseTokenThreeDigits = /\d{3}/, // 000 - 999
	        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
	        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
	        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

	        // iso 8601 regex
	        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

	        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

	        isoDates = [
	            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
	            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
	            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
	            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
	            ['YYYY-DDD', /\d{4}-\d{3}/]
	        ],

	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
	            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
	            ['HH:mm', /(T| )\d\d:\d\d/],
	            ['HH', /(T| )\d\d/]
	        ],

	        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-', '15', '30']
	        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

	        // getter and setter names
	        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
	        unitMillisecondFactors = {
	            'Milliseconds' : 1,
	            'Seconds' : 1e3,
	            'Minutes' : 6e4,
	            'Hours' : 36e5,
	            'Days' : 864e5,
	            'Months' : 2592e6,
	            'Years' : 31536e6
	        },

	        unitAliases = {
	            ms : 'millisecond',
	            s : 'second',
	            m : 'minute',
	            h : 'hour',
	            d : 'day',
	            D : 'date',
	            w : 'week',
	            W : 'isoWeek',
	            M : 'month',
	            Q : 'quarter',
	            y : 'year',
	            DDD : 'dayOfYear',
	            e : 'weekday',
	            E : 'isoWeekday',
	            gg: 'weekYear',
	            GG: 'isoWeekYear'
	        },

	        camelFunctions = {
	            dayofyear : 'dayOfYear',
	            isoweekday : 'isoWeekday',
	            isoweek : 'isoWeek',
	            weekyear : 'weekYear',
	            isoweekyear : 'isoWeekYear'
	        },

	        // format function strings
	        formatFunctions = {},

	        // default relative time thresholds
	        relativeTimeThresholds = {
	            s: 45,  // seconds to minute
	            m: 45,  // minutes to hour
	            h: 22,  // hours to day
	            d: 26,  // days to month
	            M: 11   // months to year
	        },

	        // tokens to ordinalize and pad
	        ordinalizeTokens = 'DDD w W M D d'.split(' '),
	        paddedTokens = 'M D H h m s w W'.split(' '),

	        formatTokenFunctions = {
	            M    : function () {
	                return this.month() + 1;
	            },
	            MMM  : function (format) {
	                return this.localeData().monthsShort(this, format);
	            },
	            MMMM : function (format) {
	                return this.localeData().months(this, format);
	            },
	            D    : function () {
	                return this.date();
	            },
	            DDD  : function () {
	                return this.dayOfYear();
	            },
	            d    : function () {
	                return this.day();
	            },
	            dd   : function (format) {
	                return this.localeData().weekdaysMin(this, format);
	            },
	            ddd  : function (format) {
	                return this.localeData().weekdaysShort(this, format);
	            },
	            dddd : function (format) {
	                return this.localeData().weekdays(this, format);
	            },
	            w    : function () {
	                return this.week();
	            },
	            W    : function () {
	                return this.isoWeek();
	            },
	            YY   : function () {
	                return leftZeroFill(this.year() % 100, 2);
	            },
	            YYYY : function () {
	                return leftZeroFill(this.year(), 4);
	            },
	            YYYYY : function () {
	                return leftZeroFill(this.year(), 5);
	            },
	            YYYYYY : function () {
	                var y = this.year(), sign = y >= 0 ? '+' : '-';
	                return sign + leftZeroFill(Math.abs(y), 6);
	            },
	            gg   : function () {
	                return leftZeroFill(this.weekYear() % 100, 2);
	            },
	            gggg : function () {
	                return leftZeroFill(this.weekYear(), 4);
	            },
	            ggggg : function () {
	                return leftZeroFill(this.weekYear(), 5);
	            },
	            GG   : function () {
	                return leftZeroFill(this.isoWeekYear() % 100, 2);
	            },
	            GGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 4);
	            },
	            GGGGG : function () {
	                return leftZeroFill(this.isoWeekYear(), 5);
	            },
	            e : function () {
	                return this.weekday();
	            },
	            E : function () {
	                return this.isoWeekday();
	            },
	            a    : function () {
	                return this.localeData().meridiem(this.hours(), this.minutes(), true);
	            },
	            A    : function () {
	                return this.localeData().meridiem(this.hours(), this.minutes(), false);
	            },
	            H    : function () {
	                return this.hours();
	            },
	            h    : function () {
	                return this.hours() % 12 || 12;
	            },
	            m    : function () {
	                return this.minutes();
	            },
	            s    : function () {
	                return this.seconds();
	            },
	            S    : function () {
	                return toInt(this.milliseconds() / 100);
	            },
	            SS   : function () {
	                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
	            },
	            SSS  : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            SSSS : function () {
	                return leftZeroFill(this.milliseconds(), 3);
	            },
	            Z    : function () {
	                var a = this.utcOffset(),
	                    b = '+';
	                if (a < 0) {
	                    a = -a;
	                    b = '-';
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
	            },
	            ZZ   : function () {
	                var a = this.utcOffset(),
	                    b = '+';
	                if (a < 0) {
	                    a = -a;
	                    b = '-';
	                }
	                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
	            },
	            z : function () {
	                return this.zoneAbbr();
	            },
	            zz : function () {
	                return this.zoneName();
	            },
	            x    : function () {
	                return this.valueOf();
	            },
	            X    : function () {
	                return this.unix();
	            },
	            Q : function () {
	                return this.quarter();
	            }
	        },

	        deprecations = {},

	        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'],

	        updateInProgress = false;

	    // Pick the first defined of two or three arguments. dfl comes from
	    // default.
	    function dfl(a, b, c) {
	        switch (arguments.length) {
	            case 2: return a != null ? a : b;
	            case 3: return a != null ? a : b != null ? b : c;
	            default: throw new Error('Implement me');
	        }
	    }

	    function hasOwnProp(a, b) {
	        return hasOwnProperty.call(a, b);
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object, and es5 standard is not very
	        // helpful.
	        return {
	            empty : false,
	            unusedTokens : [],
	            unusedInput : [],
	            overflow : -2,
	            charsLeftOver : 0,
	            nullInput : false,
	            invalidMonth : null,
	            invalidFormat : false,
	            userInvalidated : false,
	            iso: false
	        };
	    }

	    function printMsg(msg) {
	        if (moment.suppressDeprecationWarnings === false &&
	                typeof console !== 'undefined' && console.warn) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;
	        return extend(function () {
	            if (firstTime) {
	                printMsg(msg);
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    function deprecateSimple(name, msg) {
	        if (!deprecations[name]) {
	            printMsg(msg);
	            deprecations[name] = true;
	        }
	    }

	    function padToken(func, count) {
	        return function (a) {
	            return leftZeroFill(func.call(this, a), count);
	        };
	    }
	    function ordinalizeToken(func, period) {
	        return function (a) {
	            return this.localeData().ordinal(func.call(this, a), period);
	        };
	    }

	    function monthDiff(a, b) {
	        // difference in months
	        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2, adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        return -(wholeMonthDiff + adjust);
	    }

	    while (ordinalizeTokens.length) {
	        i = ordinalizeTokens.pop();
	        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
	    }
	    while (paddedTokens.length) {
	        i = paddedTokens.pop();
	        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
	    }
	    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


	    function meridiemFixWrap(locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // thie is not supposed to happen
	            return hour;
	        }
	    }

	    /************************************
	        Constructors
	    ************************************/

	    function Locale() {
	    }

	    // Moment prototype object
	    function Moment(config, skipOverflow) {
	        if (skipOverflow !== false) {
	            checkOverflow(config);
	        }
	        copyConfig(this, config);
	        this._d = new Date(+config._d);
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            moment.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    // Duration Constructor
	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        // representation for dateAddRemove
	        this._milliseconds = +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 36e5; // 1000 * 60 * 60
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days +
	            weeks * 7;
	        // It is impossible translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months +
	            quarters * 3 +
	            years * 12;

	        this._data = {};

	        this._locale = moment.localeData();

	        this._bubble();
	    }

	    /************************************
	        Helpers
	    ************************************/


	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function copyConfig(to, from) {
	        var i, prop, val;

	        if (typeof from._isAMomentObject !== 'undefined') {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (typeof from._i !== 'undefined') {
	            to._i = from._i;
	        }
	        if (typeof from._f !== 'undefined') {
	            to._f = from._f;
	        }
	        if (typeof from._l !== 'undefined') {
	            to._l = from._l;
	        }
	        if (typeof from._strict !== 'undefined') {
	            to._strict = from._strict;
	        }
	        if (typeof from._tzm !== 'undefined') {
	            to._tzm = from._tzm;
	        }
	        if (typeof from._isUTC !== 'undefined') {
	            to._isUTC = from._isUTC;
	        }
	        if (typeof from._offset !== 'undefined') {
	            to._offset = from._offset;
	        }
	        if (typeof from._pf !== 'undefined') {
	            to._pf = from._pf;
	        }
	        if (typeof from._locale !== 'undefined') {
	            to._locale = from._locale;
	        }

	        if (momentProperties.length > 0) {
	            for (i in momentProperties) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (typeof val !== 'undefined') {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    function absRound(number) {
	        if (number < 0) {
	            return Math.ceil(number);
	        } else {
	            return Math.floor(number);
	        }
	    }

	    // left zero fill a number
	    // see http://jsperf.com/left-zero-filling for performance comparison
	    function leftZeroFill(number, targetLength, forceSign) {
	        var output = '' + Math.abs(number),
	            sign = number >= 0;

	        while (output.length < targetLength) {
	            output = '0' + output;
	        }
	        return (sign ? (forceSign ? '+' : '') : '-') + output;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {milliseconds: 0, months: 0};

	        res.months = other.month() - base.month() +
	            (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        other = makeAs(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
	                tmp = val; val = period; period = tmp;
	            }

	            val = typeof val === 'string' ? +val : val;
	            dur = moment.duration(val, period);
	            addOrSubtractDurationFromMoment(this, dur, direction);
	            return this;
	        };
	    }

	    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = duration._days,
	            months = duration._months;
	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (milliseconds) {
	            mom._d.setTime(+mom._d + milliseconds * isAdding);
	        }
	        if (days) {
	            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
	        }
	        if (months) {
	            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
	        }
	        if (updateOffset) {
	            moment.updateOffset(mom, days || months);
	        }
	    }

	    // check if is an array
	    function isArray(input) {
	        return Object.prototype.toString.call(input) === '[object Array]';
	    }

	    function isDate(input) {
	        return Object.prototype.toString.call(input) === '[object Date]' ||
	            input instanceof Date;
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if ((dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    function normalizeUnits(units) {
	        if (units) {
	            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
	            units = unitAliases[units] || camelFunctions[lowered] || lowered;
	        }
	        return units;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    function makeList(field) {
	        var count, setter;

	        if (field.indexOf('week') === 0) {
	            count = 7;
	            setter = 'day';
	        }
	        else if (field.indexOf('month') === 0) {
	            count = 12;
	            setter = 'month';
	        }
	        else {
	            return;
	        }

	        moment[field] = function (format, index) {
	            var i, getter,
	                method = moment._locale[field],
	                results = [];

	            if (typeof format === 'number') {
	                index = format;
	                format = undefined;
	            }

	            getter = function (i) {
	                var m = moment().utc().set(setter, i);
	                return method.call(moment._locale, m, format || '');
	            };

	            if (index != null) {
	                return getter(index);
	            }
	            else {
	                for (i = 0; i < count; i++) {
	                    results.push(getter(i));
	                }
	                return results;
	            }
	        };
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            if (coercedNumber >= 0) {
	                value = Math.floor(coercedNumber);
	            } else {
	                value = Math.ceil(coercedNumber);
	            }
	        }

	        return value;
	    }

	    function daysInMonth(year, month) {
	        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	    }

	    function weeksInYear(year, dow, doy) {
	        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
	    }

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    function checkOverflow(m) {
	        var overflow;
	        if (m._a && m._pf.overflow === -2) {
	            overflow =
	                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
	                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
	                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
	                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
	                                           m._a[SECOND] !== 0 ||
	                                           m._a[MILLISECOND] !== 0)) ? HOUR :
	                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
	                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
	                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
	                -1;

	            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	                overflow = DATE;
	            }

	            m._pf.overflow = overflow;
	        }
	    }

	    function isValid(m) {
	        if (m._isValid == null) {
	            m._isValid = !isNaN(m._d.getTime()) &&
	                m._pf.overflow < 0 &&
	                !m._pf.empty &&
	                !m._pf.invalidMonth &&
	                !m._pf.nullInput &&
	                !m._pf.invalidFormat &&
	                !m._pf.userInvalidated;

	            if (m._strict) {
	                m._isValid = m._isValid &&
	                    m._pf.charsLeftOver === 0 &&
	                    m._pf.unusedTokens.length === 0 &&
	                    m._pf.bigHour === undefined;
	            }
	        }
	        return m._isValid;
	    }

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0, j, next, locale, split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return null;
	    }

	    function loadLocale(name) {
	        var oldLocale = null;
	        if (!locales[name] && hasModule) {
	            try {
	                oldLocale = moment.locale();
	                __webpack_require__(111)("./" + name);
	                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
	                moment.locale(oldLocale);
	            } catch (e) { }
	        }
	        return locales[name];
	    }

	    // Return a moment from input, that is local/utc/utcOffset equivalent to
	    // model.
	    function makeAs(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff = (moment.isMoment(input) || isDate(input) ?
	                    +input : +moment(input)) - (+res);
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(+res._d + diff);
	            moment.updateOffset(res, false);
	            return res;
	        } else {
	            return moment(input).local();
	        }
	    }

	    /************************************
	        Locale
	    ************************************/


	    extend(Locale.prototype, {

	        set : function (config) {
	            var prop, i;
	            for (i in config) {
	                prop = config[i];
	                if (typeof prop === 'function') {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	            // Lenient ordinal parsing accepts just a number in addition to
	            // number + (possibly) stuff coming from _ordinalParseLenient.
	            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
	        },

	        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        months : function (m) {
	            return this._months[m.month()];
	        },

	        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        monthsShort : function (m) {
	            return this._monthsShort[m.month()];
	        },

	        monthsParse : function (monthName, format, strict) {
	            var i, mom, regex;

	            if (!this._monthsParse) {
	                this._monthsParse = [];
	                this._longMonthsParse = [];
	                this._shortMonthsParse = [];
	            }

	            for (i = 0; i < 12; i++) {
	                // make the regex if we don't have it already
	                mom = moment.utc([2000, i]);
	                if (strict && !this._longMonthsParse[i]) {
	                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	                }
	                if (!strict && !this._monthsParse[i]) {
	                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	                    return i;
	                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	                    return i;
	                } else if (!strict && this._monthsParse[i].test(monthName)) {
	                    return i;
	                }
	            }
	        },

	        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdays : function (m) {
	            return this._weekdays[m.day()];
	        },

	        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysShort : function (m) {
	            return this._weekdaysShort[m.day()];
	        },

	        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        weekdaysMin : function (m) {
	            return this._weekdaysMin[m.day()];
	        },

	        weekdaysParse : function (weekdayName) {
	            var i, mom, regex;

	            if (!this._weekdaysParse) {
	                this._weekdaysParse = [];
	            }

	            for (i = 0; i < 7; i++) {
	                // make the regex if we don't have it already
	                if (!this._weekdaysParse[i]) {
	                    mom = moment([2000, 1]).day(i);
	                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	                }
	                // test the regex
	                if (this._weekdaysParse[i].test(weekdayName)) {
	                    return i;
	                }
	            }
	        },

	        _longDateFormat : {
	            LTS : 'h:mm:ss A',
	            LT : 'h:mm A',
	            L : 'MM/DD/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY LT',
	            LLLL : 'dddd, MMMM D, YYYY LT'
	        },
	        longDateFormat : function (key) {
	            var output = this._longDateFormat[key];
	            if (!output && this._longDateFormat[key.toUpperCase()]) {
	                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
	                    return val.slice(1);
	                });
	                this._longDateFormat[key] = output;
	            }
	            return output;
	        },

	        isPM : function (input) {
	            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	            // Using charAt should be more compatible.
	            return ((input + '').toLowerCase().charAt(0) === 'p');
	        },

	        _meridiemParse : /[ap]\.?m?\.?/i,
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'pm' : 'PM';
	            } else {
	                return isLower ? 'am' : 'AM';
	            }
	        },


	        _calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        calendar : function (key, mom, now) {
	            var output = this._calendar[key];
	            return typeof output === 'function' ? output.apply(mom, [now]) : output;
	        },

	        _relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },

	        relativeTime : function (number, withoutSuffix, string, isFuture) {
	            var output = this._relativeTime[string];
	            return (typeof output === 'function') ?
	                output(number, withoutSuffix, string, isFuture) :
	                output.replace(/%d/i, number);
	        },

	        pastFuture : function (diff, output) {
	            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
	        },

	        ordinal : function (number) {
	            return this._ordinal.replace('%d', number);
	        },
	        _ordinal : '%d',
	        _ordinalParse : /\d{1,2}/,

	        preparse : function (string) {
	            return string;
	        },

	        postformat : function (string) {
	            return string;
	        },

	        week : function (mom) {
	            return weekOfYear(mom, this._week.dow, this._week.doy).week;
	        },

	        _week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        },

	        firstDayOfWeek : function () {
	            return this._week.dow;
	        },

	        firstDayOfYear : function () {
	            return this._week.doy;
	        },

	        _invalidDate: 'Invalid date',
	        invalidDate: function () {
	            return this._invalidDate;
	        }
	    });

	    /************************************
	        Formatting
	    ************************************/


	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens), i, length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '';
	            for (i = 0; i < length; i++) {
	                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());

	        if (!formatFunctions[format]) {
	            formatFunctions[format] = makeFormatFunction(format);
	        }

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }


	    /************************************
	        Parsing
	    ************************************/


	    // get the regex to find the next token
	    function getParseRegexForToken(token, config) {
	        var a, strict = config._strict;
	        switch (token) {
	        case 'Q':
	            return parseTokenOneDigit;
	        case 'DDDD':
	            return parseTokenThreeDigits;
	        case 'YYYY':
	        case 'GGGG':
	        case 'gggg':
	            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
	        case 'Y':
	        case 'G':
	        case 'g':
	            return parseTokenSignedNumber;
	        case 'YYYYYY':
	        case 'YYYYY':
	        case 'GGGGG':
	        case 'ggggg':
	            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
	        case 'S':
	            if (strict) {
	                return parseTokenOneDigit;
	            }
	            /* falls through */
	        case 'SS':
	            if (strict) {
	                return parseTokenTwoDigits;
	            }
	            /* falls through */
	        case 'SSS':
	            if (strict) {
	                return parseTokenThreeDigits;
	            }
	            /* falls through */
	        case 'DDD':
	            return parseTokenOneToThreeDigits;
	        case 'MMM':
	        case 'MMMM':
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            return parseTokenWord;
	        case 'a':
	        case 'A':
	            return config._locale._meridiemParse;
	        case 'x':
	            return parseTokenOffsetMs;
	        case 'X':
	            return parseTokenTimestampMs;
	        case 'Z':
	        case 'ZZ':
	            return parseTokenTimezone;
	        case 'T':
	            return parseTokenT;
	        case 'SSSS':
	            return parseTokenDigits;
	        case 'MM':
	        case 'DD':
	        case 'YY':
	        case 'GG':
	        case 'gg':
	        case 'HH':
	        case 'hh':
	        case 'mm':
	        case 'ss':
	        case 'ww':
	        case 'WW':
	            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
	        case 'M':
	        case 'D':
	        case 'd':
	        case 'H':
	        case 'h':
	        case 'm':
	        case 's':
	        case 'w':
	        case 'W':
	        case 'e':
	        case 'E':
	            return parseTokenOneOrTwoDigits;
	        case 'Do':
	            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
	        default :
	            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
	            return a;
	        }
	    }

	    function utcOffsetFromString(string) {
	        string = string || '';
	        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
	            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
	            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
	            minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return parts[0] === '+' ? minutes : -minutes;
	    }

	    // function to convert string input to date
	    function addTimeToArrayFromToken(token, input, config) {
	        var a, datePartArray = config._a;

	        switch (token) {
	        // QUARTER
	        case 'Q':
	            if (input != null) {
	                datePartArray[MONTH] = (toInt(input) - 1) * 3;
	            }
	            break;
	        // MONTH
	        case 'M' : // fall through to MM
	        case 'MM' :
	            if (input != null) {
	                datePartArray[MONTH] = toInt(input) - 1;
	            }
	            break;
	        case 'MMM' : // fall through to MMMM
	        case 'MMMM' :
	            a = config._locale.monthsParse(input, token, config._strict);
	            // if we didn't find a month name, mark the date as invalid.
	            if (a != null) {
	                datePartArray[MONTH] = a;
	            } else {
	                config._pf.invalidMonth = input;
	            }
	            break;
	        // DAY OF MONTH
	        case 'D' : // fall through to DD
	        case 'DD' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(input);
	            }
	            break;
	        case 'Do' :
	            if (input != null) {
	                datePartArray[DATE] = toInt(parseInt(
	                            input.match(/\d{1,2}/)[0], 10));
	            }
	            break;
	        // DAY OF YEAR
	        case 'DDD' : // fall through to DDDD
	        case 'DDDD' :
	            if (input != null) {
	                config._dayOfYear = toInt(input);
	            }

	            break;
	        // YEAR
	        case 'YY' :
	            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
	            break;
	        case 'YYYY' :
	        case 'YYYYY' :
	        case 'YYYYYY' :
	            datePartArray[YEAR] = toInt(input);
	            break;
	        // AM / PM
	        case 'a' : // fall through to A
	        case 'A' :
	            config._meridiem = input;
	            // config._isPm = config._locale.isPM(input);
	            break;
	        // HOUR
	        case 'h' : // fall through to hh
	        case 'hh' :
	            config._pf.bigHour = true;
	            /* falls through */
	        case 'H' : // fall through to HH
	        case 'HH' :
	            datePartArray[HOUR] = toInt(input);
	            break;
	        // MINUTE
	        case 'm' : // fall through to mm
	        case 'mm' :
	            datePartArray[MINUTE] = toInt(input);
	            break;
	        // SECOND
	        case 's' : // fall through to ss
	        case 'ss' :
	            datePartArray[SECOND] = toInt(input);
	            break;
	        // MILLISECOND
	        case 'S' :
	        case 'SS' :
	        case 'SSS' :
	        case 'SSSS' :
	            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
	            break;
	        // UNIX OFFSET (MILLISECONDS)
	        case 'x':
	            config._d = new Date(toInt(input));
	            break;
	        // UNIX TIMESTAMP WITH MS
	        case 'X':
	            config._d = new Date(parseFloat(input) * 1000);
	            break;
	        // TIMEZONE
	        case 'Z' : // fall through to ZZ
	        case 'ZZ' :
	            config._useUTC = true;
	            config._tzm = utcOffsetFromString(input);
	            break;
	        // WEEKDAY - human
	        case 'dd':
	        case 'ddd':
	        case 'dddd':
	            a = config._locale.weekdaysParse(input);
	            // if we didn't get a weekday name, mark the date as invalid
	            if (a != null) {
	                config._w = config._w || {};
	                config._w['d'] = a;
	            } else {
	                config._pf.invalidWeekday = input;
	            }
	            break;
	        // WEEK, WEEK DAY - numeric
	        case 'w':
	        case 'ww':
	        case 'W':
	        case 'WW':
	        case 'd':
	        case 'e':
	        case 'E':
	            token = token.substr(0, 1);
	            /* falls through */
	        case 'gggg':
	        case 'GGGG':
	        case 'GGGGG':
	            token = token.substr(0, 2);
	            if (input) {
	                config._w = config._w || {};
	                config._w[token] = toInt(input);
	            }
	            break;
	        case 'gg':
	        case 'GG':
	            config._w = config._w || {};
	            config._w[token] = moment.parseTwoDigitYear(input);
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
	            week = dfl(w.W, 1);
	            weekday = dfl(w.E, 1);
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
	            week = dfl(w.w, 1);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < dow) {
	                    ++week;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from begining of week
	                weekday = w.e + dow;
	            } else {
	                // default to begining of week
	                weekday = dow;
	            }
	        }
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function dateFromConfig(config) {
	        var i, date, input = [], currentDate, yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear) {
	            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

	            if (config._dayOfYear > daysInYear(yearToUse)) {
	                config._pf._overflowDayOfYear = true;
	            }

	            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (config._a[HOUR] === 24 &&
	                config._a[MINUTE] === 0 &&
	                config._a[SECOND] === 0 &&
	                config._a[MILLISECOND] === 0) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }
	    }

	    function dateFromObject(config) {
	        var normalizedInput;

	        if (config._d) {
	            return;
	        }

	        normalizedInput = normalizeObjectUnits(config._i);
	        config._a = [
	            normalizedInput.year,
	            normalizedInput.month,
	            normalizedInput.day || normalizedInput.date,
	            normalizedInput.hour,
	            normalizedInput.minute,
	            normalizedInput.second,
	            normalizedInput.millisecond
	        ];

	        dateFromConfig(config);
	    }

	    function currentDateArray(config) {
	        var now = new Date();
	        if (config._useUTC) {
	            return [
	                now.getUTCFullYear(),
	                now.getUTCMonth(),
	                now.getUTCDate()
	            ];
	        } else {
	            return [now.getFullYear(), now.getMonth(), now.getDate()];
	        }
	    }

	    // date from string and format string
	    function makeDateFromStringAndFormat(config) {
	        if (config._f === moment.ISO_8601) {
	            parseISO(config);
	            return;
	        }

	        config._a = [];
	        config._pf.empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i, parsedInput, tokens, token, skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0;

	        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	        for (i = 0; i < tokens.length; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    config._pf.unusedInput.push(skipped);
	                }
	                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    config._pf.empty = false;
	                }
	                else {
	                    config._pf.unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            }
	            else if (config._strict && !parsedInput) {
	                config._pf.unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            config._pf.unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
	            config._pf.bigHour = undefined;
	        }
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR],
	                config._meridiem);
	        dateFromConfig(config);
	        checkOverflow(config);
	    }

	    function unescapeFormat(s) {
	        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	            return p1 || p2 || p3 || p4;
	        });
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function regexpEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    // date from string and array of format strings
	    function makeDateFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,

	            scoreToBeat,
	            i,
	            currentScore;

	        if (config._f.length === 0) {
	            config._pf.invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < config._f.length; i++) {
	            currentScore = 0;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._pf = defaultParsingFlags();
	            tempConfig._f = config._f[i];
	            makeDateFromStringAndFormat(tempConfig);

	            if (!isValid(tempConfig)) {
	                continue;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += tempConfig._pf.charsLeftOver;

	            //or tokens
	            currentScore += tempConfig._pf.unusedTokens.length * 10;

	            tempConfig._pf.score = currentScore;

	            if (scoreToBeat == null || currentScore < scoreToBeat) {
	                scoreToBeat = currentScore;
	                bestMoment = tempConfig;
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    // date from iso format
	    function parseISO(config) {
	        var i, l,
	            string = config._i,
	            match = isoRegex.exec(string);

	        if (match) {
	            config._pf.iso = true;
	            for (i = 0, l = isoDates.length; i < l; i++) {
	                if (isoDates[i][1].exec(string)) {
	                    // match[5] should be 'T' or undefined
	                    config._f = isoDates[i][0] + (match[6] || ' ');
	                    break;
	                }
	            }
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(string)) {
	                    config._f += isoTimes[i][0];
	                    break;
	                }
	            }
	            if (string.match(parseTokenTimezone)) {
	                config._f += 'Z';
	            }
	            makeDateFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from iso format or fallback
	    function makeDateFromString(config) {
	        parseISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	            moment.createFromInputFallback(config);
	        }
	    }

	    function map(arr, fn) {
	        var res = [], i;
	        for (i = 0; i < arr.length; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function makeDateFromInput(config) {
	        var input = config._i, matched;
	        if (input === undefined) {
	            config._d = new Date();
	        } else if (isDate(input)) {
	            config._d = new Date(+input);
	        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
	            config._d = new Date(+matched[1]);
	        } else if (typeof input === 'string') {
	            makeDateFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            dateFromConfig(config);
	        } else if (typeof(input) === 'object') {
	            dateFromObject(config);
	        } else if (typeof(input) === 'number') {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            moment.createFromInputFallback(config);
	        }
	    }

	    function makeDate(y, m, d, h, M, s, ms) {
	        //can't just apply() to create a date:
	        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	        var date = new Date(y, m, d, h, M, s, ms);

	        //the date constructor doesn't accept years < 1970
	        if (y < 1970) {
	            date.setFullYear(y);
	        }
	        return date;
	    }

	    function makeUTCDate(y) {
	        var date = new Date(Date.UTC.apply(null, arguments));
	        if (y < 1970) {
	            date.setUTCFullYear(y);
	        }
	        return date;
	    }

	    function parseWeekday(input, locale) {
	        if (typeof input === 'string') {
	            if (!isNaN(input)) {
	                input = parseInt(input, 10);
	            }
	            else {
	                input = locale.weekdaysParse(input);
	                if (typeof input !== 'number') {
	                    return null;
	                }
	            }
	        }
	        return input;
	    }

	    /************************************
	        Relative Time
	    ************************************/


	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function relativeTime(posNegDuration, withoutSuffix, locale) {
	        var duration = moment.duration(posNegDuration).abs(),
	            seconds = round(duration.as('s')),
	            minutes = round(duration.as('m')),
	            hours = round(duration.as('h')),
	            days = round(duration.as('d')),
	            months = round(duration.as('M')),
	            years = round(duration.as('y')),

	            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
	                minutes === 1 && ['m'] ||
	                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
	                hours === 1 && ['h'] ||
	                hours < relativeTimeThresholds.h && ['hh', hours] ||
	                days === 1 && ['d'] ||
	                days < relativeTimeThresholds.d && ['dd', days] ||
	                months === 1 && ['M'] ||
	                months < relativeTimeThresholds.M && ['MM', months] ||
	                years === 1 && ['y'] || ['yy', years];

	        args[2] = withoutSuffix;
	        args[3] = +posNegDuration > 0;
	        args[4] = locale;
	        return substituteTimeAgo.apply({}, args);
	    }


	    /************************************
	        Week of Year
	    ************************************/


	    // firstDayOfWeek       0 = sun, 6 = sat
	    //                      the day of the week that starts the week
	    //                      (usually sunday or monday)
	    // firstDayOfWeekOfYear 0 = sun, 6 = sat
	    //                      the first week is the week that contains the first
	    //                      of this day of the week
	    //                      (eg. ISO weeks use thursday (4))
	    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
	        var end = firstDayOfWeekOfYear - firstDayOfWeek,
	            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
	            adjustedMoment;


	        if (daysToDayOfWeek > end) {
	            daysToDayOfWeek -= 7;
	        }

	        if (daysToDayOfWeek < end - 7) {
	            daysToDayOfWeek += 7;
	        }

	        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
	        return {
	            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
	            year: adjustedMoment.year()
	        };
	    }

	    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
	        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

	        d = d === 0 ? 7 : d;
	        weekday = weekday != null ? weekday : firstDayOfWeek;
	        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
	        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

	        return {
	            year: dayOfYear > 0 ? year : year - 1,
	            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
	        };
	    }

	    /************************************
	        Top Level Functions
	    ************************************/

	    function makeMoment(config) {
	        var input = config._i,
	            format = config._f,
	            res;

	        config._locale = config._locale || moment.localeData(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return moment.invalid({nullInput: true});
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (moment.isMoment(input)) {
	            return new Moment(input, true);
	        } else if (format) {
	            if (isArray(format)) {
	                makeDateFromStringAndArray(config);
	            } else {
	                makeDateFromStringAndFormat(config);
	            }
	        } else {
	            makeDateFromInput(config);
	        }

	        res = new Moment(config);
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    moment = function (input, format, locale, strict) {
	        var c;

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c = {};
	        c._isAMomentObject = true;
	        c._i = input;
	        c._f = format;
	        c._l = locale;
	        c._strict = strict;
	        c._isUTC = false;
	        c._pf = defaultParsingFlags();

	        return makeMoment(c);
	    };

	    moment.suppressDeprecationWarnings = false;

	    moment.createFromInputFallback = deprecate(
	        'moment construction falls back to js Date. This is ' +
	        'discouraged and will be removed in upcoming major ' +
	        'release. Please refer to ' +
	        'https://github.com/moment/moment/issues/1407 for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return moment();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    moment.min = function () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    };

	    moment.max = function () {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    };

	    // creating with utc
	    moment.utc = function (input, format, locale, strict) {
	        var c;

	        if (typeof(locale) === 'boolean') {
	            strict = locale;
	            locale = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c = {};
	        c._isAMomentObject = true;
	        c._useUTC = true;
	        c._isUTC = true;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;
	        c._pf = defaultParsingFlags();

	        return makeMoment(c).utc();
	    };

	    // creating with unix timestamp (in seconds)
	    moment.unix = function (input) {
	        return moment(input * 1000);
	    };

	    // duration
	    moment.duration = function (input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            parseIso,
	            diffRes;

	        if (moment.isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months
	            };
	        } else if (typeof input === 'number') {
	            duration = {};
	            if (key) {
	                duration[key] = input;
	            } else {
	                duration.milliseconds = input;
	            }
	        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(match[MILLISECOND]) * sign
	            };
	        } else if (!!(match = isoDurationRegex.exec(input))) {
	            sign = (match[1] === '-') ? -1 : 1;
	            parseIso = function (inp) {
	                // We'd normally use ~~inp for this, but unfortunately it also
	                // converts floats to ints.
	                // inp may be undefined, so careful calling replace on it.
	                var res = inp && parseFloat(inp.replace(',', '.'));
	                // apply sign while we're at it
	                return (isNaN(res) ? 0 : res) * sign;
	            };
	            duration = {
	                y: parseIso(match[2]),
	                M: parseIso(match[3]),
	                d: parseIso(match[4]),
	                h: parseIso(match[5]),
	                m: parseIso(match[6]),
	                s: parseIso(match[7]),
	                w: parseIso(match[8])
	            };
	        } else if (duration == null) {// checks for null or undefined
	            duration = {};
	        } else if (typeof duration === 'object' &&
	                ('from' in duration || 'to' in duration)) {
	            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        return ret;
	    };

	    // version number
	    moment.version = VERSION;

	    // default format
	    moment.defaultFormat = isoFormat;

	    // constant that refers to the ISO standard
	    moment.ISO_8601 = function () {};

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    moment.momentProperties = momentProperties;

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    moment.updateOffset = function () {};

	    // This function allows you to set a threshold for relative time strings
	    moment.relativeTimeThreshold = function (threshold, limit) {
	        if (relativeTimeThresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return relativeTimeThresholds[threshold];
	        }
	        relativeTimeThresholds[threshold] = limit;
	        return true;
	    };

	    moment.lang = deprecate(
	        'moment.lang is deprecated. Use moment.locale instead.',
	        function (key, value) {
	            return moment.locale(key, value);
	        }
	    );

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    moment.locale = function (key, values) {
	        var data;
	        if (key) {
	            if (typeof(values) !== 'undefined') {
	                data = moment.defineLocale(key, values);
	            }
	            else {
	                data = moment.localeData(key);
	            }

	            if (data) {
	                moment.duration._locale = moment._locale = data;
	            }
	        }

	        return moment._locale._abbr;
	    };

	    moment.defineLocale = function (name, values) {
	        if (values !== null) {
	            values.abbr = name;
	            if (!locales[name]) {
	                locales[name] = new Locale();
	            }
	            locales[name].set(values);

	            // backwards compat for now: also set the locale
	            moment.locale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    };

	    moment.langData = deprecate(
	        'moment.langData is deprecated. Use moment.localeData instead.',
	        function (key) {
	            return moment.localeData(key);
	        }
	    );

	    // returns locale data
	    moment.localeData = function (key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return moment._locale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    };

	    // compare moment object
	    moment.isMoment = function (obj) {
	        return obj instanceof Moment ||
	            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
	    };

	    // for typechecking Duration objects
	    moment.isDuration = function (obj) {
	        return obj instanceof Duration;
	    };

	    for (i = lists.length - 1; i >= 0; --i) {
	        makeList(lists[i]);
	    }

	    moment.normalizeUnits = function (units) {
	        return normalizeUnits(units);
	    };

	    moment.invalid = function (flags) {
	        var m = moment.utc(NaN);
	        if (flags != null) {
	            extend(m._pf, flags);
	        }
	        else {
	            m._pf.userInvalidated = true;
	        }

	        return m;
	    };

	    moment.parseZone = function () {
	        return moment.apply(null, arguments).parseZone();
	    };

	    moment.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    moment.isDate = isDate;

	    /************************************
	        Moment Prototype
	    ************************************/


	    extend(moment.fn = Moment.prototype, {

	        clone : function () {
	            return moment(this);
	        },

	        valueOf : function () {
	            return +this._d - ((this._offset || 0) * 60000);
	        },

	        unix : function () {
	            return Math.floor(+this / 1000);
	        },

	        toString : function () {
	            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	        },

	        toDate : function () {
	            return this._offset ? new Date(+this) : this._d;
	        },

	        toISOString : function () {
	            var m = moment(this).utc();
	            if (0 < m.year() && m.year() <= 9999) {
	                if ('function' === typeof Date.prototype.toISOString) {
	                    // native implementation is ~50x faster, use it when we can
	                    return this.toDate().toISOString();
	                } else {
	                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	                }
	            } else {
	                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	            }
	        },

	        toArray : function () {
	            var m = this;
	            return [
	                m.year(),
	                m.month(),
	                m.date(),
	                m.hours(),
	                m.minutes(),
	                m.seconds(),
	                m.milliseconds()
	            ];
	        },

	        isValid : function () {
	            return isValid(this);
	        },

	        isDSTShifted : function () {
	            if (this._a) {
	                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
	            }

	            return false;
	        },

	        parsingFlags : function () {
	            return extend({}, this._pf);
	        },

	        invalidAt: function () {
	            return this._pf.overflow;
	        },

	        utc : function (keepLocalTime) {
	            return this.utcOffset(0, keepLocalTime);
	        },

	        local : function (keepLocalTime) {
	            if (this._isUTC) {
	                this.utcOffset(0, keepLocalTime);
	                this._isUTC = false;

	                if (keepLocalTime) {
	                    this.subtract(this._dateUtcOffset(), 'm');
	                }
	            }
	            return this;
	        },

	        format : function (inputString) {
	            var output = formatMoment(this, inputString || moment.defaultFormat);
	            return this.localeData().postformat(output);
	        },

	        add : createAdder(1, 'add'),

	        subtract : createAdder(-1, 'subtract'),

	        diff : function (input, units, asFloat) {
	            var that = makeAs(input, this),
	                zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4,
	                anchor, diff, output, daysAdjust;

	            units = normalizeUnits(units);

	            if (units === 'year' || units === 'month' || units === 'quarter') {
	                output = monthDiff(this, that);
	                if (units === 'quarter') {
	                    output = output / 3;
	                } else if (units === 'year') {
	                    output = output / 12;
	                }
	            } else {
	                diff = this - that;
	                output = units === 'second' ? diff / 1e3 : // 1000
	                    units === 'minute' ? diff / 6e4 : // 1000 * 60
	                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
	                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	                    diff;
	            }
	            return asFloat ? output : absRound(output);
	        },

	        from : function (time, withoutSuffix) {
	            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	        },

	        fromNow : function (withoutSuffix) {
	            return this.from(moment(), withoutSuffix);
	        },

	        calendar : function (time) {
	            // We want to compare the start of today, vs this.
	            // Getting start-of-today depends on whether we're locat/utc/offset
	            // or not.
	            var now = time || moment(),
	                sod = makeAs(now, this).startOf('day'),
	                diff = this.diff(sod, 'days', true),
	                format = diff < -6 ? 'sameElse' :
	                    diff < -1 ? 'lastWeek' :
	                    diff < 0 ? 'lastDay' :
	                    diff < 1 ? 'sameDay' :
	                    diff < 2 ? 'nextDay' :
	                    diff < 7 ? 'nextWeek' : 'sameElse';
	            return this.format(this.localeData().calendar(format, this, moment(now)));
	        },

	        isLeapYear : function () {
	            return isLeapYear(this.year());
	        },

	        isDST : function () {
	            return (this.utcOffset() > this.clone().month(0).utcOffset() ||
	                this.utcOffset() > this.clone().month(5).utcOffset());
	        },

	        day : function (input) {
	            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	            if (input != null) {
	                input = parseWeekday(input, this.localeData());
	                return this.add(input - day, 'd');
	            } else {
	                return day;
	            }
	        },

	        month : makeAccessor('Month', true),

	        startOf : function (units) {
	            units = normalizeUnits(units);
	            // the following switch intentionally omits break keywords
	            // to utilize falling through the cases.
	            switch (units) {
	            case 'year':
	                this.month(0);
	                /* falls through */
	            case 'quarter':
	            case 'month':
	                this.date(1);
	                /* falls through */
	            case 'week':
	            case 'isoWeek':
	            case 'day':
	                this.hours(0);
	                /* falls through */
	            case 'hour':
	                this.minutes(0);
	                /* falls through */
	            case 'minute':
	                this.seconds(0);
	                /* falls through */
	            case 'second':
	                this.milliseconds(0);
	                /* falls through */
	            }

	            // weeks are a special case
	            if (units === 'week') {
	                this.weekday(0);
	            } else if (units === 'isoWeek') {
	                this.isoWeekday(1);
	            }

	            // quarters are also special
	            if (units === 'quarter') {
	                this.month(Math.floor(this.month() / 3) * 3);
	            }

	            return this;
	        },

	        endOf: function (units) {
	            units = normalizeUnits(units);
	            if (units === undefined || units === 'millisecond') {
	                return this;
	            }
	            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	        },

	        isAfter: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this > +input;
	            } else {
	                inputMs = moment.isMoment(input) ? +input : +moment(input);
	                return inputMs < +this.clone().startOf(units);
	            }
	        },

	        isBefore: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this < +input;
	            } else {
	                inputMs = moment.isMoment(input) ? +input : +moment(input);
	                return +this.clone().endOf(units) < inputMs;
	            }
	        },

	        isBetween: function (from, to, units) {
	            return this.isAfter(from, units) && this.isBefore(to, units);
	        },

	        isSame: function (input, units) {
	            var inputMs;
	            units = normalizeUnits(units || 'millisecond');
	            if (units === 'millisecond') {
	                input = moment.isMoment(input) ? input : moment(input);
	                return +this === +input;
	            } else {
	                inputMs = +moment(input);
	                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
	            }
	        },

	        min: deprecate(
	                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
	                 function (other) {
	                     other = moment.apply(null, arguments);
	                     return other < this ? this : other;
	                 }
	         ),

	        max: deprecate(
	                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
	                function (other) {
	                    other = moment.apply(null, arguments);
	                    return other > this ? this : other;
	                }
	        ),

	        zone : deprecate(
	                'moment().zone is deprecated, use moment().utcOffset instead. ' +
	                'https://github.com/moment/moment/issues/1779',
	                function (input, keepLocalTime) {
	                    if (input != null) {
	                        if (typeof input !== 'string') {
	                            input = -input;
	                        }

	                        this.utcOffset(input, keepLocalTime);

	                        return this;
	                    } else {
	                        return -this.utcOffset();
	                    }
	                }
	        ),

	        // keepLocalTime = true means only change the timezone, without
	        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	        // +0200, so we adjust the time as needed, to be valid.
	        //
	        // Keeping the time actually adds/subtracts (one hour)
	        // from the actual represented time. That is why we call updateOffset
	        // a second time. In case it wants us to change the offset again
	        // _changeInProgress == true case, then we have to adjust, because
	        // there is no such time in the given timezone.
	        utcOffset : function (input, keepLocalTime) {
	            var offset = this._offset || 0,
	                localAdjust;
	            if (input != null) {
	                if (typeof input === 'string') {
	                    input = utcOffsetFromString(input);
	                }
	                if (Math.abs(input) < 16) {
	                    input = input * 60;
	                }
	                if (!this._isUTC && keepLocalTime) {
	                    localAdjust = this._dateUtcOffset();
	                }
	                this._offset = input;
	                this._isUTC = true;
	                if (localAdjust != null) {
	                    this.add(localAdjust, 'm');
	                }
	                if (offset !== input) {
	                    if (!keepLocalTime || this._changeInProgress) {
	                        addOrSubtractDurationFromMoment(this,
	                                moment.duration(input - offset, 'm'), 1, false);
	                    } else if (!this._changeInProgress) {
	                        this._changeInProgress = true;
	                        moment.updateOffset(this, true);
	                        this._changeInProgress = null;
	                    }
	                }

	                return this;
	            } else {
	                return this._isUTC ? offset : this._dateUtcOffset();
	            }
	        },

	        isLocal : function () {
	            return !this._isUTC;
	        },

	        isUtcOffset : function () {
	            return this._isUTC;
	        },

	        isUtc : function () {
	            return this._isUTC && this._offset === 0;
	        },

	        zoneAbbr : function () {
	            return this._isUTC ? 'UTC' : '';
	        },

	        zoneName : function () {
	            return this._isUTC ? 'Coordinated Universal Time' : '';
	        },

	        parseZone : function () {
	            if (this._tzm) {
	                this.utcOffset(this._tzm);
	            } else if (typeof this._i === 'string') {
	                this.utcOffset(utcOffsetFromString(this._i));
	            }
	            return this;
	        },

	        hasAlignedHourOffset : function (input) {
	            if (!input) {
	                input = 0;
	            }
	            else {
	                input = moment(input).utcOffset();
	            }

	            return (this.utcOffset() - input) % 60 === 0;
	        },

	        daysInMonth : function () {
	            return daysInMonth(this.year(), this.month());
	        },

	        dayOfYear : function (input) {
	            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
	            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	        },

	        quarter : function (input) {
	            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	        },

	        weekYear : function (input) {
	            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
	            return input == null ? year : this.add((input - year), 'y');
	        },

	        isoWeekYear : function (input) {
	            var year = weekOfYear(this, 1, 4).year;
	            return input == null ? year : this.add((input - year), 'y');
	        },

	        week : function (input) {
	            var week = this.localeData().week(this);
	            return input == null ? week : this.add((input - week) * 7, 'd');
	        },

	        isoWeek : function (input) {
	            var week = weekOfYear(this, 1, 4).week;
	            return input == null ? week : this.add((input - week) * 7, 'd');
	        },

	        weekday : function (input) {
	            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	            return input == null ? weekday : this.add(input - weekday, 'd');
	        },

	        isoWeekday : function (input) {
	            // behaves the same as moment#day except
	            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	            // as a setter, sunday should belong to the previous week.
	            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
	        },

	        isoWeeksInYear : function () {
	            return weeksInYear(this.year(), 1, 4);
	        },

	        weeksInYear : function () {
	            var weekInfo = this.localeData()._week;
	            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	        },

	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units]();
	        },

	        set : function (units, value) {
	            var unit;
	            if (typeof units === 'object') {
	                for (unit in units) {
	                    this.set(unit, units[unit]);
	                }
	            }
	            else {
	                units = normalizeUnits(units);
	                if (typeof this[units] === 'function') {
	                    this[units](value);
	                }
	            }
	            return this;
	        },

	        // If passed a locale key, it will set the locale for this
	        // instance.  Otherwise, it will return the locale configuration
	        // variables for this instance.
	        locale : function (key) {
	            var newLocaleData;

	            if (key === undefined) {
	                return this._locale._abbr;
	            } else {
	                newLocaleData = moment.localeData(key);
	                if (newLocaleData != null) {
	                    this._locale = newLocaleData;
	                }
	                return this;
	            }
	        },

	        lang : deprecate(
	            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	            function (key) {
	                if (key === undefined) {
	                    return this.localeData();
	                } else {
	                    return this.locale(key);
	                }
	            }
	        ),

	        localeData : function () {
	            return this._locale;
	        },

	        _dateUtcOffset : function () {
	            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	            // https://github.com/moment/moment/pull/1871
	            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;
	        }

	    });

	    function rawMonthSetter(mom, value) {
	        var dayOfMonth;

	        // TODO: Move this out of here!
	        if (typeof value === 'string') {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (typeof value !== 'number') {
	                return mom;
	            }
	        }

	        dayOfMonth = Math.min(mom.date(),
	                daysInMonth(mom.year(), value));
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	        return mom;
	    }

	    function rawGetter(mom, unit) {
	        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
	    }

	    function rawSetter(mom, unit, value) {
	        if (unit === 'Month') {
	            return rawMonthSetter(mom, value);
	        } else {
	            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	        }
	    }

	    function makeAccessor(unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                rawSetter(this, unit, value);
	                moment.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return rawGetter(this, unit);
	            }
	        };
	    }

	    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
	    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
	    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
	    // Setting the hour should keep the time, because the user explicitly
	    // specified which hour he wants. So trying to maintain the same hour (in
	    // a new timezone) makes sense. Adding/subtracting hours does not follow
	    // this rule.
	    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
	    // moment.fn.month is defined separately
	    moment.fn.date = makeAccessor('Date', true);
	    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
	    moment.fn.year = makeAccessor('FullYear', true);
	    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

	    // add plural methods
	    moment.fn.days = moment.fn.day;
	    moment.fn.months = moment.fn.month;
	    moment.fn.weeks = moment.fn.week;
	    moment.fn.isoWeeks = moment.fn.isoWeek;
	    moment.fn.quarters = moment.fn.quarter;

	    // add aliased format methods
	    moment.fn.toJSON = moment.fn.toISOString;

	    // alias isUtc for dev-friendliness
	    moment.fn.isUTC = moment.fn.isUtc;

	    /************************************
	        Duration Prototype
	    ************************************/


	    function daysToYears (days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        return days * 400 / 146097;
	    }

	    function yearsToDays (years) {
	        // years * 365 + absRound(years / 4) -
	        //     absRound(years / 100) + absRound(years / 400);
	        return years * 146097 / 400;
	    }

	    extend(moment.duration.fn = Duration.prototype, {

	        _bubble : function () {
	            var milliseconds = this._milliseconds,
	                days = this._days,
	                months = this._months,
	                data = this._data,
	                seconds, minutes, hours, years = 0;

	            // The following code bubbles up values, see the tests for
	            // examples of what that means.
	            data.milliseconds = milliseconds % 1000;

	            seconds = absRound(milliseconds / 1000);
	            data.seconds = seconds % 60;

	            minutes = absRound(seconds / 60);
	            data.minutes = minutes % 60;

	            hours = absRound(minutes / 60);
	            data.hours = hours % 24;

	            days += absRound(hours / 24);

	            // Accurately convert days to years, assume start from year 0.
	            years = absRound(daysToYears(days));
	            days -= absRound(yearsToDays(years));

	            // 30 days to a month
	            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
	            months += absRound(days / 30);
	            days %= 30;

	            // 12 months -> 1 year
	            years += absRound(months / 12);
	            months %= 12;

	            data.days = days;
	            data.months = months;
	            data.years = years;
	        },

	        abs : function () {
	            this._milliseconds = Math.abs(this._milliseconds);
	            this._days = Math.abs(this._days);
	            this._months = Math.abs(this._months);

	            this._data.milliseconds = Math.abs(this._data.milliseconds);
	            this._data.seconds = Math.abs(this._data.seconds);
	            this._data.minutes = Math.abs(this._data.minutes);
	            this._data.hours = Math.abs(this._data.hours);
	            this._data.months = Math.abs(this._data.months);
	            this._data.years = Math.abs(this._data.years);

	            return this;
	        },

	        weeks : function () {
	            return absRound(this.days() / 7);
	        },

	        valueOf : function () {
	            return this._milliseconds +
	              this._days * 864e5 +
	              (this._months % 12) * 2592e6 +
	              toInt(this._months / 12) * 31536e6;
	        },

	        humanize : function (withSuffix) {
	            var output = relativeTime(this, !withSuffix, this.localeData());

	            if (withSuffix) {
	                output = this.localeData().pastFuture(+this, output);
	            }

	            return this.localeData().postformat(output);
	        },

	        add : function (input, val) {
	            // supports only 2.0-style add(1, 's') or add(moment)
	            var dur = moment.duration(input, val);

	            this._milliseconds += dur._milliseconds;
	            this._days += dur._days;
	            this._months += dur._months;

	            this._bubble();

	            return this;
	        },

	        subtract : function (input, val) {
	            var dur = moment.duration(input, val);

	            this._milliseconds -= dur._milliseconds;
	            this._days -= dur._days;
	            this._months -= dur._months;

	            this._bubble();

	            return this;
	        },

	        get : function (units) {
	            units = normalizeUnits(units);
	            return this[units.toLowerCase() + 's']();
	        },

	        as : function (units) {
	            var days, months;
	            units = normalizeUnits(units);

	            if (units === 'month' || units === 'year') {
	                days = this._days + this._milliseconds / 864e5;
	                months = this._months + daysToYears(days) * 12;
	                return units === 'month' ? months : months / 12;
	            } else {
	                // handle milliseconds separately because of floating point math errors (issue #1867)
	                days = this._days + Math.round(yearsToDays(this._months / 12));
	                switch (units) {
	                    case 'week': return days / 7 + this._milliseconds / 6048e5;
	                    case 'day': return days + this._milliseconds / 864e5;
	                    case 'hour': return days * 24 + this._milliseconds / 36e5;
	                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
	                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
	                    // Math.floor prevents floating point math errors here
	                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
	                    default: throw new Error('Unknown unit ' + units);
	                }
	            }
	        },

	        lang : moment.fn.lang,
	        locale : moment.fn.locale,

	        toIsoString : deprecate(
	            'toIsoString() is deprecated. Please use toISOString() instead ' +
	            '(notice the capitals)',
	            function () {
	                return this.toISOString();
	            }
	        ),

	        toISOString : function () {
	            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	            var years = Math.abs(this.years()),
	                months = Math.abs(this.months()),
	                days = Math.abs(this.days()),
	                hours = Math.abs(this.hours()),
	                minutes = Math.abs(this.minutes()),
	                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

	            if (!this.asSeconds()) {
	                // this is the same as C#'s (Noda) and python (isodate)...
	                // but not other JS (goog.date)
	                return 'P0D';
	            }

	            return (this.asSeconds() < 0 ? '-' : '') +
	                'P' +
	                (years ? years + 'Y' : '') +
	                (months ? months + 'M' : '') +
	                (days ? days + 'D' : '') +
	                ((hours || minutes || seconds) ? 'T' : '') +
	                (hours ? hours + 'H' : '') +
	                (minutes ? minutes + 'M' : '') +
	                (seconds ? seconds + 'S' : '');
	        },

	        localeData : function () {
	            return this._locale;
	        },

	        toJSON : function () {
	            return this.toISOString();
	        }
	    });

	    moment.duration.fn.toString = moment.duration.fn.toISOString;

	    function makeDurationGetter(name) {
	        moment.duration.fn[name] = function () {
	            return this._data[name];
	        };
	    }

	    for (i in unitMillisecondFactors) {
	        if (hasOwnProp(unitMillisecondFactors, i)) {
	            makeDurationGetter(i.toLowerCase());
	        }
	    }

	    moment.duration.fn.asMilliseconds = function () {
	        return this.as('ms');
	    };
	    moment.duration.fn.asSeconds = function () {
	        return this.as('s');
	    };
	    moment.duration.fn.asMinutes = function () {
	        return this.as('m');
	    };
	    moment.duration.fn.asHours = function () {
	        return this.as('h');
	    };
	    moment.duration.fn.asDays = function () {
	        return this.as('d');
	    };
	    moment.duration.fn.asWeeks = function () {
	        return this.as('weeks');
	    };
	    moment.duration.fn.asMonths = function () {
	        return this.as('M');
	    };
	    moment.duration.fn.asYears = function () {
	        return this.as('y');
	    };

	    /************************************
	        Default Locale
	    ************************************/


	    // Set default locale, other locale will inherit from English.
	    moment.locale('en', {
	        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (toInt(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });

	    /* EMBED_LOCALES */

	    /************************************
	        Exposing Moment
	    ************************************/

	    function makeGlobal(shouldDeprecate) {
	        /*global ender:false */
	        if (typeof ender !== 'undefined') {
	            return;
	        }
	        oldGlobalMoment = globalScope.moment;
	        if (shouldDeprecate) {
	            globalScope.moment = deprecate(
	                    'Accessing Moment through the global scope is ' +
	                    'deprecated, and will be removed in an upcoming ' +
	                    'release.',
	                    moment);
	        } else {
	            globalScope.moment = moment;
	        }
	    }

	    // CommonJS module is defined
	    if (hasModule) {
	        module.exports = moment;
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	            if (module.config && module.config() && module.config().noGlobal === true) {
	                // release the global variable
	                globalScope.moment = oldGlobalMoment;
	            }

	            return moment;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        makeGlobal(true);
	    } else {
	        makeGlobal();
	    }
	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(235)(module)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
	/**
	 * Copyright 2013 Craig Campbell
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * Mousetrap is a simple keyboard shortcut library for Javascript with
	 * no external dependencies
	 *
	 * @version 1.4.6
	 * @url craig.is/killing/mice
	 */
	(function(window, document, undefined) {

	    /**
	     * mapping of special keycodes to their corresponding keys
	     *
	     * everything in this dictionary cannot use keypress events
	     * so it has to be here to map to the correct keycodes for
	     * keyup/keydown events
	     *
	     * @type {Object}
	     */
	    var _MAP = {
	            8: 'backspace',
	            9: 'tab',
	            13: 'enter',
	            16: 'shift',
	            17: 'ctrl',
	            18: 'alt',
	            20: 'capslock',
	            27: 'esc',
	            32: 'space',
	            33: 'pageup',
	            34: 'pagedown',
	            35: 'end',
	            36: 'home',
	            37: 'left',
	            38: 'up',
	            39: 'right',
	            40: 'down',
	            45: 'ins',
	            46: 'del',
	            91: 'meta',
	            93: 'meta',
	            224: 'meta'
	        },

	        /**
	         * mapping for special characters so they can support
	         *
	         * this dictionary is only used incase you want to bind a
	         * keyup or keydown event to one of these keys
	         *
	         * @type {Object}
	         */
	        _KEYCODE_MAP = {
	            106: '*',
	            107: '+',
	            109: '-',
	            110: '.',
	            111 : '/',
	            186: ';',
	            187: '=',
	            188: ',',
	            189: '-',
	            190: '.',
	            191: '/',
	            192: '`',
	            219: '[',
	            220: '\\',
	            221: ']',
	            222: '\''
	        },

	        /**
	         * this is a mapping of keys that require shift on a US keypad
	         * back to the non shift equivelents
	         *
	         * this is so you can use keyup events with these keys
	         *
	         * note that this will only work reliably on US keyboards
	         *
	         * @type {Object}
	         */
	        _SHIFT_MAP = {
	            '~': '`',
	            '!': '1',
	            '@': '2',
	            '#': '3',
	            '$': '4',
	            '%': '5',
	            '^': '6',
	            '&': '7',
	            '*': '8',
	            '(': '9',
	            ')': '0',
	            '_': '-',
	            '+': '=',
	            ':': ';',
	            '\"': '\'',
	            '<': ',',
	            '>': '.',
	            '?': '/',
	            '|': '\\'
	        },

	        /**
	         * this is a list of special strings you can use to map
	         * to modifier keys when you specify your keyboard shortcuts
	         *
	         * @type {Object}
	         */
	        _SPECIAL_ALIASES = {
	            'option': 'alt',
	            'command': 'meta',
	            'return': 'enter',
	            'escape': 'esc',
	            'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
	        },

	        /**
	         * variable to store the flipped version of _MAP from above
	         * needed to check if we should use keypress or not when no action
	         * is specified
	         *
	         * @type {Object|undefined}
	         */
	        _REVERSE_MAP,

	        /**
	         * a list of all the callbacks setup via Mousetrap.bind()
	         *
	         * @type {Object}
	         */
	        _callbacks = {},

	        /**
	         * direct map of string combinations to callbacks used for trigger()
	         *
	         * @type {Object}
	         */
	        _directMap = {},

	        /**
	         * keeps track of what level each sequence is at since multiple
	         * sequences can start out with the same sequence
	         *
	         * @type {Object}
	         */
	        _sequenceLevels = {},

	        /**
	         * variable to store the setTimeout call
	         *
	         * @type {null|number}
	         */
	        _resetTimer,

	        /**
	         * temporary state where we will ignore the next keyup
	         *
	         * @type {boolean|string}
	         */
	        _ignoreNextKeyup = false,

	        /**
	         * temporary state where we will ignore the next keypress
	         *
	         * @type {boolean}
	         */
	        _ignoreNextKeypress = false,

	        /**
	         * are we currently inside of a sequence?
	         * type of action ("keyup" or "keydown" or "keypress") or false
	         *
	         * @type {boolean|string}
	         */
	        _nextExpectedAction = false;

	    /**
	     * loop through the f keys, f1 to f19 and add them to the map
	     * programatically
	     */
	    for (var i = 1; i < 20; ++i) {
	        _MAP[111 + i] = 'f' + i;
	    }

	    /**
	     * loop through to map numbers on the numeric keypad
	     */
	    for (i = 0; i <= 9; ++i) {
	        _MAP[i + 96] = i;
	    }

	    /**
	     * cross browser add event method
	     *
	     * @param {Element|HTMLDocument} object
	     * @param {string} type
	     * @param {Function} callback
	     * @returns void
	     */
	    function _addEvent(object, type, callback) {
	        if (object.addEventListener) {
	            object.addEventListener(type, callback, false);
	            return;
	        }

	        object.attachEvent('on' + type, callback);
	    }

	    /**
	     * takes the event and returns the key character
	     *
	     * @param {Event} e
	     * @return {string}
	     */
	    function _characterFromEvent(e) {

	        // for keypress events we should return the character as is
	        if (e.type == 'keypress') {
	            var character = String.fromCharCode(e.which);

	            // if the shift key is not pressed then it is safe to assume
	            // that we want the character to be lowercase.  this means if
	            // you accidentally have caps lock on then your key bindings
	            // will continue to work
	            //
	            // the only side effect that might not be desired is if you
	            // bind something like 'A' cause you want to trigger an
	            // event when capital A is pressed caps lock will no longer
	            // trigger the event.  shift+a will though.
	            if (!e.shiftKey) {
	                character = character.toLowerCase();
	            }

	            return character;
	        }

	        // for non keypress events the special maps are needed
	        if (_MAP[e.which]) {
	            return _MAP[e.which];
	        }

	        if (_KEYCODE_MAP[e.which]) {
	            return _KEYCODE_MAP[e.which];
	        }

	        // if it is not in the special map

	        // with keydown and keyup events the character seems to always
	        // come in as an uppercase character whether you are pressing shift
	        // or not.  we should make sure it is always lowercase for comparisons
	        return String.fromCharCode(e.which).toLowerCase();
	    }

	    /**
	     * checks if two arrays are equal
	     *
	     * @param {Array} modifiers1
	     * @param {Array} modifiers2
	     * @returns {boolean}
	     */
	    function _modifiersMatch(modifiers1, modifiers2) {
	        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
	    }

	    /**
	     * resets all sequence counters except for the ones passed in
	     *
	     * @param {Object} doNotReset
	     * @returns void
	     */
	    function _resetSequences(doNotReset) {
	        doNotReset = doNotReset || {};

	        var activeSequences = false,
	            key;

	        for (key in _sequenceLevels) {
	            if (doNotReset[key]) {
	                activeSequences = true;
	                continue;
	            }
	            _sequenceLevels[key] = 0;
	        }

	        if (!activeSequences) {
	            _nextExpectedAction = false;
	        }
	    }

	    /**
	     * finds all callbacks that match based on the keycode, modifiers,
	     * and action
	     *
	     * @param {string} character
	     * @param {Array} modifiers
	     * @param {Event|Object} e
	     * @param {string=} sequenceName - name of the sequence we are looking for
	     * @param {string=} combination
	     * @param {number=} level
	     * @returns {Array}
	     */
	    function _getMatches(character, modifiers, e, sequenceName, combination, level) {
	        var i,
	            callback,
	            matches = [],
	            action = e.type;

	        // if there are no events related to this keycode
	        if (!_callbacks[character]) {
	            return [];
	        }

	        // if a modifier key is coming up on its own we should allow it
	        if (action == 'keyup' && _isModifier(character)) {
	            modifiers = [character];
	        }

	        // loop through all callbacks for the key that was pressed
	        // and see if any of them match
	        for (i = 0; i < _callbacks[character].length; ++i) {
	            callback = _callbacks[character][i];

	            // if a sequence name is not specified, but this is a sequence at
	            // the wrong level then move onto the next match
	            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
	                continue;
	            }

	            // if the action we are looking for doesn't match the action we got
	            // then we should keep going
	            if (action != callback.action) {
	                continue;
	            }

	            // if this is a keypress event and the meta key and control key
	            // are not pressed that means that we need to only look at the
	            // character, otherwise check the modifiers as well
	            //
	            // chrome will not fire a keypress if meta or control is down
	            // safari will fire a keypress if meta or meta+shift is down
	            // firefox will fire a keypress if meta or control is down
	            if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

	                // when you bind a combination or sequence a second time it
	                // should overwrite the first one.  if a sequenceName or
	                // combination is specified in this call it does just that
	                //
	                // @todo make deleting its own method?
	                var deleteCombo = !sequenceName && callback.combo == combination;
	                var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
	                if (deleteCombo || deleteSequence) {
	                    _callbacks[character].splice(i, 1);
	                }

	                matches.push(callback);
	            }
	        }

	        return matches;
	    }

	    /**
	     * takes a key event and figures out what the modifiers are
	     *
	     * @param {Event} e
	     * @returns {Array}
	     */
	    function _eventModifiers(e) {
	        var modifiers = [];

	        if (e.shiftKey) {
	            modifiers.push('shift');
	        }

	        if (e.altKey) {
	            modifiers.push('alt');
	        }

	        if (e.ctrlKey) {
	            modifiers.push('ctrl');
	        }

	        if (e.metaKey) {
	            modifiers.push('meta');
	        }

	        return modifiers;
	    }

	    /**
	     * prevents default for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _preventDefault(e) {
	        if (e.preventDefault) {
	            e.preventDefault();
	            return;
	        }

	        e.returnValue = false;
	    }

	    /**
	     * stops propogation for this event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _stopPropagation(e) {
	        if (e.stopPropagation) {
	            e.stopPropagation();
	            return;
	        }

	        e.cancelBubble = true;
	    }

	    /**
	     * actually calls the callback function
	     *
	     * if your callback function returns false this will use the jquery
	     * convention - prevent default and stop propogation on the event
	     *
	     * @param {Function} callback
	     * @param {Event} e
	     * @returns void
	     */
	    function _fireCallback(callback, e, combo, sequence) {

	        // if this event should not happen stop here
	        if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
	            return;
	        }

	        if (callback(e, combo) === false) {
	            _preventDefault(e);
	            _stopPropagation(e);
	        }
	    }

	    /**
	     * handles a character key event
	     *
	     * @param {string} character
	     * @param {Array} modifiers
	     * @param {Event} e
	     * @returns void
	     */
	    function _handleKey(character, modifiers, e) {
	        var callbacks = _getMatches(character, modifiers, e),
	            i,
	            doNotReset = {},
	            maxLevel = 0,
	            processedSequenceCallback = false;

	        // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
	        for (i = 0; i < callbacks.length; ++i) {
	            if (callbacks[i].seq) {
	                maxLevel = Math.max(maxLevel, callbacks[i].level);
	            }
	        }

	        // loop through matching callbacks for this key event
	        for (i = 0; i < callbacks.length; ++i) {

	            // fire for all sequence callbacks
	            // this is because if for example you have multiple sequences
	            // bound such as "g i" and "g t" they both need to fire the
	            // callback for matching g cause otherwise you can only ever
	            // match the first one
	            if (callbacks[i].seq) {

	                // only fire callbacks for the maxLevel to prevent
	                // subsequences from also firing
	                //
	                // for example 'a option b' should not cause 'option b' to fire
	                // even though 'option b' is part of the other sequence
	                //
	                // any sequences that do not match here will be discarded
	                // below by the _resetSequences call
	                if (callbacks[i].level != maxLevel) {
	                    continue;
	                }

	                processedSequenceCallback = true;

	                // keep a list of which sequences were matches for later
	                doNotReset[callbacks[i].seq] = 1;
	                _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
	                continue;
	            }

	            // if there were no sequence matches but we are still here
	            // that means this is a regular match so we should fire that
	            if (!processedSequenceCallback) {
	                _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
	            }
	        }

	        // if the key you pressed matches the type of sequence without
	        // being a modifier (ie "keyup" or "keypress") then we should
	        // reset all sequences that were not matched by this event
	        //
	        // this is so, for example, if you have the sequence "h a t" and you
	        // type "h e a r t" it does not match.  in this case the "e" will
	        // cause the sequence to reset
	        //
	        // modifier keys are ignored because you can have a sequence
	        // that contains modifiers such as "enter ctrl+space" and in most
	        // cases the modifier key will be pressed before the next key
	        //
	        // also if you have a sequence such as "ctrl+b a" then pressing the
	        // "b" key will trigger a "keypress" and a "keydown"
	        //
	        // the "keydown" is expected when there is a modifier, but the
	        // "keypress" ends up matching the _nextExpectedAction since it occurs
	        // after and that causes the sequence to reset
	        //
	        // we ignore keypresses in a sequence that directly follow a keydown
	        // for the same character
	        var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
	        if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
	            _resetSequences(doNotReset);
	        }

	        _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
	    }

	    /**
	     * handles a keydown event
	     *
	     * @param {Event} e
	     * @returns void
	     */
	    function _handleKeyEvent(e) {

	        // normalize e.which for key events
	        // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
	        if (typeof e.which !== 'number') {
	            e.which = e.keyCode;
	        }

	        var character = _characterFromEvent(e);

	        // no character found then stop
	        if (!character) {
	            return;
	        }

	        // need to use === for the character check because the character can be 0
	        if (e.type == 'keyup' && _ignoreNextKeyup === character) {
	            _ignoreNextKeyup = false;
	            return;
	        }

	        Mousetrap.handleKey(character, _eventModifiers(e), e);
	    }

	    /**
	     * determines if the keycode specified is a modifier key or not
	     *
	     * @param {string} key
	     * @returns {boolean}
	     */
	    function _isModifier(key) {
	        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
	    }

	    /**
	     * called to set a 1 second timeout on the specified sequence
	     *
	     * this is so after each key press in the sequence you have 1 second
	     * to press the next key before you have to start over
	     *
	     * @returns void
	     */
	    function _resetSequenceTimer() {
	        clearTimeout(_resetTimer);
	        _resetTimer = setTimeout(_resetSequences, 1000);
	    }

	    /**
	     * reverses the map lookup so that we can look for specific keys
	     * to see what can and can't use keypress
	     *
	     * @return {Object}
	     */
	    function _getReverseMap() {
	        if (!_REVERSE_MAP) {
	            _REVERSE_MAP = {};
	            for (var key in _MAP) {

	                // pull out the numeric keypad from here cause keypress should
	                // be able to detect the keys from the character
	                if (key > 95 && key < 112) {
	                    continue;
	                }

	                if (_MAP.hasOwnProperty(key)) {
	                    _REVERSE_MAP[_MAP[key]] = key;
	                }
	            }
	        }
	        return _REVERSE_MAP;
	    }

	    /**
	     * picks the best action based on the key combination
	     *
	     * @param {string} key - character for key
	     * @param {Array} modifiers
	     * @param {string=} action passed in
	     */
	    function _pickBestAction(key, modifiers, action) {

	        // if no action was picked in we should try to pick the one
	        // that we think would work best for this key
	        if (!action) {
	            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
	        }

	        // modifier keys don't work as expected with keypress,
	        // switch to keydown
	        if (action == 'keypress' && modifiers.length) {
	            action = 'keydown';
	        }

	        return action;
	    }

	    /**
	     * binds a key sequence to an event
	     *
	     * @param {string} combo - combo specified in bind call
	     * @param {Array} keys
	     * @param {Function} callback
	     * @param {string=} action
	     * @returns void
	     */
	    function _bindSequence(combo, keys, callback, action) {

	        // start off by adding a sequence level record for this combination
	        // and setting the level to 0
	        _sequenceLevels[combo] = 0;

	        /**
	         * callback to increase the sequence level for this sequence and reset
	         * all other sequences that were active
	         *
	         * @param {string} nextAction
	         * @returns {Function}
	         */
	        function _increaseSequence(nextAction) {
	            return function() {
	                _nextExpectedAction = nextAction;
	                ++_sequenceLevels[combo];
	                _resetSequenceTimer();
	            };
	        }

	        /**
	         * wraps the specified callback inside of another function in order
	         * to reset all sequence counters as soon as this sequence is done
	         *
	         * @param {Event} e
	         * @returns void
	         */
	        function _callbackAndReset(e) {
	            _fireCallback(callback, e, combo);

	            // we should ignore the next key up if the action is key down
	            // or keypress.  this is so if you finish a sequence and
	            // release the key the final key will not trigger a keyup
	            if (action !== 'keyup') {
	                _ignoreNextKeyup = _characterFromEvent(e);
	            }

	            // weird race condition if a sequence ends with the key
	            // another sequence begins with
	            setTimeout(_resetSequences, 10);
	        }

	        // loop through keys one at a time and bind the appropriate callback
	        // function.  for any key leading up to the final one it should
	        // increase the sequence. after the final, it should reset all sequences
	        //
	        // if an action is specified in the original bind call then that will
	        // be used throughout.  otherwise we will pass the action that the
	        // next key in the sequence should match.  this allows a sequence
	        // to mix and match keypress and keydown events depending on which
	        // ones are better suited to the key provided
	        for (var i = 0; i < keys.length; ++i) {
	            var isFinal = i + 1 === keys.length;
	            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
	            _bindSingle(keys[i], wrappedCallback, action, combo, i);
	        }
	    }

	    /**
	     * Converts from a string key combination to an array
	     *
	     * @param  {string} combination like "command+shift+l"
	     * @return {Array}
	     */
	    function _keysFromString(combination) {
	        if (combination === '+') {
	            return ['+'];
	        }

	        return combination.split('+');
	    }

	    /**
	     * Gets info for a specific key combination
	     *
	     * @param  {string} combination key combination ("command+s" or "a" or "*")
	     * @param  {string=} action
	     * @returns {Object}
	     */
	    function _getKeyInfo(combination, action) {
	        var keys,
	            key,
	            i,
	            modifiers = [];

	        // take the keys from this pattern and figure out what the actual
	        // pattern is all about
	        keys = _keysFromString(combination);

	        for (i = 0; i < keys.length; ++i) {
	            key = keys[i];

	            // normalize key names
	            if (_SPECIAL_ALIASES[key]) {
	                key = _SPECIAL_ALIASES[key];
	            }

	            // if this is not a keypress event then we should
	            // be smart about using shift keys
	            // this will only work for US keyboards however
	            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
	                key = _SHIFT_MAP[key];
	                modifiers.push('shift');
	            }

	            // if this key is a modifier then add it to the list of modifiers
	            if (_isModifier(key)) {
	                modifiers.push(key);
	            }
	        }

	        // depending on what the key combination is
	        // we will try to pick the best event for it
	        action = _pickBestAction(key, modifiers, action);

	        return {
	            key: key,
	            modifiers: modifiers,
	            action: action
	        };
	    }

	    /**
	     * binds a single keyboard combination
	     *
	     * @param {string} combination
	     * @param {Function} callback
	     * @param {string=} action
	     * @param {string=} sequenceName - name of sequence if part of sequence
	     * @param {number=} level - what part of the sequence the command is
	     * @returns void
	     */
	    function _bindSingle(combination, callback, action, sequenceName, level) {

	        // store a direct mapped reference for use with Mousetrap.trigger
	        _directMap[combination + ':' + action] = callback;

	        // make sure multiple spaces in a row become a single space
	        combination = combination.replace(/\s+/g, ' ');

	        var sequence = combination.split(' '),
	            info;

	        // if this pattern is a sequence of keys then run through this method
	        // to reprocess each pattern one key at a time
	        if (sequence.length > 1) {
	            _bindSequence(combination, sequence, callback, action);
	            return;
	        }

	        info = _getKeyInfo(combination, action);

	        // make sure to initialize array if this is the first time
	        // a callback is added for this key
	        _callbacks[info.key] = _callbacks[info.key] || [];

	        // remove an existing match if there is one
	        _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

	        // add this call back to the array
	        // if it is a sequence put it at the beginning
	        // if not put it at the end
	        //
	        // this is important because the way these are processed expects
	        // the sequence ones to come first
	        _callbacks[info.key][sequenceName ? 'unshift' : 'push']({
	            callback: callback,
	            modifiers: info.modifiers,
	            action: info.action,
	            seq: sequenceName,
	            level: level,
	            combo: combination
	        });
	    }

	    /**
	     * binds multiple combinations to the same callback
	     *
	     * @param {Array} combinations
	     * @param {Function} callback
	     * @param {string|undefined} action
	     * @returns void
	     */
	    function _bindMultiple(combinations, callback, action) {
	        for (var i = 0; i < combinations.length; ++i) {
	            _bindSingle(combinations[i], callback, action);
	        }
	    }

	    // start!
	    _addEvent(document, 'keypress', _handleKeyEvent);
	    _addEvent(document, 'keydown', _handleKeyEvent);
	    _addEvent(document, 'keyup', _handleKeyEvent);

	    var Mousetrap = {

	        /**
	         * binds an event to mousetrap
	         *
	         * can be a single key, a combination of keys separated with +,
	         * an array of keys, or a sequence of keys separated by spaces
	         *
	         * be sure to list the modifier keys first to make sure that the
	         * correct key ends up getting bound (the last key in the pattern)
	         *
	         * @param {string|Array} keys
	         * @param {Function} callback
	         * @param {string=} action - 'keypress', 'keydown', or 'keyup'
	         * @returns void
	         */
	        bind: function(keys, callback, action) {
	            keys = keys instanceof Array ? keys : [keys];
	            _bindMultiple(keys, callback, action);
	            return this;
	        },

	        /**
	         * unbinds an event to mousetrap
	         *
	         * the unbinding sets the callback function of the specified key combo
	         * to an empty function and deletes the corresponding key in the
	         * _directMap dict.
	         *
	         * TODO: actually remove this from the _callbacks dictionary instead
	         * of binding an empty function
	         *
	         * the keycombo+action has to be exactly the same as
	         * it was defined in the bind method
	         *
	         * @param {string|Array} keys
	         * @param {string} action
	         * @returns void
	         */
	        unbind: function(keys, action) {
	            return Mousetrap.bind(keys, function() {}, action);
	        },

	        /**
	         * triggers an event that has already been bound
	         *
	         * @param {string} keys
	         * @param {string=} action
	         * @returns void
	         */
	        trigger: function(keys, action) {
	            if (_directMap[keys + ':' + action]) {
	                _directMap[keys + ':' + action]({}, keys);
	            }
	            return this;
	        },

	        /**
	         * resets the library back to its initial state.  this is useful
	         * if you want to clear out the current keyboard shortcuts and bind
	         * new ones - for example if you switch to another page
	         *
	         * @returns void
	         */
	        reset: function() {
	            _callbacks = {};
	            _directMap = {};
	            return this;
	        },

	       /**
	        * should we stop this event before firing off callbacks
	        *
	        * @param {Event} e
	        * @param {Element} element
	        * @return {boolean}
	        */
	        stopCallback: function(e, element) {

	            // if the element has the class "mousetrap" then no need to stop
	            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
	                return false;
	            }

	            // stop for input, select, and textarea
	            return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
	        },

	        /**
	         * exposes _handleKey publicly so it can be overwritten by extensions
	         */
	        handleKey: _handleKey
	    };

	    // expose mousetrap to the global object
	    window.Mousetrap = Mousetrap;

	    // expose mousetrap as an AMD module
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (Mousetrap), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	}) (window, document);


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var AppDispatcher = __webpack_require__(1),
	    FaviconCounter = __webpack_require__(112),
	    AnalyticsDispatcher = __webpack_require__(7),
	    AppConfig = __webpack_require__(3);

	var Notifier = (function () {
	  function Notifier() {
	    var _this = this;

	    _classCallCheck(this, Notifier);

	    this.isSupported = typeof Notification != "undefined";
	    this.totalUnreadCount = 0;
	    this.totalUnreadHasMention = false;

	    if (typeof Audio !== "undefined") {
	      this.audio = new Audio(AppConfig.notify_sound_asset);
	      this.audio.addEventListener("loadedmetadata", function () {
	        _this.audio_duration = _this.audio.duration;
	      });
	    }
	    this.autoclose_timeout = AppConfig.notification_close_timeout;
	    this.maxNotifications = AppConfig.notification_limit;
	    this.notificationCount = 0;

	    try {
	      this.favicon = new FaviconCounter({ bgColor: AppConfig.favicon_bg_color });
	    } catch (e) {
	      console.debug("[ERROR]", e);
	    }
	  }

	  _prototypeProperties(Notifier, null, {
	    notify: {
	      value: function notify(data) {
	        this._increaseCount();
	        var notification;
	        if (this.isSupported) {
	          notification = new Notification(data.title, this._getOptions(data));
	          this._bindNotification(notification, data.jid);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    playSound: {
	      value: function playSound() {
	        if (this.audio) {
	          if (this.audio_duration && this.audio.currentTime < this.audio_duration) {
	            this.audio.pause();
	            this.audio.currentTime = 0;
	          }
	          this.audio.play();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    updateTotalUnreadCount: {
	      value: function updateTotalUnreadCount(count, hasMention) {
	        if (count !== this.totalUnreadCount || hasMention !== this.totalUnreadHasMention) {
	          this._updateFavicon(count, hasMention);
	          this.totalUnreadCount = count;
	          this.totalUnreadHasMention = hasMention;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    _getOptions: {
	      value: function _getOptions(data) {
	        var notificationData = {
	          icon: data.icon,
	          body: data.body
	        };
	        if (this.notificationCount >= this.maxNotifications) {
	          notificationData.tag = true;
	        }
	        return notificationData;
	      },
	      writable: true,
	      configurable: true
	    },
	    _bindNotification: {
	      value: function _bindNotification(notification, jid) {
	        var _this = this;

	        notification.onclick = function () {
	          window.focus();
	          AppDispatcher.dispatch("select-room", { jid: jid });
	          AnalyticsDispatcher.dispatch("analytics-select-room", { jid: jid });
	          this.close();
	        };
	        notification.onshow = function () {
	          setTimeout(function () {
	            notification.close();
	          }, _this.autoclose_timeout);
	        };
	        notification.onclose = function () {
	          _this._decreaseCount(notification);
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    _increaseCount: {
	      value: function _increaseCount() {
	        this.notificationCount++;
	      },
	      writable: true,
	      configurable: true
	    },
	    _decreaseCount: {
	      value: function _decreaseCount(notification) {
	        if (notification.tag) {
	          this.notificationCount = 0;
	        } else {
	          this.notificationCount--;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    _updateFavicon: {
	      value: function _updateFavicon(unreadTotal, hasMention) {
	        if (this.favicon) {
	          if (unreadTotal > 0) {
	            var opts = {
	              bgColor: AppConfig.favicon_bg_color
	            };
	            if (hasMention) {
	              opts.bgColor = AppConfig.favicon_bg_color_with_mention;
	            }
	            this.favicon.badge(unreadTotal, opts);
	          } else {
	            this.favicon.reset();
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return Notifier;
	})();

	module.exports = new Notifier();

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);

	var errorsToHandle = ["500", "403"];

	module.exports = function (stanza) {
	  if (stanza.error && stanza.error.code && _.contains(errorsToHandle, stanza.error.code)) {
	    AppDispatcher.dispatch("general-error", stanza);
	  }
	};

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  NOTIFY_FOR_ROOM: "notifyForRoom",
	  NOTIFY_FOR_PRIVATE_ROOM: "notifyForPrivateRoom",
	  NOTIFY_FOR_TAG: "notifyForTag",
	  NOTIFY_FOR_PRIVATE: "notifyForPrivate",
	  DISABLE_SOUNDS: "disableSounds",
	  SHOW_TOASTERS: "showToasters",
	  HIDE_PRESENCE_MESSAGES: "hidePresenceMessages",
	  USE_24_HR_FORMAT: "timeFormat24Hour"
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Promise = __webpack_require__(113).Promise;
	var polyfill = __webpack_require__(114).polyfill;
	exports.Promise = Promise;
	exports.polyfill = polyfill;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var AppDispatcher = __webpack_require__(1),
	    PreferencesStore = __webpack_require__(21),
	    Store = __webpack_require__(43),
	    Utils = __webpack_require__(4),
	    moment = __webpack_require__(64);

	var ChatHeaderStore = (function (Store) {
	  function ChatHeaderStore() {
	    _classCallCheck(this, ChatHeaderStore);

	    this.default_profile = {
	      email: "",
	      mention_name: "",
	      name: "",
	      photo_large: "",
	      photo_small: "",
	      timezone: false,
	      title: "",
	      xmlns: ""
	    };

	    this.local = {
	      profiles: {}
	    };

	    this.data = {
	      active_chat: null,
	      type: "",
	      rooms: {},
	      topic_editing: false,
	      topic_input_value: "",
	      chat: {
	        jid: "",
	        name: "",
	        topic: "",
	        photo_large: "",
	        title: "",
	        status: "",
	        privacy: "",
	        is_archived: "0",
	        email: "",
	        presence: {},
	        time: "",
	        loading_profile: true
	      }
	    };

	    this.registerListeners();
	  }

	  _inherits(ChatHeaderStore, Store);

	  _prototypeProperties(ChatHeaderStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.registerOnce({
	          "hc-init": function () {
	            _this.set("active_chat", PreferencesStore.getChatToFocus());
	          }
	        });
	        AppDispatcher.register({
	          "updated:current_user": function (user) {
	            _this.local.profiles[user.user_jid] = _.assign({
	              name: user.user_name,
	              mention_name: user.mention
	            }, user);
	          },
	          "updated:preferences": function (prefs) {
	            _this.set("active_chat", prefs.chatToFocus);
	          },
	          "updated:activeRooms": function (rooms) {
	            _this.handleRoomsUpdate(rooms);
	          },
	          "updated:profiles": function (profiles) {
	            _this.handleProfilesUpdate(profiles);
	          },
	          "updated:roster": function (roster) {
	            _this.handleRosterUpdate(roster);
	          },
	          "updated:active_chat": function (jid) {
	            _this.updateRoomHeaderState(jid);
	          },
	          "open-room": function (data) {
	            _this.updateRoomHeaderState(data.jid);
	          },
	          "edit-topic": function () {
	            _this.set("topic_editing", true);
	          },
	          "dismiss-topic-edit": function () {
	            _this.set({
	              topic_editing: false,
	              topic_input_value: _this.data.chat.topic
	            });
	          },
	          "set-topic-input-value": function (data) {
	            _this.set("topic_input_value", data);
	          },
	          "set-topic": function (data) {
	            _this.data.chat.topic = _this.data.rooms[data.jid].topic = data.topic;
	            _this.data.topic_editing = false;
	            _this.updateRoomHeaderState(data.jid);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomsUpdate: {
	      value: function handleRoomsUpdate(rooms) {
	        var deleted = _.difference(_.keys(this.data.rooms), _.keys(rooms));
	        if (deleted.length) {
	          this.data.rooms = _.omit(this.data.rooms, deleted);
	        } else if (this.data.active_chat && this.data.active_chat != null && !this.data.active_chat.match("lobby") && !this.data.topic_editing && rooms[this.data.active_chat] && rooms[this.data.active_chat].topic) {
	          this.data.topic_input_value = rooms[this.data.active_chat].topic;
	        }
	        this.set("rooms", _.merge(this.data.rooms, rooms));
	        this.updateRoomHeaderState(this.data.active_chat);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleProfilesUpdate: {
	      value: function handleProfilesUpdate(profiles) {
	        var _this = this;

	        _.map(profiles, function (profile, jid) {
	          _this.local.profiles[jid] = profile;
	          if (_this.data.rooms[jid]) {
	            _this.data.rooms[jid] = _.merge(_this.data.rooms[jid], profile);
	          }
	        });
	        this.updateRoomHeaderState(this.data.active_chat);
	      },
	      writable: true,
	      configurable: true
	    },
	    updateRoomHeaderState: {
	      value: function updateRoomHeaderState(jid) {
	        var _this = this;

	        clearTimeout(this.timeout);
	        if (!jid || /^lobby$/.test(jid.split("@")[0]) || !this.data.rooms[jid]) {
	          return;
	        }
	        var type = this.data.rooms[jid].type,
	            defaultPanel = {
	          chat: "files",
	          groupchat: "roster"
	        };
	        if (!_.isEqual(this.data.type, type)) {
	          this.data.active_panel = defaultPanel[type];
	        }
	        if (type == "chat" && this.data.rooms[jid]) {
	          if (this.local.profiles[jid]) {
	            this.data.rooms[jid].loading_profile = false;
	          }
	          _.merge(this.data.rooms[jid], _.clone(this.default_profile), this.local.profiles[jid]);
	          if (this.data.rooms[jid].timezone) {
	            var timezone_offset = parseFloat(this.data.rooms[jid].timezone.utc_offset);
	            this.data.chat.time = moment().utcOffset(timezone_offset).format("ddd h:mm A");
	          } else {
	            this.data.chat.time = moment().format("ddd h:mm A");
	          }
	          this.timeout = setTimeout(function () {
	            _this.updateRoomHeaderState(jid);
	          }, 60000);
	        }
	        var chat = _.assign({}, this.data.chat, this.data.rooms[jid]);
	        this.set({
	          active_chat: jid,
	          type: type,
	          chat: chat,
	          active_panel: this.data.active_panel,
	          topic_input_value: this.data.topic_editing ? this.data.topic_input_value : chat.topic
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRosterUpdate: {
	      value: function handleRosterUpdate(roster) {
	        _.map(this.data.rooms, function (room) {
	          if (room) {
	            if (roster[room.jid]) {
	              room.presence = roster[room.jid].presence;
	            }
	          }
	        });
	        this.handleRoomsUpdate(this.data.rooms);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return ChatHeaderStore;
	})(Store);

	module.exports = new ChatHeaderStore();

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4);
	var Store = __webpack_require__(43);
	var AppDispatcher = __webpack_require__(1);

	var CurrentUserStore = (function (Store) {
	  function CurrentUserStore() {
	    _classCallCheck(this, CurrentUserStore);

	    this.data = {
	      user: {},
	      presence: {
	        show: "chat"
	      }
	    };

	    this.registerListeners();
	  }

	  _inherits(CurrentUserStore, Store);

	  _prototypeProperties(CurrentUserStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "updated:current_user": function (user) {
	            _this.handleCurrentUserUpdate(user);
	          },
	          "updated:roster": function (roster) {
	            _this.data.presence = roster[_this.data.user.user_jid].presence;
	            _this.handleCurrentUserUpdate(_this.data.user);
	          },
	          "update-presence": function (presence) {
	            _this.data.presence = presence;
	            _this.handleCurrentUserUpdate(_this.data.user);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleCurrentUserUpdate: {
	      value: function handleCurrentUserUpdate(user) {
	        this.set("user", _.assign(this.data.user, user));
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return CurrentUserStore;
	})(Store);

	module.exports = new CurrentUserStore();

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var UserStatusAvatar = __webpack_require__(115),
	    UserStatusMenu = __webpack_require__(116),
	    CurrentUserStore = __webpack_require__(71),
	    AppHeaderActions = __webpack_require__(48),
	    SearchInput = __webpack_require__(117),
	    PresenceIcon = __webpack_require__(118),
	    AceStpButton = __webpack_require__(119);

	function getState() {
	  return {
	    user: CurrentUserStore.get("user"),
	    presence: CurrentUserStore.get("presence"),
	    presenceDialogVisible: false
	  };
	}

	function setupFeedbackButton() {
	  if (document.location.hostname !== "localhost") {
	    $.ajax({
	      url: "https://jira.atlassian.com/s/83f9ee60463444b76d4b2e62fed26460-T/en_UK2pighi/64005/131/1.4.17/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-UK&collectorId=12269b35",
	      type: "get",
	      cache: true,
	      dataType: "script"
	    });

	    window.ATL_JQ_PAGE_PROPS = $.extend(window.ATL_JQ_PAGE_PROPS, {
	      triggerFunction: function (showCollectorDialog) {
	        //Requires that jQuery is available!
	        $("#give-feedback").click(function (e) {
	          e.preventDefault();
	          showCollectorDialog();
	        });
	      },
	      fieldValues: {
	        customfield_11030: window.versionID
	      }
	    });
	  }
	}

	module.exports = React.createClass({

	  displayName: "UserStatus",

	  getInitialState: function getInitialState() {
	    return getState();
	  },

	  componentDidMount: function componentDidMount() {
	    CurrentUserStore.on(["change"], this._onChange);
	    setupFeedbackButton();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    CurrentUserStore.off(["change"], this._onChange);
	  },

	  _onHelpButtonClicked: function _onHelpButtonClicked() {
	    AppHeaderActions.helpButtonClicked();
	  },

	  _onUserProfileDropdownClick: function _onUserProfileDropdownClick() {
	    AppHeaderActions.userProfileDropdownClicked();
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "aui-header-secondary" },
	      React.createElement(
	        "ul",
	        { className: "aui-nav", "data-skate-ignore": true },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { href: "javascript:void(0)", id: "give-feedback" },
	            React.createElement("span", { className: "aui-icon aui-icon-small aui-iconfont-comment" }),
	            " Feedback"
	          )
	        ),
	        React.createElement(
	          "li",
	          null,
	          React.createElement(SearchInput, { jid: this.props.active_chat, text: this.props.search_text, focus_search: this.props.focus_search })
	        ),
	        React.createElement(
	          "li",
	          { id: "ace-stp-menu" },
	          React.createElement(AceStpButton, null)
	        ),
	        React.createElement(
	          "li",
	          { className: "status-dropdown", onClick: this._onUserProfileDropdownClick },
	          React.createElement(
	            "a",
	            { className: "aui-dropdown2-trigger hc-header-user-avatar", "aria-owns": "current-user-status", "aria-haspopup": "true", "aria-controls": "current-user-status" },
	            React.createElement(
	              "div",
	              { className: "aui-avatar-small" },
	              React.createElement(UserStatusAvatar, { user: this.state.user })
	            ),
	            React.createElement(PresenceIcon, { presence: this.state.presence.show, active: true })
	          ),
	          React.createElement(UserStatusMenu, { user: this.state.user, onPresenceUpdate: this._onPresenceUpdate, onSignout: this._onSignout, onSettings: this._onSettings })
	        )
	      )
	    );
	  },

	  _onChange: function _onChange() {
	    this.setState(getState());
	  },

	  _onPresenceUpdate: function _onPresenceUpdate(target) {
	    AppHeaderActions.updatePresence(target.dataset);
	  },

	  _onPresenceUpdated: function _onPresenceUpdated() {
	    AppHeaderActions.hideStatusMessageForm();
	  },

	  _onSignout: function _onSignout() {
	    AppHeaderActions.signout();
	  },

	  _onSettings: function _onSettings() {
	    AppHeaderActions.requestPreferencesDialog();
	  }

	});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43),
	    Storage = __webpack_require__(120),
	    AppDispatcher = __webpack_require__(1),
	    Utils = __webpack_require__(4);

	var AppHeaderStore = (function (Store) {
	  function AppHeaderStore() {
	    _classCallCheck(this, AppHeaderStore);

	    this.notification_supported = typeof Notification != "undefined";

	    this.data = {
	      ready: false,
	      active_chat: false,
	      search_text: "",
	      focus_search: false,
	      notification_supported: this.notification_supported,
	      notification_dismissed: this.getDismissalCount(),
	      notification_dismissed_forever: Storage.get("notificationBannerDismissedForever"),
	      notification_preference: false,
	      notification_permission: this.getNotificationPermission()
	    };
	    this.registerListeners();
	  }

	  _inherits(AppHeaderStore, Store);

	  _prototypeProperties(AppHeaderStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "app-state-ready": function () {
	            _this.set({
	              ready: true
	            });
	          },
	          "updated:active_chat": function (jid) {
	            _this.set({
	              active_chat: jid
	            });
	          },
	          "updated:preferences": function (data) {
	            _this.set({
	              notification_preference: data.showToasters,
	              notification_dismissed: _this.getDismissalCount()
	            });
	          },
	          "search-history": function (data) {
	            _this.handleSearch(data);
	          },
	          "set-search-text": function (data) {
	            _this.set("search_text", data.text);
	          },
	          "request-notification-permission": function () {
	            Notification.requestPermission();
	          },
	          "dismiss-notification-banner": function () {
	            Storage.set("notificationBannerDismissalCount", _this.getDismissalCount() + 1 || 1);
	          },
	          "dismiss-notification-banner-forever": function () {
	            Storage.set("notificationBannerDismissedForever", true);
	          },
	          "focus-search": function () {
	            _this.set("focus_search", true);
	          },
	          "blur-search": function () {
	            _this.set("focus_search", false);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleSearch: {
	      value: function handleSearch(data) {
	        var room_name = Utils.jid.room_name(data.jid),
	            url = "/search?q=" + _.escape(this.data.search_text) + "&r=" + _.escape(room_name);
	        window.open(url);
	        this.set("search_text", "");
	      },
	      writable: true,
	      configurable: true
	    },
	    getDismissalCount: {
	      value: function getDismissalCount() {
	        return Storage.get("notificationBannerDismissalCount");
	      },
	      writable: true,
	      configurable: true
	    },
	    getNotificationPermission: {
	      value: function getNotificationPermission() {
	        if (this.notification_supported) {
	          return Notification.permission !== "default";
	        }
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return AppHeaderStore;
	})(Store);

	module.exports = new AppHeaderStore();

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppHeaderActions = __webpack_require__(48),
	    strings = __webpack_require__(121),
	    AppDispatcher = __webpack_require__(1),
	    appConfig = __webpack_require__(3);

	module.exports = React.createClass({

	  displayName: "NotificationBanner",

	  getInitialState: function getInitialState() {
	    return {
	      dismissed: false,
	      shown: false
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if (this.props.notification_preference && !nextProps.notification_preference) {
	      this.setState({
	        dismissed: true,
	        shown: false
	      });
	    } else if (!this.props.notification_preference && nextProps.notification_preference) {
	      this.setState({
	        dismissed: false,
	        shown: true
	      });
	      _.delay(function () {
	        AppDispatcher.dispatch("position-invite-dialog");
	        AppDispatcher.dispatch("notification-banner-status", {
	          showing: true
	        });
	      }, appConfig.notification_banner_slide);
	    } else if (nextProps.notification_dismissed > this.props.notification_dismissed) {
	      this.setState({
	        dismissed: true,
	        shown: false
	      });
	    }
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        classes = cx({
	      dismissed: this.state.dismissed,
	      shown: this.state.shown,
	      "aui-banner": true,
	      "hc-banner-warning": true
	    });
	    return React.createElement(
	      "div",
	      { className: classes, role: "banner", "aria-hidden": "false" },
	      strings.banner_message,
	      " ",
	      React.createElement(
	        "a",
	        { onClick: this._enableNotifications },
	        strings.enable_link
	      ),
	      " ",
	      this.props.notification_dismissed > 0 ? strings.seriously_recommended : strings.recommended,
	      React.createElement(
	        "strong",
	        null,
	        "  ·  "
	      ),
	      React.createElement(
	        "a",
	        { onClick: this._dismiss },
	        strings.dismiss_link
	      ),
	      this.props.notification_dismissed > 0 ? React.createElement(
	        "span",
	        null,
	        React.createElement(
	          "strong",
	          null,
	          "  ·  "
	        ),
	        React.createElement(
	          "a",
	          { onClick: this._dismissForever },
	          strings.dismiss_forever_link
	        )
	      ) : React.createElement("span", null)
	    );
	  },

	  _enableNotifications: function _enableNotifications() {
	    this._hideBanner();
	    AppHeaderActions.requestNotificationPermission();
	  },

	  _dismiss: function _dismiss() {
	    this._hideBanner();
	    AppHeaderActions.dismissNotificationBanner();
	  },

	  _dismissForever: function _dismissForever() {
	    this._hideBanner();
	    AppHeaderActions.dismissNotificationBannerForever();
	  },

	  _hideBanner: function _hideBanner() {
	    this.setState({
	      dismissed: true,
	      shown: false
	    });
	    AppDispatcher.dispatch("notification-banner-status", {
	      showing: false
	    });
	  }
	});

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var AppDispatcher = __webpack_require__(1),
	    Store = __webpack_require__(43);

	var ConnectionStore = (function (Store) {
	  function ConnectionStore() {
	    _classCallCheck(this, ConnectionStore);

	    this.data = {
	      connection: {
	        connected: true,
	        reconnecting: false,
	        disconnecting: false
	      },
	      force_hide: false
	    };

	    this.registerListeners();
	  }

	  _inherits(ConnectionStore, Store);

	  _prototypeProperties(ConnectionStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "updated:connection": function (data) {
	            _this.set("connection", data);
	          },
	          "unload-app": function () {
	            return _this.set("force_hide", true);
	          },
	          "ping-response": function () {
	            var connection = _this.get("connection");
	            if (!connection.connected) {
	              connection.connected = true;
	              _this.set("connection", connection);
	            }
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return ConnectionStore;
	})(Store);

	module.exports = new ConnectionStore();

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  attempt_reconnect: "Attempting to reconnect. (You may be having network issues.)",
	  reconnect_now: "Reconnect now",
	  failed_connection: "Couldn't connect to HipChat."
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var invariant = __webpack_require__(239);

	module.exports = React.createClass({

	  displayName: "Spinner",

	  componentWillMount: function componentWillMount() {
	    invariant(_.contains(["small", "medium", "large"], this.props.size), "Spinner size must be either small, medium or large");
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      size: "medium",
	      zIndex: 100
	    };
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.refs.spinner) {
	      if (this.props.spin) {
	        AJS.$(this.refs.spinner.getDOMNode()).spin(this.props.size, this.props);
	      } else {
	        AJS.$(this.refs.spinner.getDOMNode()).spinStop();
	      }
	    }
	  },

	  render: function render() {
	    return React.createElement("div", { className: "hc-spinner " + (this.props.spinner_class ? this.props.spinner_class : ""), ref: "spinner" });
	  }
	});

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43),
	    AppDispatcher = __webpack_require__(1);

	var GeneralErrorsStore = (function (Store) {
	  function GeneralErrorsStore() {
	    _classCallCheck(this, GeneralErrorsStore);

	    this.data = this.getDefaults();
	    this.registerListeners();
	  }

	  _inherits(GeneralErrorsStore, Store);

	  _prototypeProperties(GeneralErrorsStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          errors: []
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "general-error": function (error) {
	            var errors = _this.data.errors;
	            errors.push(error);
	            _this.set("errors", errors);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return GeneralErrorsStore;
	})(Store);

	module.exports = new GeneralErrorsStore();

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);
	var ClientPreferencesStore = __webpack_require__(38);
	var AppDispatcher = __webpack_require__(1);

	var LayoutStore = (function (Store) {
	  function LayoutStore() {
	    _classCallCheck(this, LayoutStore);

	    this.data = this.getDefaults();
	    this.register_listeners();
	  }

	  _inherits(LayoutStore, Store);

	  _prototypeProperties(LayoutStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          ready: false,
	          bannerShowing: false,
	          leftColumnWidth: this.getLeftColumnWidth()
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    register_listeners: {
	      value: function register_listeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "app-state-ready": function () {
	            _this.set("ready", true);
	          },
	          "notification-banner-status": function (data) {
	            _this.set("bannerShowing", data.showing);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    getLeftColumnWidth: {
	      value: function getLeftColumnWidth() {
	        return ClientPreferencesStore.getLeftColumnWidth();
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return LayoutStore;
	})(Store);

	module.exports = new LayoutStore();

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomsNav = __webpack_require__(140),
	    UnreadScroller = __webpack_require__(141);

	module.exports = React.createClass({

	  displayName: "SideBar",

	  render: function render() {
	    return React.createElement(
	      UnreadScroller,
	      null,
	      React.createElement(RoomsNav, null)
	    );
	  }
	});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomsNavStore = __webpack_require__(122),
	    RosterStore = __webpack_require__(91),
	    Lobby = __webpack_require__(123),
	    Sidebar = __webpack_require__(124),
	    ChatHeader = __webpack_require__(125),
	    ChatPanel = __webpack_require__(16),
	    ChatInputBox = __webpack_require__(126),
	    ClientPreferencesKeys = __webpack_require__(39),
	    ClientPreferencesStore = __webpack_require__(38),
	    ui = __webpack_require__(40),
	    Utils = __webpack_require__(4),
	    LayoutActions = __webpack_require__(84),
	    appConfig = __webpack_require__(3);

	function getState() {
	  return {
	    active_chat: RoomsNavStore.get("active_chat"),
	    chat_show_sidebar: ClientPreferencesStore.shouldShowChatSidebar(),
	    groupchat_show_sidebar: ClientPreferencesStore.shouldShowGroupChatSidebar(),
	    rightColumnWidth: ClientPreferencesStore.getRightColumnWidth()
	  };
	}

	module.exports = React.createClass({

	  displayName: "MainColumn",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(nextState, this.state);
	  },

	  getInitialState: getState,

	  componentDidMount: function componentDidMount() {
	    RoomsNavStore.on("change", this._onChange);
	    ClientPreferencesStore.on(["change"], this._onChange);
	    if (this.state.active_chat !== "lobby") {
	      this._resizeColumns(this._getColumnWidth());
	    }
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.active_chat !== "lobby") {
	      this._resizeColumns(this._getColumnWidth());
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    RoomsNavStore.off("change", this._onChange);
	    ClientPreferencesStore.off(["change"], this._onChange);
	  },

	  render: function render() {
	    var panel,
	        cx = React.addons.classSet,
	        chatClasses = cx({
	      "hc-rooms-container": true,
	      hidden: this.state.active_chat == "lobby"
	    });

	    if (this.state.active_chat === "lobby") {
	      panel = React.createElement(Lobby, null);
	    } else {
	      panel = React.createElement(
	        "div",
	        { className: chatClasses },
	        React.createElement(ChatHeader, null),
	        React.createElement(ChatPanel, { ref: "main_column" }),
	        React.createElement(
	          "div",
	          { className: "hc-right-sidebar-col", ref: "right_column" },
	          React.createElement(Sidebar, null),
	          React.createElement("div", { className: "resize-handle", onMouseDown: this._onResizeStart })
	        ),
	        React.createElement(ChatInputBox, { ref: "chat_input" })
	      );
	    }

	    return React.createElement(
	      "div",
	      { className: "hc-main-col" },
	      panel
	    );
	  },

	  _showSidebar: function _showSidebar() {
	    return ui.showSidebar(Utils.room.detect_chat_type(this.state.active_chat), this.state.groupchat_show_sidebar, this.state.chat_show_sidebar);
	  },

	  _onChange: function _onChange() {
	    this.setState(getState());
	  },

	  _getColumnWidth: function _getColumnWidth() {
	    var width,
	        show_sidebar = this._showSidebar();
	    width = this.state.rightColumnWidth > appConfig.column_width_limits.right.min ? this.state.rightColumnWidth : appConfig.column_width_limits.right["default"];
	    return show_sidebar ? width : 0;
	  },

	  _resizeColumns: function _resizeColumns(width) {
	    var main = this.refs.main_column.getDOMNode(),
	        right = this.refs.right_column.getDOMNode(),
	        input = this.refs.chat_input.getDOMNode();
	    right.style.width = width + "px";
	    main.style.width = "calc(100% - " + width + "px)";
	    input.style.width = "calc(100% - " + width + "px)";
	  },

	  _onResizeStart: function _onResizeStart(e) {
	    e.preventDefault();
	    this.beginX = e.pageX;
	    this.beginWidth = this.refs.right_column.getDOMNode().offsetWidth;
	    document.addEventListener("mouseup", this._onResizeEnd);
	    document.addEventListener("mousemove", this._onHandleDrag);
	  },

	  _onHandleDrag: function _onHandleDrag(e) {
	    var diff = e.pageX - this.beginX;
	    if (this.beginWidth - diff >= 0 && this.beginWidth - diff <= appConfig.column_width_limits.right.max) {
	      this._resizeColumns(this.beginWidth - diff);
	    }
	  },

	  _onResizeEnd: function _onResizeEnd(e) {
	    e.preventDefault();
	    document.removeEventListener("mouseup", this._onResizeEnd);
	    document.removeEventListener("mousemove", this._onHandleDrag);
	    var data = {
	      rightColumnWidth: this.refs.right_column.getDOMNode().offsetWidth
	    };
	    data[ClientPreferencesKeys["SHOW_" + Utils.room.detect_chat_type(this.state.active_chat).toUpperCase() + "_SIDEBAR"]] = this.refs.right_column.getDOMNode().offsetWidth >= appConfig.column_width_limits.right.min;
	    LayoutActions.saveRightColumnWidth(data);
	  }
	});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var loadingMessages = __webpack_require__(127);
	var invariant = __webpack_require__(239);

	function getRandomNumber(max) {
	  return Math.floor(Math.random() * max);
	}

	var imageNumber = getRandomNumber(2);

	module.exports = React.createClass({

	  displayName: "RandomLoadMessage",

	  pageLoadTimeout: 7000, // seven second timeout to show the "don't freak out" message

	  getInitialState: function getInitialState() {
	    return {
	      loading_message: this._getRandomHappyMessage()
	    };
	  },

	  componentWillMount: function componentWillMount() {
	    invariant(loadingMessages.happy.length === loadingMessages.sad.length, "There must be the same number of happy vs sad loading messages");
	  },

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    this.messageTimeout = setTimeout(function () {
	      _this.setState({
	        loading_message: _this._getRandomSadMessage()
	      });
	    }, this.pageLoadTimeout);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    clearTimeout(this.messageTimeout);
	  },

	  render: function render() {

	    var src = window.assetBaseUri + "assets/img/embedded/load_" + imageNumber + ".gif";

	    return React.createElement(
	      "div",
	      { className: "loading-message" },
	      React.createElement(
	        "div",
	        { className: "loading-inner" },
	        React.createElement("img", { src: src, width: "100", height: "100" }),
	        React.createElement(
	          "p",
	          null,
	          this.state.loading_message
	        )
	      )
	    );
	  },

	  _getRandomHappyMessage: function _getRandomHappyMessage() {
	    var key = getRandomNumber(loadingMessages.happy.length);
	    return loadingMessages.happy[key];
	  },

	  _getRandomSadMessage: function _getRandomSadMessage() {
	    var key = getRandomNumber(loadingMessages.sad.length);
	    return loadingMessages.sad[key];
	  },

	  _onReady: function _onReady() {
	    clearTimeout(this.messageTimeout);
	  }

	});

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);
	var GeneralError403 = __webpack_require__(128);
	var GeneralError500 = __webpack_require__(129);

	module.exports = React.createClass({

	  displayName: "GeneralErrorDisplay",

	  render: function render() {
	    var stanza = this.props.errors[0];

	    if (stanza.error.code === "500") {
	      return React.createElement(GeneralError500, { error: stanza });
	    } else {
	      return React.createElement(GeneralError403, { error: stanza });
	    }
	  }

	});

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * MainLayoutActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var MainLayoutActions = {

	  saveLeftColumnWidth: function saveLeftColumnWidth(data) {
	    AppDispatcher.dispatch("save-client-preferences", data);
	  },

	  saveRightColumnWidth: function saveRightColumnWidth(data) {
	    AppDispatcher.dispatch("save-client-preferences", data);
	  }

	};

	module.exports = MainLayoutActions;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);
	var Storage = __webpack_require__(120);
	var AppDispatcher = __webpack_require__(1);

	var PersistentStore = (function (Store) {
	  function PersistentStore() {
	    _classCallCheck(this, PersistentStore);

	    _get(Object.getPrototypeOf(PersistentStore.prototype), "constructor", this).call(this);
	    this.id = this.getStoreId();
	    if (!this.id) {
	      throw "Persistent store requires an ID. Set one by specifying the function getStoreId.";
	    }

	    var defaults = this.getDefaults();
	    var existingProperties = Storage.get(this.id);

	    this.set(_.defaults(existingProperties, defaults));
	    AppDispatcher.register("unload-app", this.flush.bind(this));
	  }

	  _inherits(PersistentStore, Store);

	  _prototypeProperties(PersistentStore, null, {
	    flush: {
	      value: function flush() {
	        Storage.set(this.id, this.getAll());
	      },
	      writable: true,
	      configurable: true
	    },
	    getStoreId: {

	      /**
	       * Returns the ID of the current store.
	       *
	       * @return String The Store ID
	       */

	      value: function getStoreId() {},
	      writable: true,
	      configurable: true
	    }
	  });

	  return PersistentStore;
	})(Store);

	module.exports = PersistentStore;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ChatWindowActions = __webpack_require__(33);
	var Message = __webpack_require__(130);
	var NotificationMessage = __webpack_require__(131);
	var InfoMessage = __webpack_require__(132);
	var FileMessage = __webpack_require__(133);
	var LinkMessage = __webpack_require__(134);
	var ImageMessage = __webpack_require__(135);
	var VideoMessage = __webpack_require__(136);
	var UserStateMessage = __webpack_require__(137);
	var TwitterStatusMessage = __webpack_require__(138);
	var TwitterUserMessage = __webpack_require__(139);
	var ClientPreferencesStore = __webpack_require__(38);
	var cx = React.addons.classSet;
	var Utils = __webpack_require__(4);

	var message_types = {
	  message: Message,
	  notification: NotificationMessage,
	  info: InfoMessage,
	  file: FileMessage,
	  link: LinkMessage,
	  image: ImageMessage,
	  video: VideoMessage,
	  user_state: UserStateMessage,
	  twitter_status: TwitterStatusMessage,
	  twitter_user: TwitterUserMessage
	};

	module.exports = React.createClass({

	  displayName: "ChatWindowMessageGroup",

	  _getMessageType: function _getMessageType(message) {
	    var MessageType = message_types[message.type];
	    if (MessageType) {
	      return React.createElement(MessageType, { key: message.mid, msg: message, _setScroll: this.props._setScroll, use24hrTime: this.props.use24hrTime, shouldHideGifs: this.props.shouldHideGifs });
	    }
	  },

	  render: function render() {
	    var _this = this;

	    var senderText = this.props.msg.sender;
	    if (this.props.msg.type === "image") {
	      senderText = "Image";
	    } else if (this.props.msg.isEmote) {
	      senderText = "";
	    }

	    var lastViewedClass = this.groupContainsLastViewed() && ClientPreferencesStore.shouldShowUnreadMessageDivider() ? "last-viewed" : "";
	    var allFailed = this.props.msg.status === "failed" && !_.some(this.props.msg.messages, function (msg) {
	      return msg.status !== "failed";
	    });
	    var show_time = ! ~["image", "user_state", "twitter_status", "twitter_user", "info"].indexOf(this.props.msg.type);
	    var show_avatar = this.props.show_avatars && this.props.msg.sender_avatar && this.props.msg.type != "info";
	    var time = show_time ? React.createElement(
	      "div",
	      { className: "hc-chat-time" },
	      this.props.msg.display_time
	    ) : false;
	    return React.createElement(
	      "div",
	      { className: cx(_.object([["hc-chat-row", true], ["hc-msg-" + this.props.msg.color + " hc-msg-" + this.props.msg.type, true], ["fade", !this.props.msg.is_echo], ["hc-msg-failed", allFailed], ["show-avatars", this.props.show_avatars], [lastViewedClass, lastViewedClass]])), key: this.props.msg.mid },
	      React.createElement(
	        "div",
	        { className: cx({
	            "hc-chat-from": true,
	            invisible: this.props.msg.type == "user_state"
	          }), onClick: this.onSenderClicked, "data-mention": this.props.msg.sender_mention },
	        show_avatar ? React.createElement(
	          "span",
	          { className: "aui-avatar aui-avatar-medium" },
	          React.createElement(
	            "span",
	            { className: "aui-avatar-inner" },
	            React.createElement("img", { src: this.props.msg.sender_avatar, width: "32" })
	          )
	        ) : false,
	        !this.props.show_avatars ? React.createElement(
	          "span",
	          { className: "sender-name" },
	          senderText
	        ) : false
	      ),
	      React.createElement(
	        "div",
	        { className: cx({
	            "hc-chat-msg": true,
	            "image-link": this.props.msg.type == "image"
	          }) },
	        this.props.show_avatars ? React.createElement(
	          "span",
	          { className: "sender-name" },
	          senderText
	        ) : false,
	        show_time && this.props.show_avatars ? React.createElement(
	          "span",
	          null,
	          React.createElement(
	            "span",
	            { className: "time-separator" },
	            "·"
	          ),
	          time
	        ) : { time: time },
	        _.uniq(this.props.msg.messages).map(function (message) {
	          try {
	            return _this._getMessageType(message);
	          } catch (e) {
	            Utils.log("[ERROR]", message);
	          }
	        }, this)
	      )
	    );
	  },
	  onSenderClicked: function onSenderClicked(e) {
	    e.preventDefault();
	    var mentionName = e.currentTarget.getAttribute("data-mention");
	    if (mentionName) {
	      ChatWindowActions.senderClick({ mention: "@" + mentionName });
	    }
	  },

	  groupContainsLastViewed: function groupContainsLastViewed() {
	    return this.props.show_unread_divider && _.map(this.props.msg.messages, function (msg) {
	      return msg.mid.split("-link")[0];
	    }).indexOf(this.props.last_viewed_mid) != -1;
	  }

	});

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "ChatWindowEmptyState",

	  render: function render() {

	    return React.createElement(
	      "div",
	      { className: "empty" },
	      /@chat/.test(this.props.chat.jid) ? React.createElement(
	        "div",
	        { className: "empty-state chat" },
	        React.createElement("div", { className: "empty-state-img" }),
	        React.createElement(
	          "div",
	          { className: "empty-state-msg" },
	          React.createElement(
	            "p",
	            { className: "empty-header" },
	            "Say Hello to ",
	            this.props.chat.name.split(" ")[0],
	            "!"
	          ),
	          React.createElement(
	            "p",
	            { className: "empty-msg" },
	            "You haven't talked to ",
	            this.props.chat.name.split(" ")[0],
	            " before. Why not break the ice with",
	            React.createElement("br", null),
	            "an emoticon? (fonzie) ",
	            React.createElement("img", { src: "wc/assets/img/embedded/fonzie@3x.png", width: "34", height: "25" })
	          )
	        )
	      ) : React.createElement(
	        "div",
	        { className: "empty-state groupchat" },
	        React.createElement("div", { className: "empty-state-img" }),
	        React.createElement(
	          "div",
	          { className: "empty-state-msg" },
	          React.createElement(
	            "p",
	            { className: "empty-header" },
	            "Welcome to the ",
	            this.props.chat.name,
	            " room!"
	          ),
	          React.createElement(
	            "p",
	            { className: "empty-msg" },
	            "This window is kinda empty, huh? It fills up fast when you",
	            React.createElement("br", null),
	            "start chatting with your friends. Happy chatting!"
	          )
	        )
	      )
	    );
	  }

	});

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Utils = __webpack_require__(4),
	    EventEmitter = __webpack_require__(110).EventEmitter;

	var Emitter = (function (EventEmitter) {
	  function Emitter() {
	    _classCallCheck(this, Emitter);

	    if (EventEmitter != null) {
	      EventEmitter.apply(this, arguments);
	    }
	  }

	  _inherits(Emitter, EventEmitter);

	  _prototypeProperties(Emitter, null, {
	    on: {
	      value: function on(type, callback) {
	        var _this4 = this;

	        var _this = this;

	        Utils.toArray(type).forEach(function (t) {
	          return _get(Object.getPrototypeOf(Emitter.prototype), "on", _this).call(_this4, t, callback);
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    once: {
	      value: function once(type, callback) {
	        var _this4 = this;

	        var _this2 = this;

	        Utils.toArray(type).forEach(function (t) {
	          return _get(Object.getPrototypeOf(Emitter.prototype), "once", _this2).call(_this4, t, callback);
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    off: {
	      value: function off(type, callback) {
	        var _this4 = this;

	        var _this3 = this;

	        Utils.toArray(type).forEach(function (t) {
	          return _get(Object.getPrototypeOf(Emitter.prototype), "removeListener", _this3).call(_this4, t, callback);
	        });
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return Emitter;
	})(EventEmitter);

	module.exports = Emitter;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);

	var dispatcher = __webpack_require__(1);

	var InlineDialogStore = (function (Store) {
	  function InlineDialogStore() {
	    _classCallCheck(this, InlineDialogStore);

	    this.data = {
	      visibleDialog: false,
	      dialogData: false
	    };

	    this.registerListeners();
	  }

	  _inherits(InlineDialogStore, Store);

	  _prototypeProperties(InlineDialogStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        dispatcher.register({
	          "show-inline-dialog": function (data) {
	            _this._showInlineDialog(data);
	          },
	          "hide-inline-dialog": function () {
	            _this._hideInlineDialog();
	          },
	          "toggle-inline-dialog": function (data) {
	            _this._toggleInlineDialog(data);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    _toggleInlineDialog: {
	      value: function _toggleInlineDialog(data) {
	        // Show a new dialog if it is different to the current one
	        if (data.dialog_type !== this.getCurrentInlineDialog()) {
	          this._showInlineDialog(data);
	        } else {
	          // Otherwise the new and current are the same so we hide it
	          this._hideInlineDialog();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    _showInlineDialog: {
	      value: function _showInlineDialog(data) {
	        this.set({
	          visibleDialog: data.dialog_type,
	          dialogData: data.dialog_data
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    _hideInlineDialog: {
	      value: function _hideInlineDialog() {
	        if (this.getCurrentInlineDialog() !== false) {
	          this.set({
	            visibleDialog: false,
	            dialogData: false
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getCurrentInlineDialog: {
	      value: function getCurrentInlineDialog() {
	        return this.get("visibleDialog");
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return InlineDialogStore;
	})(Store);

	module.exports = new InlineDialogStore();

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var fileHelper = module.exports = {

	  /**
	   * Returns true if the click event was triggered by a left click
	   * @param  {event} event
	   * @return {bool}
	   */
	  shouldOpenFileViewer: function shouldOpenFileViewer(event) {
	    return event.button === 0;
	  },

	  /**
	   * Returns the filename from a path.
	   * @param {string} path
	   * @returns {string} filename
	   */
	  basename: function basename(path) {
	    return path.split("/").pop();
	  },

	  /**
	   * Check if FileViewer supports previewing the given file.
	   * @param {object} file
	   * @returns {boolean} is file supported
	   */
	  fileViewerSupports: function fileViewerSupports(file) {
	    var normalized = this._normalizeFile(file);
	    return this._guessMimeType(normalized) !== "unknown";
	  },

	  /**
	   * Transform a file to the format used by fileviewer.
	   * @param {object} file
	   * @returns {boolean} FileViewer file
	   */
	  transformForFileViewer: function transformForFileViewer(file) {
	    var normalized = this._normalizeFile(file);
	    var item = {
	      src: normalized.url,
	      title: normalized.name,
	      type: this._guessMimeType(normalized),
	      downloadable: this._isDownloadable(normalized),
	      date: normalized.date
	    };

	    if (item.type === "video/youtube") {
	      item.title = file.title || "Youtube Video";
	    }

	    return item;
	  },

	  /**
	   * A file can either be an uploaded file or a link to a file.
	   * @param {object} file
	   * @returns {object} normalized file
	   */
	  _normalizeFile: function _normalizeFile(file) {
	    return {
	      url: file.image || file.file_url || file.url,
	      name: this.basename(file.name || file.title || file.url),
	      date: file.date || ""
	    };
	  },

	  /**
	   * Guesses the mimetype for a given file based on the path.
	   * @param {object} normalized file
	   * @returns {string} mimetype
	   */
	  _guessMimeType: function _guessMimeType(file) {
	    var url = (file.url || "").toLowerCase();

	    var isImage = url.match(/(png)|(jpg)|(jpeg)|(gif)|(svg)$/i);
	    var isDoc = url.match(/pdf$/i);
	    var isAudio = url.match(/mp3$/i);
	    var isVideo = url.match(/mp4$/i);
	    var isYoutube = url.match(/(youtube\.com)|(youtu\.be)/i);

	    if (isImage) {
	      return "image/" + isImage[0].replace("jpg", "jpeg").replace("svg", "svg+xml");
	    }
	    if (isDoc) {
	      return "application/pdf";
	    }
	    if (isYoutube) {
	      return "video/youtube";
	    }
	    if (isVideo) {
	      return "video/mp4";
	    }
	    if (isAudio) {
	      return "audio/mp3";
	    }

	    return "unknown";
	  },

	  /**
	   * Check if a file is downloadable.
	   * @param {object} normalized file
	   * @returns {boolean} is downloadable
	   */
	  _isDownloadable: function _isDownloadable(file) {
	    return this._guessMimeType(file) !== "video/youtube";
	  }

	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var AppDispatcher = __webpack_require__(1);
	var PreferencesStore = __webpack_require__(21);
	var ClientPreferencesStore = __webpack_require__(38);
	var ClientPrefKeys = __webpack_require__(39);
	var Store = __webpack_require__(43);
	var Utils = __webpack_require__(4);

	var RosterStore = (function (Store) {
	  function RosterStore() {
	    _classCallCheck(this, RosterStore);

	    if (Store != null) {
	      Store.apply(this, arguments);
	    }
	  }

	  _inherits(RosterStore, Store);

	  _prototypeProperties(RosterStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          admins: [],
	          current_user: {},
	          users: {},
	          rooms: {},
	          files: [],
	          links: [],
	          loading: false,
	          participants: {
	            members: [],
	            guests: []
	          },
	          initialized: false,
	          active_chat: null,
	          active_chat_privacy: null,
	          guest_url: "",
	          chat_type: ""
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.registerOnce({
	          "hc-init": function () {
	            _this.data.active_chat = PreferencesStore.getChatToFocus();
	            _this.fetchPanelContent(_this.data.active_chat);
	          }
	        });
	        AppDispatcher.register({
	          "updated:current_user": function (user) {
	            _this.data.current_user = user;
	          },
	          "updated:preferences": function (prefs) {
	            _this.data.active_chat = prefs.chatToFocus;
	          },
	          "updated:roster": function (roster) {
	            _this.handleRosterUpdate(roster);
	          },
	          "app-state-ready": function () {
	            _this.data.initialized = true;
	          },
	          "fetch-files": function () {
	            if (_this.getActivePanel(_this.data.chat_type) == "files") {
	              _this.set("loading", true);
	            }
	          },
	          "files-fetched": function () {
	            _this.set("loading", false);
	            _this.handleSelectRoom(_this.data.active_chat);
	          },
	          "add-file": function (data) {
	            if (data.room == _this.data.active_chat) {
	              _this.handleNewFile(data.file);
	            }
	          },
	          "fetch-links": function () {
	            if (_this.getActivePanel(_this.data.chat_type) == "links") {
	              _this.set("loading", true);
	            }
	          },
	          "links-fetched": function () {
	            _this.set("loading", false);
	            _this.handleSelectRoom(_this.data.active_chat);
	          },
	          "add-link": function (data) {
	            if (data.room == _this.data.active_chat) {
	              _this.handleNewLink(data.link);
	            }
	          },
	          "new-room-created": function (room) {
	            _this.handleNewRoom(room);
	          },
	          "mark-participant-unknown": function (data) {
	            _this.markParticipantForPrivateRoom(data);
	          },
	          "unmark-participant": function (data) {
	            _this.unmarkParticipantForPrivateRoom(data);
	          },
	          "updated:active_chat": function (jid) {
	            _this.handleSelectRoom(jid);
	            _this.fetchPanelContent(jid);
	          },
	          "updated:activeRooms": function (rooms) {
	            _this.handleActiveRoomsUpdate(rooms);
	          },
	          "select-panel": function (data) {
	            _this.selectPanel(data);
	          },
	          "open-room": function (room) {
	            _this.data.active_chat = room.jid;
	            _this.handleSelectRoom(room.jid);
	            _this.fetchPanelContent(room.jid);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    saveClientPrefs: {
	      value: function saveClientPrefs() {
	        AppDispatcher.dispatch("save-client-preferences", ClientPreferencesStore.getAll());
	      },
	      writable: true,
	      configurable: true
	    },
	    selectPanel: {
	      value: function selectPanel(data) {
	        if (this.shouldToggleSidebar(data.activePanel)) {
	          this.toggleSidebar(this.data.chat_type);
	        }
	        this.setPanel(data.activePanel);
	        this.fetchPanelContent(this.data.active_chat);
	        this.saveClientPrefs();
	      },
	      writable: true,
	      configurable: true
	    },
	    setPanel: {
	      value: function setPanel(panel) {
	        if (this.data.chat_type === "chat") {
	          ClientPreferencesStore.set(ClientPrefKeys.CHAT_ACTIVE_PANEL, panel);
	        } else if (this.data.chat_type === "groupchat") {
	          ClientPreferencesStore.set(ClientPrefKeys.GROUPCHAT_ACTIVE_PANEL, panel);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    shouldToggleSidebar: {
	      value: function shouldToggleSidebar(panel) {
	        var result = false;
	        if (this.data.chat_type == "chat") {
	          result = panel == ClientPreferencesStore.getChatActivePanel() || !ClientPreferencesStore.shouldShowChatSidebar();
	        } else if (this.data.chat_type == "groupchat") {
	          result = panel == ClientPreferencesStore.getGroupChatActivePanel() || !ClientPreferencesStore.shouldShowGroupChatSidebar();
	        }
	        return result;
	      },
	      writable: true,
	      configurable: true
	    },
	    toggleSidebar: {
	      value: function toggleSidebar(chat_type) {
	        if (chat_type == "chat") {
	          ClientPreferencesStore.set(ClientPrefKeys.SHOW_CHAT_SIDEBAR, !ClientPreferencesStore.shouldShowChatSidebar());
	        } else if (chat_type == "groupchat") {
	          ClientPreferencesStore.set(ClientPrefKeys.SHOW_GROUPCHAT_SIDEBAR, !ClientPreferencesStore.shouldShowGroupChatSidebar());
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    sidebarShowing: {
	      value: function sidebarShowing(jid) {
	        return Utils.room.detect_chat_type(jid) == "chat" && ClientPreferencesStore.shouldShowChatSidebar() || Utils.room.detect_chat_type(jid) == "groupchat" && ClientPreferencesStore.shouldShowGroupChatSidebar();
	      },
	      writable: true,
	      configurable: true
	    },
	    getActivePanel: {
	      value: function getActivePanel(chat_type) {
	        if (chat_type == "chat") {
	          return ClientPreferencesStore.getChatActivePanel();
	        } else if (chat_type == "groupchat") {
	          return ClientPreferencesStore.getGroupChatActivePanel();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    fetchPanelContent: {
	      value: function fetchPanelContent(jid) {
	        // Only fetch if sidebar is visible
	        if (jid !== "lobby" && this.sidebarShowing(jid)) {
	          var event;
	          switch (this.getActivePanel(this.data.chat_type)) {
	            case "files":
	              event = "fetch-files";
	              break;
	            case "links":
	              event = "fetch-links";
	              break;
	          }
	          if (event) {
	            AppDispatcher.dispatch(event, { room: jid });
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    markParticipantForPrivateRoom: {
	      value: function markParticipantForPrivateRoom(data) {
	        if (this.data.users[data.user]) {
	          this.data.users[data.user].not_participating ? this.data.users[data.user].not_participating.push(data.room) : this.data.users[data.user].not_participating = [data.room];
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    unmarkParticipantForPrivateRoom: {
	      value: function unmarkParticipantForPrivateRoom(data) {
	        if (this.data.users[data.user] && this.data.users[data.user].not_participating && this.data.users[data.user].not_participating.indexOf(data.room) != -1) {
	          this.data.users[data.user].not_participating = _.without(this.data.users[data.user].not_participating, data.room);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    sortRoster: {
	      value: function sortRoster(roster) {
	        var temp = [],
	            grouped = _.groupBy(roster, function (person) {
	          return Utils.dot(person, "presence.show", false);
	        });
	        _.each(["chat", "away", "dnd", "mobile", "unavailable", "unknown"], function (presence) {
	          _.each(_.sortBy(grouped[presence], "name"), function (room) {
	            temp.push(room);
	          });
	        });
	        return temp;
	      },
	      writable: true,
	      configurable: true
	    },
	    handleActiveRoomsUpdate: {
	      value: function handleActiveRoomsUpdate(rooms) {
	        var deleted = _.difference(_.keys(this.data.rooms), _.keys(rooms));
	        if (deleted.length) {
	          this.data.rooms = _.omit(this.data.rooms, deleted);
	        } else {
	          this.data.rooms = _.merge(this.data.rooms, rooms);
	        }
	        if (this.data.active_chat && this.data.active_chat != "lobby") {
	          this.data.rooms[this.data.active_chat] = rooms[this.data.active_chat];
	          this.handleSelectRoom(this.data.active_chat);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRosterUpdate: {
	      value: function handleRosterUpdate(roster) {
	        var _this = this;

	        _.map(this.data.participants, function (group, role) {
	          if (_this.data.participants[role].length) _this.sortRoster(_this.data.participants[role]);
	        });
	        this.data.users = roster;
	        this.handleSelectRoom(this.data.active_chat);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleNewRoom: {
	      value: function handleNewRoom(room) {
	        this.set({
	          active_chat: room.jid,
	          chat_type: Utils.room.detect_chat_type(room.jid)
	        });
	        if (room.privacy === "private") {
	          AppDispatcher.dispatch("show-modal-dialog", "invite-users-dialog");
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleNewLink: {
	      value: function handleNewLink(link) {
	        if (!this.data.links) {
	          this.data.links = [];
	        }
	        this.data.links.unshift(link);
	        this.set("links", this.data.links);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleNewFile: {
	      value: function handleNewFile(file) {
	        if (!this.data.files) {
	          this.data.files = [];
	        }
	        this.data.files.unshift(file);
	        this.set("files", this.data.files);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleSelectRoom: {
	      value: function handleSelectRoom(jid) {
	        var _this = this;

	        if (!jid || jid === "lobby") {
	          return;
	        }

	        var type = Utils.room.detect_chat_type(jid),
	            room_privacy,
	            files,
	            links,
	            admins,
	            new_data,
	            guest_url;

	        this.data.participants = {
	          members: [],
	          guests: []
	        };

	        if (this.data.rooms[jid]) {
	          room_privacy = this.data.rooms[jid].privacy;
	          guest_url = this.data.rooms[jid].guest_url;
	          files = this.data.rooms[jid].files;
	          links = this.data.rooms[jid].links;
	          admins = this.data.rooms[jid].admins;
	          type = this.data.rooms[jid].type;
	          _.map(this.data.rooms[jid].participants, function (group, role) {
	            _.each(group, function (user_jid) {
	              if (_this.data.rooms[jid].privacy === "private") {
	                if (_this.data.users[user_jid] && _this.data.users[user_jid].not_participating && _this.data.users[user_jid].not_participating.indexOf(jid) != -1) {
	                  _this.data.participants[role].push(_.assign({}, _this.data.users[user_jid], {
	                    presence: {
	                      show: "unknown",
	                      status: "",
	                      idleTime: false
	                    }
	                  }));
	                } else {
	                  _this.data.participants[role].push(_this.data.users[user_jid]);
	                }
	              } else {
	                _this.data.participants[role].push(_this.data.users[user_jid]);
	              }
	            });
	            _this.data.participants[role] = _this.sortRoster(_this.data.participants[role]);
	          });
	        }
	        new_data = {
	          admins: admins,
	          users: this.data.users,
	          participants: this.data.participants,
	          active_chat: jid,
	          active_chat_privacy: room_privacy,
	          chat_type: type,
	          files: files,
	          links: links,
	          guest_url: guest_url,
	          loading: this.data.loading
	        };
	        this.set(new_data);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return RosterStore;
	})(Store);

	module.exports = new RosterStore();

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var AppActions = _interopRequire(__webpack_require__(44));

	var InlineDialog = _interopRequire(__webpack_require__(222));

	var InlineDialogActions = _interopRequire(__webpack_require__(51));

	var AppDispatcher = _interopRequire(__webpack_require__(1));

	module.exports = React.createClass({
	  displayName: "invite_users_inline_dialog",

	  componentDidMount: function componentDidMount() {
	    AppDispatcher.register("position-invite-dialog", this._positionDialog);
	    this._positionDialog();
	    this._getIframe().on("load", this._onIframeLoad);
	    AJS.$("#invite-user-form >.aui-inline-dialog-contents").spin("large");
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this._getIframe().off("load", this._onIframeLoad);
	    AppDispatcher.unregister("position-invite-dialog", this._positionDialog);
	  },

	  _onIframeLoad: function _onIframeLoad() {
	    var _this = this;

	    this._positionDialog();
	    AJS.$("#invite-user-form >.aui-inline-dialog-contents").spinStop();
	    this._getIframe().addClass("loaded");
	    var $body = $(this._getIframeBody());
	    $body.find("#btn_copy_invite_link").remove();
	    $body.find(".external-link").click(function (e) {
	      var $target = $(e.target);
	      $target.attr("target", "_blank");
	      $target.attr("href", _this._getExternalUrl($target.attr("href")));
	    });
	    $body.find("a[href='#hcnative:close']").click(this._close);
	  },

	  _getExternalUrl: function _getExternalUrl(href) {
	    var url;

	    var key = "#hcnative:externalLinkClicked:";
	    var uri = decodeURIComponent(href.substr(href.indexOf(key) + key.length));

	    if (uri.indexOf(key) > -1) {
	      try {
	        var data = JSON.parse(uri);
	        url = data.url;
	      } catch (e) {}
	    }

	    return url;
	  },

	  _getIframe: function _getIframe() {
	    return $(this.refs.inviteUsersIframe.getDOMNode());
	  },

	  _getIframeBody: function _getIframeBody() {
	    return this._getIframe().get(0).contentWindow.document.body;
	  },

	  _close: function _close() {
	    InlineDialogActions.hideInlineDialog();
	  },

	  _positionDialog: function _positionDialog() {
	    var btn = this.props.button ? this.props.button : document.querySelector(".aui-header-primary a.hc-invite-users");
	    var top = btn.getBoundingClientRect().bottom + 5;
	    $(this.getDOMNode()).css("top", top + "px");
	  },

	  render: function render() {
	    return React.createElement(
	      InlineDialog,
	      { dialogId: "invite-user-form" },
	      React.createElement("iframe", { ref: "inviteUsersIframe", src: "/native/invite" })
	    );
	  }
	});

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var InlineDialog = __webpack_require__(222);
	var PresenceIcon = __webpack_require__(118);
	var Utils = __webpack_require__(4);
	var AppHeaderActions = __webpack_require__(48);

	module.exports = React.createClass({

	  displayName: "UserStatusMessageForm",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      visible: false
	    };
	  },

	  _getStatusInput: function _getStatusInput() {
	    return this.getDOMNode().querySelectorAll("input[name='status-message']")[0];
	  },

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var input = this._getStatusInput();
	    AppHeaderActions.setStatus({
	      show: this.props.presence.show,
	      status: input.value
	    });
	  },

	  _onShow: function _onShow() {
	    var input = this._getStatusInput();
	    input.value = "";
	    input.focus();
	  },

	  render: function render() {
	    return React.createElement(
	      InlineDialog,
	      { dialogId: "userStatusMessage", onShow: this._onShow },
	      React.createElement(
	        "form",
	        { id: "userStatusForm", className: "aui aui-group", onSubmit: this._onSubmit },
	        React.createElement(
	          "div",
	          { className: "aui-item status-icon" },
	          React.createElement(PresenceIcon, { presence: this.props.presence.show })
	        ),
	        React.createElement(
	          "div",
	          { className: "aui-item status-message" },
	          React.createElement("input", { type: "text", className: "text", placeholder: "Set your status", name: "status-message" })
	        ),
	        React.createElement(
	          "div",
	          { className: "aui-item" },
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-small", type: "submit" },
	            "OK"
	          )
	        )
	      )
	    );
	  }

	});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var InlineDialog = __webpack_require__(222),
	    InlineDialogActions = __webpack_require__(51),
	    AppDispatcher = __webpack_require__(1),
	    IFrameMessenger = __webpack_require__(223),
	    AceStpStore = __webpack_require__(224),
	    HelpMenu = __webpack_require__(225),
	    Utils = __webpack_require__(4),
	    AceStpStrings = __webpack_require__(226);

	module.exports = React.createClass({

	  displayName: "AceStpInlineDialog",

	  componentDidMount: function componentDidMount() {
	    this.iFrameMessenger = new IFrameMessenger(this.refs.aceStpFrame.getDOMNode(), this._handleMessage);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this.iFrameMessenger.destroy();
	  },

	  _handleMessage: function _handleMessage(message) {
	    var data = {};
	    try {
	      data = JSON.parse(message.data);
	    } catch (e) {
	      Utils.log("[ERROR]", "Message from ACE STP was invalid JSON: " + e);
	    }

	    if (data.source === "ace.stp.CrossOriginMessenger") {
	      if (data.type === "message notification") {
	        AppDispatcher.dispatch("ace-stp-button-update", data.payload);
	      }
	    }
	  },

	  _close: function _close() {
	    InlineDialogActions.hideInlineDialog();
	  },

	  _sendDialogOpenedEvent: function _sendDialogOpenedEvent() {
	    if (this.iFrameMessenger) {
	      this.iFrameMessenger.postMessage({ type: "dialog opened", payload: {}, source: "ace.stp.CrossOriginMessenger" });
	    }
	  },

	  _showDialog: function _showDialog() {
	    this._sendDialogOpenedEvent();
	  },

	  _getIFrameUrl: function _getIFrameUrl() {
	    return AceStpStore.getIFrameUrl() + "?domain=" + window.location.origin;
	  },

	  render: function render() {
	    return React.createElement(
	      InlineDialog,
	      { dialogId: "ace-stp-inline-dialog", invisible: this.props.invisible, onShow: this._showDialog },
	      React.createElement(
	        "div",
	        { id: "ace-stp-section" },
	        React.createElement(
	          "div",
	          { id: "ace-stp-help-section" },
	          React.createElement(
	            "h1",
	            { className: "ace-stp-heading" },
	            AceStpStrings.help
	          ),
	          React.createElement(
	            "form",
	            { id: "ace-stp-search-form", className: "aui", target: "_blank", method: "get", action: "http://help.hipchat.com/search" },
	            React.createElement("span", { id: "ace-stp-icon-search", className: "aui-icon aui-icon-large aui-iconfont-search" }),
	            React.createElement("input", { id: "ace-stp-search-form-input", name: "query", className: "text", type: "text", placeholder: AceStpStrings.ask_a_question })
	          ),
	          React.createElement(HelpMenu, { onClick: this._close })
	        ),
	        React.createElement(
	          "div",
	          { id: "ace-stp-message-section" },
	          React.createElement("iframe", { src: this._getIFrameUrl(), ref: "aceStpFrame",
	            frameBorder: "0", scrolling: "no", width: "649", height: "370" })
	        )
	      )
	    );
	  }
	});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);

	var dispatcher = __webpack_require__(1);

	var ModalDialogStore = (function (Store) {
	  function ModalDialogStore() {
	    _classCallCheck(this, ModalDialogStore);

	    this.data = {
	      visibleDialog: false,
	      dialogData: false,
	      btnLoading: false
	    };

	    this.registerListeners();
	  }

	  _inherits(ModalDialogStore, Store);

	  _prototypeProperties(ModalDialogStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        dispatcher.register({
	          "show-modal-dialog": function (data) {
	            _this.set({
	              visibleDialog: data.dialog_type,
	              dialogData: data.dialog_data,
	              btnLoading: false
	            });
	          },
	          "hide-modal-dialog": function () {
	            _this.set({
	              visibleDialog: false,
	              dialogData: false,
	              btnLoading: false
	            });
	          },
	          "modal-dialog-btn-loading": function (data) {
	            _this.set({
	              btnLoading: data.loading
	            });
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    getCurrentModalDialog: {
	      value: function getCurrentModalDialog() {
	        return this.get("visibleDialog");
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return ModalDialogStore;
	})(Store);

	module.exports = new ModalDialogStore();

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var DialogActions = __webpack_require__(28);

	module.exports = React.createClass({

	  displayName: "ModalDialogBackdrop",

	  componentDidMount: function componentDidMount() {
	    document.querySelector("body").addEventListener("keydown", this._onKeydown);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    document.querySelector("body").removeEventListener("keydown", this._onKeydown);
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      btnLoading: false
	    };
	  },

	  _onKeydown: function _onKeydown(e) {
	    var intKey = window.Event ? e.which : e.keyCode;
	    if (intKey === 27 && !this.props.btnLoading) {
	      this.close();
	    }
	  },

	  _onClick: function _onClick(e) {
	    if (!this.props.btnLoading) {
	      this.close();
	    }
	  },

	  close: function close() {
	    DialogActions.closeDialog();
	  },

	  render: function render() {
	    return React.createElement("div", { className: "aui-blanket", "aria-hidden": "false", tabIndex: "0", onClick: this._onClick });
	  }
	});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    NavPanel = __webpack_require__(228),
	    NavPanelContent = __webpack_require__(229),
	    PreferenceCheckboxField = __webpack_require__(230),
	    PreferenceRadioField = __webpack_require__(231),
	    PreferencesStore = __webpack_require__(21),
	    ClientPreferencesStore = __webpack_require__(38),
	    PreferencesActions = __webpack_require__(53),
	    PreferencesKeys = __webpack_require__(68),
	    strings = __webpack_require__(232),
	    ClientPreferencesKeys = __webpack_require__(39);

	module.exports = React.createClass({

	  displayName: "SettingsDialog",

	  componentDidMount: function componentDidMount() {
	    PreferencesStore.on("change", this._onChange);
	    ClientPreferencesStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    PreferencesStore.off("change", this._onChange);
	    ClientPreferencesStore.off("change", this._onChange);
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  getInitialState: function getInitialState() {
	    return this._getState();
	  },

	  _getState: function _getState() {
	    var prefs = {};
	    var preferences = PreferencesStore.getAll();
	    var clientPreferences = ClientPreferencesStore.getAll();

	    _.assign(prefs, preferences, clientPreferences);

	    return prefs;
	  },

	  _dialogBody: function _dialogBody() {
	    var appearanceSettings;
	    if (this.state.features && this.state.features.web_client_appearance_settings || HC.ENV !== "production") {
	      appearanceSettings = React.createElement(
	        NavPanelContent,
	        { name: "Appearance" },
	        React.createElement(
	          "form",
	          { className: "aui" },
	          React.createElement(PreferenceRadioField, { id: ClientPreferencesKeys.THEME, label: strings.theme,
	            options: ClientPreferencesStore.getThemeOptions() }),
	          React.createElement(PreferenceRadioField, { id: ClientPreferencesKeys.DENSITY, label: strings.density,
	            options: ClientPreferencesStore.getDensityOptions() }),
	          React.createElement(PreferenceCheckboxField, { id: ClientPreferencesKeys.SHOW_AVATARS, label: strings.show_avatars })
	        )
	      );
	    } else {
	      appearanceSettings = React.createElement("span", { name: "Appearance" });
	    }
	    return React.createElement(
	      NavPanel,
	      { onChange: this._onPreferenceChanged },
	      React.createElement(
	        NavPanelContent,
	        { name: "Notifications" },
	        React.createElement(
	          "form",
	          { className: "aui" },
	          React.createElement(
	            "h3",
	            null,
	            "Notify me when"
	          ),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.NOTIFY_FOR_ROOM, label: strings.notify_for_room }),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.NOTIFY_FOR_PRIVATE_ROOM, label: strings.notify_for_private_room }),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.NOTIFY_FOR_TAG, label: strings.notify_for_tag }),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.NOTIFY_FOR_PRIVATE, label: strings.notify_for_private }),
	          React.createElement(
	            "h3",
	            null,
	            "Notify me by"
	          ),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.DISABLE_SOUNDS, label: strings.disable_sounds, value: "false", isReverse: true }),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.SHOW_TOASTERS, label: strings.show_toasters })
	        )
	      ),
	      React.createElement(
	        NavPanelContent,
	        { name: "General settings" },
	        React.createElement(
	          "form",
	          { className: "aui" },
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.HIDE_PRESENCE_MESSAGES, label: strings.hide_presence_messages, value: "false", isReverse: true }),
	          React.createElement(PreferenceCheckboxField, { id: PreferencesKeys.USE_24_HR_FORMAT, label: strings.use_24_hour_format }),
	          React.createElement(PreferenceCheckboxField, { id: ClientPreferencesKeys.HIDE_GIFS_BY_DEFAULT, label: strings.hide_gifs_by_default }),
	          React.createElement(PreferenceCheckboxField, { id: ClientPreferencesKeys.REPLACE_TEXT_EMOTICONS, label: strings.replace_text_emoticons }),
	          React.createElement(PreferenceCheckboxField, { id: ClientPreferencesKeys.SHOW_UNREAD_DIVIDER, label: strings.show_unread_divider })
	        )
	      ),
	      appearanceSettings
	    );
	  },

	  _getPreference: function _getPreference(target) {
	    var value = target.value === "true";
	    var pref = {};
	    pref[target.id] = target.checked ? value : !value;

	    return pref;
	  },

	  _getRadioPreference: function _getRadioPreference(target) {
	    var checked = document.querySelector("input[name=\"" + target.name + "\"]:checked"),
	        pref = {};
	    pref[target.name] = checked.id;
	    return pref;
	  },

	  _onPreferenceChanged: function _onPreferenceChanged(e) {
	    var target = e.target;
	    var data = target.type === "radio" ? this._getRadioPreference(target) : this._getPreference(target);
	    var isServerPref = _.contains(_.values(PreferencesKeys), target.id);
	    if (isServerPref) {
	      PreferencesActions.savePreferences(data);
	    } else {
	      PreferencesActions.saveClientPreferences(data);
	    }
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "settings-dialog", title: "Settings", dialogBody: this._dialogBody });
	  }
	});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    InviteUsersForm = __webpack_require__(233),
	    strings = __webpack_require__(232),
	    RoomsNavStore = __webpack_require__(122),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "InviteUserDialog",

	  componentDidMount: function componentDidMount() {
	    RoomsNavStore.on(["change"], this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    RoomsNavStore.off(["change"], this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },

	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: RoomsNavStore.get("active_chat"),
	      rooms: RoomsNavStore.get("rooms")
	    };
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getActiveChatState());
	  },

	  _dialogTitle: function _dialogTitle() {
	    return strings.invite_users(Utils.room.get_room_name(_.indexBy(this.state.rooms.rooms, "jid"), this.state.active_chat));
	  },

	  _dialogBody: function _dialogBody() {
	    if (Utils.jid.is_room(this.state.active_chat)) {
	      return React.createElement(InviteUsersForm, { room_jid: this.state.active_chat });
	    }
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { form: "invite-users-form", className: "aui-button aui-button-primary", type: "submit" },
	      "Invite people"
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "invite-users-dialog",
	      title: this._dialogTitle(),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel" });
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    strings = __webpack_require__(232),
	    RemoveUsersForm = __webpack_require__(236);

	module.exports = React.createClass({

	  displayName: "RemoveUserDialog",

	  _dialogTitle: function _dialogTitle() {
	    return strings.choose_removed_members;
	  },

	  _dialogBody: function _dialogBody() {
	    return React.createElement(RemoveUsersForm, null);
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { form: "remove-users-form", className: "aui-button aui-button-primary", type: "submit" },
	      strings.ok
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "remove-users-dialog",
	      title: this._dialogTitle(),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel",
	      size: "small" });
	  }
	});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    strings = __webpack_require__(232),
	    CreateRoomForm = __webpack_require__(237);

	module.exports = React.createClass({

	  displayName: "CreateRoomDialog",

	  _dialogBody: function _dialogBody() {
	    return React.createElement(CreateRoomForm, { loading: this.props.btnLoading });
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    var cx = React.addons.classSet,
	        btnClasses = cx({
	      "aui-button": true,
	      "aui-button-primary": true
	    });

	    return React.createElement(
	      "button",
	      { form: "create-room-form", className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading, type: "submit" },
	      strings.create_room
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "create-room-dialog",
	      title: strings.create_a_new_room,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.props.btnLoading,
	      closeLinkText: "Cancel" });
	  }
	});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    strings = __webpack_require__(232),
	    RoomPrivacyForm = __webpack_require__(238);

	module.exports = React.createClass({

	  displayName: "RoomPrivacyDialog",

	  _dialogBody: function _dialogBody() {
	    return React.createElement(RoomPrivacyForm, { jid: this.props.jid, name: this.props.name, privacy: this.props.privacy, loading: this.props.btnLoading });
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    var cx = React.addons.classSet,
	        btnClasses = cx({
	      "aui-button": true,
	      "aui-button-primary": true
	    });

	    return React.createElement(
	      "button",
	      { form: "room-privacy-form", className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading, type: "submit" },
	      strings.set_privacy
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "room-privacy-dialog",
	      title: strings.change_privacy,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.props.btnLoading,
	      closeLinkText: strings.cancel });
	  }
	});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    RenameRoomForm = __webpack_require__(234),
	    strings = __webpack_require__(232),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "RenameRoomDialog",

	  _dialogBody: function _dialogBody() {
	    return React.createElement(RenameRoomForm, { jid: this.props.jid, name: this.props.name, loading: this.props.btnLoading });
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    var cx = React.addons.classSet,
	        btnClasses = cx({
	      "aui-button": true,
	      "aui-button-primary": true
	    });

	    return React.createElement(
	      "button",
	      { form: "rename-room-form", className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading, type: "submit" },
	      strings.rename
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "rename-room-dialog",
	      title: strings.rename_room(this.props.name),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      btnLoading: this.props.btnLoading,
	      closeLinkText: strings.cancel });
	  }
	});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    DialogActions = __webpack_require__(28),
	    FlagActions = __webpack_require__(49),
	    strings = __webpack_require__(232),
	    RoomDropDownActions = __webpack_require__(54),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "DeleteRoomDialog",

	  componentDidMount: function componentDidMount() {
	    this._focusButton();
	  },

	  _dialogBody: function _dialogBody() {
	    return strings.confirm_delete(this.props.name);
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    var cx = React.addons.classSet,
	        btnClasses = cx({
	      "aui-button": true,
	      "aui-button-primary": true
	    });

	    return React.createElement(
	      "button",
	      { onClick: this._deleteRoom, className: btnClasses, "aria-disabled": this.props.btnLoading, disabled: this.props.btnLoading },
	      strings.delete_room
	    );
	  },

	  _deleteRoom: function _deleteRoom(e) {
	    e.preventDefault();
	    DialogActions.startBtnLoading();
	    RoomDropDownActions.deleteRoom({
	      jid: this.props.jid
	    }, this._handleResponse);
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = Utils.dot(data, "error.text.__text") ? data.error.text.__text : strings.delete_room_fail;
	      this._throwFlagError(error_msg);
	    } else {
	      var success_msg = strings.room_deleted(this.props.name);
	      this._throwFlagSuccess(success_msg);
	    }
	    this._closeDialog();
	  },

	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    FlagActions.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },

	  _flagBody: function _flagBody(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._flagActionClick, href: "#" },
	            strings.try_again
	          )
	        )
	      )
	    );
	  },

	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data("flag-index");
	    FlagActions.removeFlag(flag_index);
	    this._showDialog();
	  },

	  _showDialog: function _showDialog() {
	    DialogActions.showDeleteRoomDialog({
	      jid: this.props.jid,
	      name: this.props.name
	    });
	  },

	  _closeDialog: function _closeDialog() {
	    DialogActions.closeDialog();
	  },

	  _focusButton: function _focusButton() {
	    this.getDOMNode().querySelector(".aui-button-primary").focus();
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "delete-room-dialog",
	      title: strings.delete_room,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: strings.cancel,
	      btnLoading: this.props.btnLoading,
	      size: "small" });
	  }
	});

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    AppDispatcher = __webpack_require__(1),
	    strings = __webpack_require__(232),
	    DialogActions = __webpack_require__(28);

	module.exports = React.createClass({

	  displayName: "RoomInviteDialog",

	  _dialogBody: function _dialogBody() {
	    var invitePrompt = strings.invited_to_join(this.props.from_user, this.props.room_name);
	    return React.createElement(
	      "div",
	      null,
	      invitePrompt,
	      React.createElement("br", null),
	      React.createElement("br", null),
	      this.props.reason ? "\"" + this.props.reason + "\"" : ""
	    );
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { onClick: this._acceptInvite, className: "aui-button aui-button-primary" },
	      strings.join
	    );
	  },

	  _acceptInvite: function _acceptInvite(e) {
	    e.preventDefault();
	    AppDispatcher.dispatch("groupchat-invite-accepted", {
	      jid: this.props.room_jid
	    });
	    DialogActions.closeDialog();
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "room-invite-dialog",
	      title: strings.join_room(this.props.room_name),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Ignore",
	      size: "small" });
	  }
	});

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    RoomsNavStore = __webpack_require__(122),
	    AppDispatcher = __webpack_require__(1),
	    DialogActions = __webpack_require__(28),
	    FlagActions = __webpack_require__(49),
	    strings = __webpack_require__(232),
	    RoomDropDownActions = __webpack_require__(54),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "ArchiveRoomDialog",

	  componentDidMount: function componentDidMount() {
	    RoomsNavStore.on(["change"], this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    RoomsNavStore.off(["change"], this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },

	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: RoomsNavStore.get("active_chat"),
	      rooms: RoomsNavStore.get("rooms")
	    };
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getActiveChatState());
	  },

	  _dialogBody: function _dialogBody() {
	    return this.props.archive ? React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        null,
	        React.createElement(
	          "strong",
	          null,
	          strings.really_archive(this._getRoomName())
	        )
	      ),
	      React.createElement(
	        "p",
	        null,
	        strings.confirm_archive
	      )
	    ) : React.createElement(
	      "p",
	      null,
	      strings.really_unarchive(this._getRoomName())
	    );
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { onClick: this.props.archive ? this._archiveRoom : this._unarchiveRoom, className: "aui-button aui-button-primary" },
	      this.props.archive ? strings.archive : strings.unarchive
	    );
	  },

	  _getRoomName: function _getRoomName() {
	    return Utils.room.get_room_name(_.indexBy(this.state.rooms.rooms, "jid"), this.state.active_chat);
	  },

	  _archiveRoom: function _archiveRoom(e) {
	    e.preventDefault();
	    RoomDropDownActions.archiveRoom({
	      jid: this.state.active_chat
	    }, this._handleResponse);
	    DialogActions.closeDialog();
	  },

	  _unarchiveRoom: function _unarchiveRoom(e) {
	    e.preventDefault();
	    RoomDropDownActions.unarchiveRoom({
	      jid: this.state.active_chat
	    }, this._handleResponse);
	    DialogActions.closeDialog();
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = this.props.archive ? strings.archive_fail : strings.unarchive_fail;
	      this._throwFlagError(error_msg);
	    } else {
	      var success_msg = this.props.archive ? strings.room_archived : strings.room_unarchived;
	      this._throwFlagSuccess(success_msg);
	    }
	  },

	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    FlagActions.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },

	  _flagBody: function _flagBody(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this.props.archive ? this._archiveRoom : this._unarchiveRoom, href: "#" },
	            strings.try_again
	          )
	        )
	      )
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "archive-room-dialog",
	      title: this.props.archive ? strings.archive_room_name(this._getRoomName()) : strings.unarchive_room_name(this._getRoomName()),
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel" });
	  }
	});

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227),
	    RoomsNavStore = __webpack_require__(122),
	    AppDispatcher = __webpack_require__(1),
	    DialogActions = __webpack_require__(28),
	    FlagActions = __webpack_require__(49),
	    strings = __webpack_require__(232),
	    RoomDropDownActions = __webpack_require__(54),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "GuestAccessDialog",

	  getInitialState: function getInitialState() {
	    return this._getActiveChatState();
	  },

	  _getActiveChatState: function _getActiveChatState() {
	    return {
	      active_chat: RoomsNavStore.get("active_chat"),
	      rooms: RoomsNavStore.get("rooms")
	    };
	  },

	  _dialogBody: function _dialogBody() {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        null,
	        React.createElement(
	          "strong",
	          null,
	          strings.really_disable_guest
	        )
	      ),
	      React.createElement(
	        "p",
	        null,
	        strings.confirm_disable_guest
	      )
	    );
	  },

	  _dialogFooterButton: function _dialogFooterButton() {
	    return React.createElement(
	      "button",
	      { onClick: this._disableGuestAccess, className: "aui-button aui-button-primary" },
	      strings.ok
	    );
	  },

	  _disableGuestAccess: function _disableGuestAccess(e) {
	    e.preventDefault();
	    RoomDropDownActions.disableGuestAccess({
	      jid: this.state.active_chat
	    }, this._handleResponse);
	    DialogActions.closeDialog();
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = strings.disable_guest_fail;
	      this._throwFlagError(error_msg);
	    }
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },

	  _flagBody: function _flagBody(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._disableGuestAccess, href: "#" },
	            strings.try_again
	          )
	        )
	      )
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "disable-guest-dialog",
	      title: strings.disable_guest,
	      dialogBody: this._dialogBody,
	      dialogFooterButton: this._dialogFooterButton,
	      closeLinkText: "Cancel" });
	  }
	});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ModalDialog = __webpack_require__(227);
	var KeyboardShortcutStrings = __webpack_require__(29);

	module.exports = React.createClass({

	  displayName: "KeyboardShortcutsDialog",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      shortcuts: {}
	    };
	  },

	  _getKeyItem: function _getKeyItem(shortcut) {
	    var keyAction = this._getKeyLayout(shortcut.keys);
	    return React.createElement(
	      "li",
	      { className: "hc-list-item" },
	      React.createElement(
	        "span",
	        { className: "hc-list-item-desc" },
	        shortcut.title
	      ),
	      keyAction
	    );
	  },

	  _getKeyLayout: function _getKeyLayout(keys) {
	    return React.createElement(
	      "span",
	      { className: "hc-list-item-action" },
	      _.map(keys, function (item, index) {
	        return this._getKey(item, index);
	      }, this)
	    );
	  },

	  _getKey: function _getKey(key, index) {
	    var keyClass = "hc-key-" + key.type,
	        name = key.name;
	    if (index !== 0) {
	      return React.createElement(
	        "span",
	        null,
	        React.createElement(
	          "span",
	          { className: "hc-key-separator" },
	          KeyboardShortcutStrings.separator
	        ),
	        React.createElement(
	          "kbd",
	          { className: keyClass },
	          name
	        )
	      );
	    } else {
	      return React.createElement(
	        "kbd",
	        { className: keyClass },
	        name
	      );
	    }
	  },

	  _dialogBody: function _dialogBody() {
	    return React.createElement(
	      "ul",
	      { className: "hc-list" },
	      _.map(this.props.shortcuts, function (shortcut) {
	        return this._getKeyItem(shortcut);
	      }, this)
	    );
	  },

	  render: function render() {
	    return React.createElement(ModalDialog, { dialogId: "keyboard-shortcuts-dialog", title: "Keyboard Shortcuts", dialogBody: this._dialogBody, size: "small" });
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);
	var dispatcher = __webpack_require__(1);

	var FlagsStore = (function (Store) {
	  function FlagsStore() {
	    _classCallCheck(this, FlagsStore);

	    this.data = {
	      flags: []
	    };

	    this.flag_defaults = {
	      type: "info",
	      body: null,
	      close: "manual",
	      title: ""
	    };

	    this.register_listeners();
	  }

	  _inherits(FlagsStore, Store);

	  _prototypeProperties(FlagsStore, null, {
	    register_listeners: {
	      value: function register_listeners() {
	        var _this = this;

	        dispatcher.register({
	          "show-flag": function (flag_data) {
	            _this.add_flag(flag_data);
	          },
	          "remove-flag": function (flag_index) {
	            _this.remove_flag(flag_index);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    add_flag: {
	      value: function add_flag(flag_data) {
	        this.data.flags.unshift(_.defaults(flag_data, this.flag_defaults));
	        this.set("flags", this.data.flags);
	      },
	      writable: true,
	      configurable: true
	    },
	    remove_flag: {
	      value: function remove_flag(flag_index) {
	        this.data.flags.splice(flag_index, 1);
	        this.set("flags", this.data.flags);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return FlagsStore;
	})(Store);

	module.exports = new FlagsStore();

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var FlagActions = __webpack_require__(49),
	    invariant = __webpack_require__(239);

	module.exports = React.createClass({

	  displayName: "Flag",

	  componentWillMount: function componentWillMount() {
	    invariant(_.contains(["info", "success", "warning", "error"], this.props.type), "Type prop must be info, success, warning or error");
	    invariant(_.contains(["manual", "auto", "never"], this.props.close), "Close prop must be manual, auto or never");
	  },

	  _isCloseable: function _isCloseable() {
	    return this.props.close !== "never";
	  },

	  _getCloseButton: function _getCloseButton() {
	    return this._isCloseable() ? React.createElement("span", { onClick: this.close, className: "aui-icon hipchat-icon-small icon-close", role: "button", tabIndex: "0" }) : undefined;
	  },

	  close: function close() {
	    var flag_index = this.props.flag_index;
	    $(this.getDOMNode()).attr("aria-hidden", true);
	    _.delay(function () {
	      // Wait for animation to complete before removing flag
	      FlagActions.removeFlag(flag_index);
	    }, 1000);
	  },

	  render: function render() {
	    var closeable = this._isCloseable() ? "closeable" : "";
	    var classes = "hc-message hc-message-" + this.props.type + " " + this.props.type + " " + closeable;
	    var closeBtn = this._getCloseButton();
	    if (this.props.close === "auto") {
	      _.delay(this.close, 2000);
	    }

	    return React.createElement(
	      "div",
	      { className: "hc-flag", "data-flag-index": this.props.flag_index, "aria-hidden": "false" },
	      React.createElement(
	        "div",
	        { className: classes },
	        React.createElement(
	          "p",
	          { className: "title" },
	          React.createElement(
	            "strong",
	            null,
	            this.props.title
	          )
	        ),
	        this.props.body,
	        closeBtn
	      )
	    );
	  }
	});

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 142,
		"./af.js": 142,
		"./ar": 146,
		"./ar-ma": 143,
		"./ar-ma.js": 143,
		"./ar-sa": 144,
		"./ar-sa.js": 144,
		"./ar-tn": 145,
		"./ar-tn.js": 145,
		"./ar.js": 146,
		"./az": 147,
		"./az.js": 147,
		"./be": 148,
		"./be.js": 148,
		"./bg": 149,
		"./bg.js": 149,
		"./bn": 150,
		"./bn.js": 150,
		"./bo": 151,
		"./bo.js": 151,
		"./br": 152,
		"./br.js": 152,
		"./bs": 153,
		"./bs.js": 153,
		"./ca": 154,
		"./ca.js": 154,
		"./cs": 155,
		"./cs.js": 155,
		"./cv": 156,
		"./cv.js": 156,
		"./cy": 157,
		"./cy.js": 157,
		"./da": 158,
		"./da.js": 158,
		"./de": 160,
		"./de-at": 159,
		"./de-at.js": 159,
		"./de.js": 160,
		"./el": 161,
		"./el.js": 161,
		"./en-au": 162,
		"./en-au.js": 162,
		"./en-ca": 163,
		"./en-ca.js": 163,
		"./en-gb": 164,
		"./en-gb.js": 164,
		"./eo": 165,
		"./eo.js": 165,
		"./es": 166,
		"./es.js": 166,
		"./et": 167,
		"./et.js": 167,
		"./eu": 168,
		"./eu.js": 168,
		"./fa": 169,
		"./fa.js": 169,
		"./fi": 170,
		"./fi.js": 170,
		"./fo": 171,
		"./fo.js": 171,
		"./fr": 173,
		"./fr-ca": 172,
		"./fr-ca.js": 172,
		"./fr.js": 173,
		"./fy": 174,
		"./fy.js": 174,
		"./gl": 175,
		"./gl.js": 175,
		"./he": 176,
		"./he.js": 176,
		"./hi": 177,
		"./hi.js": 177,
		"./hr": 178,
		"./hr.js": 178,
		"./hu": 179,
		"./hu.js": 179,
		"./hy-am": 180,
		"./hy-am.js": 180,
		"./id": 181,
		"./id.js": 181,
		"./is": 182,
		"./is.js": 182,
		"./it": 183,
		"./it.js": 183,
		"./ja": 184,
		"./ja.js": 184,
		"./ka": 185,
		"./ka.js": 185,
		"./km": 186,
		"./km.js": 186,
		"./ko": 187,
		"./ko.js": 187,
		"./lb": 188,
		"./lb.js": 188,
		"./lt": 189,
		"./lt.js": 189,
		"./lv": 190,
		"./lv.js": 190,
		"./mk": 191,
		"./mk.js": 191,
		"./ml": 192,
		"./ml.js": 192,
		"./mr": 193,
		"./mr.js": 193,
		"./ms-my": 194,
		"./ms-my.js": 194,
		"./my": 195,
		"./my.js": 195,
		"./nb": 196,
		"./nb.js": 196,
		"./ne": 197,
		"./ne.js": 197,
		"./nl": 198,
		"./nl.js": 198,
		"./nn": 199,
		"./nn.js": 199,
		"./pl": 200,
		"./pl.js": 200,
		"./pt": 202,
		"./pt-br": 201,
		"./pt-br.js": 201,
		"./pt.js": 202,
		"./ro": 203,
		"./ro.js": 203,
		"./ru": 204,
		"./ru.js": 204,
		"./sk": 205,
		"./sk.js": 205,
		"./sl": 206,
		"./sl.js": 206,
		"./sq": 207,
		"./sq.js": 207,
		"./sr": 209,
		"./sr-cyrl": 208,
		"./sr-cyrl.js": 208,
		"./sr.js": 209,
		"./sv": 210,
		"./sv.js": 210,
		"./ta": 211,
		"./ta.js": 211,
		"./th": 212,
		"./th.js": 212,
		"./tl-ph": 213,
		"./tl-ph.js": 213,
		"./tr": 214,
		"./tr.js": 214,
		"./tzm": 216,
		"./tzm-latn": 215,
		"./tzm-latn.js": 215,
		"./tzm.js": 216,
		"./uk": 217,
		"./uk.js": 217,
		"./uz": 218,
		"./uz.js": 218,
		"./vi": 219,
		"./vi.js": 219,
		"./zh-cn": 220,
		"./zh-cn.js": 220,
		"./zh-tw": 221,
		"./zh-tw.js": 221
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 111;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var FaviconCounter = (function () {
	  function FaviconCounter(opt) {
	    var _this = this;

	    _classCallCheck(this, FaviconCounter);

	    this.def = {
	      bgColor: "#d00",
	      textColor: "#fff",
	      fontFamily: "sans-serif", //Arial,Verdana,Times New Roman,serif,sans-serif,...
	      fontStyle: "lighter", //normal,italic,oblique,bold,bolder,lighter,100,200,300,400,500,600,700,800,900
	      elementId: false
	    };

	    this.browser = {};
	    this.browser.ff = typeof InstallTrigger != "undefined";
	    this.browser.opera = !!window.opera || navigator.userAgent.indexOf("Opera") >= 0;

	    this.readyCb = function () {};
	    this.ready = false;

	    this.opt = _.merge(this.def, opt);
	    this.opt.bgColor = this.opt.bgColor;
	    this.opt.textColor = this.hexToRgb(this.opt.textColor);

	    try {
	      this.orig = this.getIcon();
	      this.canvas = document.createElement("canvas");
	      this.img = document.createElement("img");
	      if (this.orig.hasAttribute("href")) {
	        this.img.onload = function () {
	          _this.h = _this.img.height > 0 ? _this.img.height : 32;
	          _this.w = _this.img.width > 0 ? _this.img.width : 32;
	          _this.canvas.height = _this.h;
	          _this.canvas.width = _this.w;
	          _this.context = _this.canvas.getContext("2d");
	          _this.setReady();
	        };
	        this.img.setAttribute("src", this.orig.getAttribute("href"));
	      } else {
	        this.img.setAttribute("src", "");
	        this.h = 32;
	        this.w = 32;
	        this.img.height = this.h;
	        this.img.width = this.w;
	        this.canvas.height = this.h;
	        this.canvas.width = this.w;
	        this.context = this.canvas.getContext("2d");
	        this.setReady();
	      }
	    } catch (e) {
	      throw "Error initializing favico. Message: " + e.message;
	    }
	  }

	  _prototypeProperties(FaviconCounter, null, {
	    setReady: {
	      value: function setReady() {
	        this.ready = true;
	        this.reset();
	        this.readyCb();
	      },
	      writable: true,
	      configurable: true
	    },
	    reset: {
	      value: function reset() {
	        if (!this.ready) {
	          return;
	        }
	        this.context.clearRect(0, 0, this.w, this.h);
	        this.context.drawImage(this.img, 0, 0, this.w, this.h);
	        this.setIcon(this.canvas);
	      },
	      writable: true,
	      configurable: true
	    },
	    draw: {
	      value: function draw(opt) {
	        var _this = this;

	        this.ready = false;
	        var img = new Image();
	        img.onload = function () {
	          opt.n = typeof opt.n === "number" ? Math.abs(opt.n | 0) : opt.n;
	          opt.w = _this.w;
	          opt.h = _this.h;
	          opt.len = ("" + opt.n).length;
	          _this.context.clearRect(0, 0, _this.w, _this.h);
	          _this.context.drawImage(img, 0, 0);
	          _this.context.beginPath();
	          _this.context.font = _this.opt.fontStyle + " " + Math.floor(opt.n > 99 ? opt.h * 1.2 : opt.h * 0.55) + "px " + _this.opt.fontFamily;
	          _this.context.textAlign = "center";
	          _this.context.fillStyle = "rgb(" + _this.opt.textColor.r + "," + _this.opt.textColor.g + "," + _this.opt.textColor.b + ")";
	          if (typeof opt.n === "number" && opt.n > 99) {
	            _this.context.font = "bold " + Math.floor(opt.h * 0.5) + "px " + _this.opt.fontFamily;
	            _this.context.fillText("•••", Math.floor(opt.w / 2), Math.floor(opt.h * 0.67));
	          } else {
	            _this.context.fillText(opt.n, Math.floor(opt.w / 2), Math.floor(opt.h - opt.h * 0.34));
	          }
	          _this.context.closePath();
	          _this.setIcon(_this.canvas);
	        };
	        var svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + this.w + "\" height=\"" + this.h + "\"><g><path fill=\"" + opt.bgColor + "\" d=\"M29.1,28.9c-1.1-0.6-2.2-1.7-2.6-3.2c-0.1-0.3,0-0.5,0.2-0.7c3.2-2.5,5.2-6.1,5.2-10.2c0-7.5-7-13.6-15.8-13.6c-8.7,0-15.7,6.1-15.7,13.6c0,7.5,7,13.6,15.7,13.6c1.1,0,2.2-0.1,3.3-0.3c0.3-0.1,0.5,0,0.7,0.1c2.2,1.3,5.4,2.4,8.2,2.4c0.9,0,1.3-0.6,1.3-1.1C28.6,29.3-209.8,29.1,28.9z\"/></g></svg>";
	        img.src = "data:image/svg+xml," + encodeURIComponent(svg);
	      },
	      writable: true,
	      configurable: true
	    },
	    badge: {
	      value: function badge(number, opts) {
	        var _this = this;

	        try {
	          if (typeof number === "number" ? number > 0 : number !== "") {
	            var q = {
	              type: "badge",
	              options: {
	                n: number,
	                bgColor: opts.bgColor || this.opt.bgColor
	              }
	            };
	            ["textColor"].forEach(function (o) {
	              if (o in opts) {
	                q.options[o] = _this.hexToRgb(opts[o]);
	              }
	            });
	            ["fontStyle", "fontFamily"].forEach(function (o) {
	              if (o in opts) {
	                q.options[o] = opts[o];
	              }
	            });
	            this.draw(q.options);
	          } else {
	            this.reset();
	          }
	        } catch (e) {
	          throw "Error setting badge. Message: " + e.message;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getIcon: {
	      value: function getIcon() {
	        var elm = false;
	        var url = "";
	        var getLink = function getLink() {
	          var link = document.getElementsByTagName("head")[0].getElementsByTagName("link");
	          for (var l = link.length, i = l - 1; i >= 0; i--) {
	            if (/(^|\s)icon(\s|$)/i.test(link[i].getAttribute("rel"))) {
	              return link[i];
	            }
	          }
	          return false;
	        };
	        if (this.opt.elementId) {
	          elm = document.getElementById(this.opt.elementId);
	          elm.setAttribute("href", elm.getAttribute("src"));
	        } else {
	          elm = getLink();
	          if (elm === false) {
	            elm = document.createElement("link");
	            elm.setAttribute("rel", "icon");
	            document.getElementsByTagName("head")[0].appendChild(elm);
	          }
	        }
	        url = this.opt.elementId ? elm.src : elm.href;
	        if (url.substr(0, 5) !== "data:" && url.indexOf(document.location.hostname) === -1) {
	          throw new Error("Error setting favicon. Favicon image is on different domain (Icon: " + url + ", Domain: " + document.location.hostname + ")");
	        }
	        elm.setAttribute("type", "image/png");
	        return elm;
	      },
	      writable: true,
	      configurable: true
	    },
	    setIcon: {
	      value: function setIcon(canvas) {
	        var url = canvas.toDataURL("image/png");
	        if (this.opt.elementId) {
	          document.getElementById(this.opt.elementId).setAttribute("src", url);
	        } else {
	          if (this.browser.ff || this.browser.opera) {
	            var old = this.orig;
	            this.orig = document.createElement("link");
	            if (this.browser.opera) {
	              this.orig.setAttribute("rel", "icon");
	            }
	            this.orig.setAttribute("rel", "icon");
	            this.orig.setAttribute("type", "image/png");
	            document.getElementsByTagName("head")[0].appendChild(this.orig);
	            this.orig.setAttribute("href", url);
	            if (old.parentNode) {
	              old.parentNode.removeChild(old);
	            }
	          } else {
	            this.orig.setAttribute("href", url);
	          }
	        }
	        this.ready = true;
	      },
	      writable: true,
	      configurable: true
	    },
	    hexToRgb: {

	      //http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-5624139
	      //HEX to RGB convertor

	      value: function hexToRgb(hex) {
	        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
	          return r + r + g + g + b + b;
	        });
	        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	        return result ? {
	          r: parseInt(result[1], 16),
	          g: parseInt(result[2], 16),
	          b: parseInt(result[3], 16)
	        } : false;
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return FaviconCounter;
	})();

	module.exports = FaviconCounter;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var config = __webpack_require__(240).config;
	var configure = __webpack_require__(240).configure;
	var objectOrFunction = __webpack_require__(241).objectOrFunction;
	var isFunction = __webpack_require__(241).isFunction;
	var now = __webpack_require__(241).now;
	var all = __webpack_require__(242).all;
	var race = __webpack_require__(243).race;
	var staticResolve = __webpack_require__(244).resolve;
	var staticReject = __webpack_require__(245).reject;
	var asap = __webpack_require__(246).asap;

	var counter = 0;

	config.async = asap; // default async is asap;

	function Promise(resolver) {
	  if (!isFunction(resolver)) {
	    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	  }

	  if (!(this instanceof Promise)) {
	    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	  }

	  this._subscribers = [];

	  invokeResolver(resolver, this);
	}

	function invokeResolver(resolver, promise) {
	  function resolvePromise(value) {
	    resolve(promise, value);
	  }

	  function rejectPromise(reason) {
	    reject(promise, reason);
	  }

	  try {
	    resolver(resolvePromise, rejectPromise);
	  } catch(e) {
	    rejectPromise(e);
	  }
	}

	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value, error, succeeded, failed;

	  if (hasCallback) {
	    try {
	      value = callback(detail);
	      succeeded = true;
	    } catch(e) {
	      failed = true;
	      error = e;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }

	  if (handleThenable(promise, value)) {
	    return;
	  } else if (hasCallback && succeeded) {
	    resolve(promise, value);
	  } else if (failed) {
	    reject(promise, error);
	  } else if (settled === FULFILLED) {
	    resolve(promise, value);
	  } else if (settled === REJECTED) {
	    reject(promise, value);
	  }
	}

	var PENDING   = void 0;
	var SEALED    = 0;
	var FULFILLED = 1;
	var REJECTED  = 2;

	function subscribe(parent, child, onFulfillment, onRejection) {
	  var subscribers = parent._subscribers;
	  var length = subscribers.length;

	  subscribers[length] = child;
	  subscribers[length + FULFILLED] = onFulfillment;
	  subscribers[length + REJECTED]  = onRejection;
	}

	function publish(promise, settled) {
	  var child, callback, subscribers = promise._subscribers, detail = promise._detail;

	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];

	    invokeCallback(settled, child, callback, detail);
	  }

	  promise._subscribers = null;
	}

	Promise.prototype = {
	  constructor: Promise,

	  _state: undefined,
	  _detail: undefined,
	  _subscribers: undefined,

	  then: function(onFulfillment, onRejection) {
	    var promise = this;

	    var thenPromise = new this.constructor(function() {});

	    if (this._state) {
	      var callbacks = arguments;
	      config.async(function invokePromiseCallback() {
	        invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
	      });
	    } else {
	      subscribe(this, thenPromise, onFulfillment, onRejection);
	    }

	    return thenPromise;
	  },

	  'catch': function(onRejection) {
	    return this.then(null, onRejection);
	  }
	};

	Promise.all = all;
	Promise.race = race;
	Promise.resolve = staticResolve;
	Promise.reject = staticReject;

	function handleThenable(promise, value) {
	  var then = null,
	  resolved;

	  try {
	    if (promise === value) {
	      throw new TypeError("A promises callback cannot return that same promise.");
	    }

	    if (objectOrFunction(value)) {
	      then = value.then;

	      if (isFunction(then)) {
	        then.call(value, function(val) {
	          if (resolved) { return true; }
	          resolved = true;

	          if (value !== val) {
	            resolve(promise, val);
	          } else {
	            fulfill(promise, val);
	          }
	        }, function(val) {
	          if (resolved) { return true; }
	          resolved = true;

	          reject(promise, val);
	        });

	        return true;
	      }
	    }
	  } catch (error) {
	    if (resolved) { return true; }
	    reject(promise, error);
	    return true;
	  }

	  return false;
	}

	function resolve(promise, value) {
	  if (promise === value) {
	    fulfill(promise, value);
	  } else if (!handleThenable(promise, value)) {
	    fulfill(promise, value);
	  }
	}

	function fulfill(promise, value) {
	  if (promise._state !== PENDING) { return; }
	  promise._state = SEALED;
	  promise._detail = value;

	  config.async(publishFulfillment, promise);
	}

	function reject(promise, reason) {
	  if (promise._state !== PENDING) { return; }
	  promise._state = SEALED;
	  promise._detail = reason;

	  config.async(publishRejection, promise);
	}

	function publishFulfillment(promise) {
	  publish(promise, promise._state = FULFILLED);
	}

	function publishRejection(promise) {
	  publish(promise, promise._state = REJECTED);
	}

	exports.Promise = Promise;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/*global self*/
	var RSVPPromise = __webpack_require__(113).Promise;
	var isFunction = __webpack_require__(241).isFunction;

	function polyfill() {
	  var local;

	  if (typeof global !== 'undefined') {
	    local = global;
	  } else if (typeof window !== 'undefined' && window.document) {
	    local = window;
	  } else {
	    local = self;
	  }

	  var es6PromiseSupport =
	    "Promise" in local &&
	    // Some of these methods are missing from
	    // Firefox/Chrome experimental implementations
	    "resolve" in local.Promise &&
	    "reject" in local.Promise &&
	    "all" in local.Promise &&
	    "race" in local.Promise &&
	    // Older version of the spec had a resolver object
	    // as the arg rather than a function
	    (function() {
	      var resolve;
	      new local.Promise(function(r) { resolve = r; });
	      return isFunction(resolve);
	    }());

	  if (!es6PromiseSupport) {
	    local.Promise = RSVPPromise;
	  }
	}

	exports.polyfill = polyfill;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "UserStatusAvatar",

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "aui-avatar-inner hc-user-photo" },
	      this.props.user.photo_small ? React.createElement("img", { src: this.props.user.photo_small }) : React.createElement("span", { className: "aui-icon hc-user-silhouette" })
	    );
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PresenceIcon = __webpack_require__(118);

	module.exports = React.createClass({

	  displayName: "UserStatusAvatar",

	  componentDidMount: function componentDidMount() {
	    var _this = this;

	    // Can't use standard React events here since AUI has mutated the drop-down.
	    // React can't operate on DOM that's mutated since it's been created. In most
	    // other cases, we should stick with React events.
	    var statusActions = document.querySelectorAll("#current-user-status .hc-availability a"),
	        signoutLink = document.querySelectorAll(".signout a");

	    for (var i = 0; i < statusActions.length; i++) {
	      statusActions[i].addEventListener("click", (function (e) {
	        this.props.onPresenceUpdate.bind(null, e.currentTarget)();
	      }).bind(this));
	    }
	    signoutLink[0].addEventListener("click", (function (e) {
	      this.props.onSignout.bind(null, e.currentTarget)();
	    }).bind(this));
	    var dialogLink = document.querySelectorAll(".settings > a");
	    dialogLink[0].addEventListener("click", function (e) {
	      _this.props.onSettings.bind(null, e.currentTarget)();
	    });
	  },
	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "aui-dropdown2 aui-style-default aui-dropdown2-in-header", id: "current-user-status", "aria-hidden": "true", "data-dropdown2-alignment": "right" },
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            null,
	            React.createElement(
	              "a",
	              { className: "hc-user-name", href: "/account", target: "_blank" },
	              this.props.user.user_name
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section hc-availability" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "chat aui-inline-dialog-trigger" },
	            React.createElement(
	              "a",
	              { "data-show": "chat" },
	              React.createElement(PresenceIcon, { presence: "chat" }),
	              " Available"
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "xa aui-inline-dialog-trigger" },
	            React.createElement(
	              "a",
	              { "data-show": "xa" },
	              React.createElement(PresenceIcon, { presence: "xa" }),
	              " Away"
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "dnd aui-inline-dialog-trigger" },
	            React.createElement(
	              "a",
	              { "data-show": "dnd" },
	              React.createElement(PresenceIcon, { presence: "dnd" }),
	              " Do not disturb"
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section hc-actions" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "settings" },
	            React.createElement(
	              "a",
	              null,
	              React.createElement("span", { className: "aui-icon aui-icon-small aui-iconfont-configure" }),
	              " Settings"
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "signout" },
	            React.createElement(
	              "a",
	              null,
	              React.createElement("span", { className: "aui-icon aui-icon-small aui-iconfont-devtools-checkout" }),
	              " Sign out"
	            )
	          )
	        )
	      )
	    );
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppHeaderActions = __webpack_require__(48);
	var AppDispatcher = __webpack_require__(1);

	module.exports = React.createClass({

	  displayName: "SearchInput",

	  componentDidMount: function componentDidMount() {
	    this._shouldFocus();
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this._shouldFocus();
	  },

	  _shouldFocus: function _shouldFocus() {
	    if (this.props.focus_search) {
	      this._focusAndSelect();
	    }
	  },

	  _focusAndSelect: function _focusAndSelect() {
	    var input = this.refs.searchInput.getDOMNode();
	    if (input !== document.activeElement) {
	      input.focus();
	      input.select();
	    }
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "aui-quicksearch" },
	      React.createElement("input", { id: "search-query", type: "text", placeholder: "Search history", name: "name", autoComplete: "off", title: "search for something", ref: "searchInput",
	        onKeyDown: this._onKeyDown,
	        onChange: this._onChange,
	        onBlur: this._onBlur,
	        value: this.props.text })
	    );
	  },

	  _onKeyDown: function _onKeyDown(evt) {
	    if (evt.keyCode === 13) {
	      AppHeaderActions.searchHistory(this.props.jid);
	    }
	  },

	  _onChange: function _onChange(evt) {
	    AppHeaderActions.setSearchText({
	      text: evt.target.value
	    });
	  },

	  _onBlur: function _onBlur() {
	    AppHeaderActions.searchBlurred();
	  }
	});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Icon = __webpack_require__(247),
	    PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "PresenceIcon",

	  mixins: [PureRenderMixin],

	  getDefaultProps: function getDefaultProps() {
	    return {
	      classNames: {
	        "hc-status-icon": true
	      },

	      presence: "chat",
	      mobile: false,
	      active: false
	    };
	  },

	  _getPresenceIconName: function _getPresenceIconName(statusName) {
	    var iconName = statusName;

	    if (statusName === "chat") {
	      iconName = "available";
	    } else if (statusName === "unknown") {
	      iconName = "unavailable";
	    }

	    if (this.props.active) {
	      iconName += "-selected";
	    }

	    return iconName;
	  },

	  _getStatusName: function _getStatusName() {
	    var statusName = "unknown";

	    if (this.props.presence === "unknown" && this.props.mobile) {
	      statusName = "mobile";
	    } else if (this.props.presence) {
	      statusName = this.props.presence;
	    }

	    return statusName;
	  },

	  render: function render() {
	    var statusName = this._getStatusName();
	    var iconName = this._getPresenceIconName(statusName);
	    var className = "icon-" + statusName;
	    var c = {};
	    c[className] = true;
	    var classes = _.assign({}, this.props.classNames, c);

	    return React.createElement(Icon, { classes: classes, iconName: iconName });
	  }
	});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var InlineDialogActions = __webpack_require__(51);
	var AceStpStore = __webpack_require__(224);

	module.exports = React.createClass({

	  displayName: "AceStpButton",

	  componentDidMount: function componentDidMount() {
	    AceStpStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    AceStpStore.off("change", this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return AceStpStore.getAll();
	  },

	  _onChange: function _onChange() {
	    this.setState(AceStpStore.getAll());
	  },

	  _onAceStpClick: function _onAceStpClick(evt) {
	    InlineDialogActions.toggleInlineDialog("ace-stp-inline-dialog", { button: evt.target });
	  },

	  render: function render() {
	    return React.createElement(
	      "a",
	      { id: "ace-stp-menu-link", className: "aui-nav-link aui-inline-dialog-trigger", onClick: this._onAceStpClick },
	      React.createElement("span", { id: "ace-stp-menu-icon", className: "aui-icon aui-icon-small aui-iconfont-help" }),
	      this.state.button_status === "message" ? React.createElement("span", { className: "ace-stp-message-notification" }) : false
	    );
	  }
	});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	// Depends on Lodash

	var cookies = __webpack_require__(248);

	var Storage = (function () {
	  function Storage() {
	    _classCallCheck(this, Storage);

	    this.prefix = "hc-";
	    this.locations = ["local", "session", "global"];
	    try {
	      return "localStorage" in window && window.localStorage !== null;
	    } catch (e) {
	      window.localStorage = window.sessionStorage = cookies;
	    }
	  }

	  _prototypeProperties(Storage, null, {
	    has: {
	      value: function has(key) {
	        var _this = this;

	        return _.first(this.locations, function (location) {
	          return _.keys(window[location + "Storage"]).indexOf(_this.prefix + key) != -1;
	        })[0];
	      },
	      writable: true,
	      configurable: true
	    },
	    get: {
	      value: function get(key) {
	        var location = this.has(key);
	        if (location) {
	          try {
	            return JSON.parse(window[location + "Storage"].getItem(this.prefix + key).toString());
	          } catch (e) {
	            return false;
	          }
	        }
	        return false;
	      },
	      writable: true,
	      configurable: true
	    },
	    set: {
	      value: function set(key, val, location) {
	        return window[(location || "local") + "Storage"].setItem(this.prefix + key, JSON.stringify(val, function (key, value) {
	          if (value instanceof RegExp) {
	            return value.toString();
	          }
	          return value;
	        }));
	      },
	      writable: true,
	      configurable: true
	    },
	    unset: {
	      value: function unset(key) {
	        var location = this.has(key);
	        if (location) {
	          window[location + "Storage"].removeItem(this.prefix + key);
	          return true;
	        }
	        return false;
	      },
	      writable: true,
	      configurable: true
	    },
	    clear: {
	      value: function clear() {
	        var _this = this;

	        _.each(this.locations, function (location) {
	          _.filter(_.keys(window[location + "Storage"]), function (key) {
	            return key.match(_this.prefix);
	          }).forEach(function (key) {
	            window[location + "Storage"].removeItem(key);
	          });
	        });
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return Storage;
	})();

	module.exports = new Storage();

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  banner_message: "Don't miss out on all those important messages.",
	  enable_link: "Enable desktop notifications",
	  dismiss_link: "Not right now",
	  dismiss_forever_link: "Don't ask me again",
	  recommended: "(Recommended)",
	  seriously_recommended: "(We seriously recommend this)"
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var AppDispatcher = __webpack_require__(1),
	    Store = __webpack_require__(43),
	    Utils = __webpack_require__(4),
	    PreferencesStore = __webpack_require__(21),
	    notifier = __webpack_require__(66),
	    AnalyticsDispatcher = __webpack_require__(7);

	var RoomsNavStore = (function (Store) {
	  function RoomsNavStore() {
	    _classCallCheck(this, RoomsNavStore);

	    this.data = this.getDefaults();

	    this.registerListeners();
	    this.savePrefsDebounced = _.debounce(this.savePrefs, 2000, { leading: true, trailing: false });

	    this.windowFocused = true;
	  }

	  _inherits(RoomsNavStore, Store);

	  _prototypeProperties(RoomsNavStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          mentionRegex: null,
	          current_user: {},
	          active_chat: "lobby",
	          active_chat_type: "",
	          rooms: {
	            people: [],
	            rooms: []
	          },
	          room_order: []
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.registerOnce({
	          "hc-init": function (data) {
	            _this.handleRoomsInit(data);
	          }
	        });
	        AppDispatcher.register({
	          "initial-select-room": function () {
	            _this.hc_init_complete = true;
	          },
	          "before:select-room": function (data) {
	            _this.set("active_chat", data.jid);
	          },
	          "updated:current_user": function (user) {
	            _this.data.mentionRegex = new RegExp("@(" + user.mention + "\\b|all\\b|here\\b|\"" + user.user_name + "\")", "ig");
	            _this.set("current_user", user);
	          },
	          "updated:newMessages": function (messages) {
	            _this.handleMessageUpdate(messages);
	          },
	          "updated:roster": function (roster) {
	            _this.handleRosterUpdate(roster);
	          },
	          "updated:preferences": function (prefs) {
	            _this.handleSelectRoom(prefs.chatToFocus);
	          },
	          "updated:activeRooms": function (rooms) {
	            _this.handleRoomsUpdate(rooms);
	          },
	          "updated:active_chat": function (jid) {
	            _this.handleSelectRoom(jid);
	          },
	          "open-room": function (data) {
	            _this.handleOpenRoom(data);
	          },
	          "room-closed": function (data) {
	            _this.handleRoomClosed(data.jid);
	          },
	          "update-room-order": function (room_jids) {
	            _this.updateRoomOrder(room_jids);
	          },
	          "navigate-rooms": function (data) {
	            _this.navigateRooms(data.direction);
	          },
	          "application-focused": function () {
	            _this.windowFocused = true;
	            _this.clearUnreadCountForCurrentChat();
	          },
	          "application-blurred": function () {
	            _this.windowFocused = false;
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    groupRooms: {

	      /**
	       * Helper method for grouping tabs (rooms first then people)
	       * @param {object} tabs
	       */

	      value: function groupRooms(tabs) {
	        tabs = _.groupBy(_.reject(tabs, function (item) {
	          return !item || item.name === "";
	        }), function (chat) {
	          return chat.type == "groupchat" ? "rooms" : "people";
	        });
	        return tabs;
	      },
	      writable: true,
	      configurable: true
	    },
	    orderRooms: {

	      /**
	       * Helper method for ordering rooms
	       * @param {array} rooms
	       */

	      value: function orderRooms(rooms) {
	        if (this.data.room_order.length) {
	          var results = _.compact(_.map(this.data.room_order, function (jid) {
	            if (rooms[jid]) {
	              return rooms[jid];
	            }
	          }, this));
	          var newRooms = _.map(rooms, function (room) {
	            var newRoom = _.find(results, function (item) {
	              return room.jid === item.jid;
	            });
	            if (!newRoom) {
	              return room;
	            }
	          });
	          return _.compact(results.concat(newRooms));
	        } else {
	          return rooms;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    setRoomOrder: {

	      /**
	       * Helper method for setting room_order array based on autoJoin or RoomsNavStore rooms
	       * @param {array} autoJoin
	       */

	      value: function setRoomOrder(autoJoin) {
	        var jids;
	        if (autoJoin) {
	          jids = _.map(autoJoin, function (room) {
	            return room.jid;
	          }, this);
	        } else {
	          jids = _.flatten(_.map(["rooms", "people"], function (groupName) {
	            return _.map(this.data.rooms[groupName], function (room) {
	              return room.jid;
	            }, this);
	          }, this));
	        }
	        this.set({
	          room_order: jids
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomsInit: {
	      value: function handleRoomsInit() {
	        var autoJoinRooms = PreferencesStore.getAutoJoinRooms();
	        if (!_.isEmpty(autoJoinRooms)) {
	          this.setRoomOrder(autoJoinRooms);
	        }
	        var chatToFocus = PreferencesStore.getChatToFocus();
	        if (chatToFocus) {
	          this.set({
	            active_chat: chatToFocus
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleMessageUpdate: {

	      /**
	       * Handle message stanzas that arrive either in bulk or
	       * one at a time
	       * @param {object} messageData
	       */

	      value: function handleMessageUpdate(messageData) {
	        var _this = this;

	        var chat;

	        _.forEach(messageData, function (messages, jid) {
	          _.forEach(_this.data.rooms, function (group, type) {
	            chat = _.find(group, function (room) {
	              return room.jid == jid;
	            });
	            _.forEach(messages, function (msg) {
	              if (msg.delay || msg.room === _this.data.active_chat && _this.windowFocused || msg.sender === _this.data.current_user.user_name) return;
	              if (chat && !msg.is_history_message && msg.type != "user_state") {
	                ++chat.unreadCount;
	                if (_this.data.mentionRegex.test(msg.body) || type == "people") {
	                  chat.hasMention = true;
	                  return false;
	                }
	              }
	            });
	          });
	        });
	        this.set("rooms", this.data.rooms);
	        this.setRoomOrder();
	        this._updateTotalUnreadCount();
	      },
	      writable: true,
	      configurable: true
	    },
	    _updateTotalUnreadCount: {
	      value: function _updateTotalUnreadCount() {
	        var hasMention = false;
	        function unreadCB(r) {
	          if (!hasMention && r.hasMention) {
	            hasMention = true;
	          }
	          return r.unreadCount;
	        }

	        var unreadTotal = _.reduce(_.map(this.data.rooms.rooms, unreadCB).concat(_.map(this.data.rooms.people, unreadCB)), function (s, n) {
	          return s + n;
	        });

	        notifier.updateTotalUnreadCount(unreadTotal, hasMention);
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRosterUpdate: {
	      value: function handleRosterUpdate(roster) {
	        var _this = this;

	        var room;
	        _.map(roster, function (user, jid) {
	          room = _.find(_this.data.rooms.people, function (room) {
	            return room.jid == jid;
	          });
	          if (room) {
	            _.assign(room.presence, roster[jid].presence);
	            // Ensure OTO Chats have a name
	            if (!room.name) {
	              if (Utils.dot(user, "name")) {
	                room.name = user.name;
	              }
	            }
	          }
	        });

	        this.set({
	          rooms: this.data.rooms
	        });
	        this.setRoomOrder();
	      },
	      writable: true,
	      configurable: true
	    },
	    handleOpenRoom: {
	      value: function handleOpenRoom(data) {
	        if (_.find(this.data.rooms.rooms, { jid: data.jid }) || _.find(this.data.rooms.people, { jid: data.jid })) {
	          this.handleSelectRoom(data.jid);
	        } else {
	          AppDispatcher.dispatch("join-room", {
	            jid: data.jid,
	            name: data.name
	          });
	          this.handleSelectRoom(data.jid);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomsUpdate: {

	      /**
	       * Handle rooms update - accepts activeRooms obj with jids as keys
	       * @param {object} activeRooms
	       */

	      value: function handleRoomsUpdate(activeRooms) {
	        var rooms,
	            orderedRooms,
	            roomDefault = {
	          unreadCount: 0,
	          hasMention: false
	        };
	        _.map(activeRooms, function (room) {
	          _.defaults(room, roomDefault);
	        });
	        _.reject(activeRooms, function (room) {
	          return !room;
	        });
	        orderedRooms = this.orderRooms(activeRooms);
	        rooms = this.groupRooms(orderedRooms);
	        _.assign(this.data, {
	          rooms: _.defaults(rooms, { rooms: [], people: [] }),
	          active_chat: this.data.active_chat
	        });
	        if (!activeRooms[this.data.active_chat]) {
	          this.data.active_chat = "lobby";
	        }
	        this.saveRooms(orderedRooms, this.data.active_chat, this.data.rooms);
	        this._updateTotalUnreadCount();
	      },
	      writable: true,
	      configurable: true
	    },
	    getNextRoom: {
	      value: function getNextRoom(jid) {
	        var nextRoom, idx;
	        if (this.data.room_order.length) {
	          idx = this.data.room_order.indexOf(jid);
	          if (idx !== -1) {
	            if (idx == 0) {
	              idx++;
	            } else {
	              idx--;
	            }
	            nextRoom = this.data.room_order[idx];
	          }
	        }
	        return nextRoom || "lobby";
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomClosed: {
	      value: function handleRoomClosed(jid) {
	        if (jid === this.data.active_chat) {
	          var data = {
	            jid: this.getNextRoom(jid),
	            isClose: true
	          };
	          AppDispatcher.dispatch("select-room", data);
	          AnalyticsDispatcher.dispatch("analytics-select-room", data);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    handleSelectRoom: {
	      value: function handleSelectRoom(jid) {
	        var selectedJid = _.find(this.data.rooms.rooms, { jid: jid }) || _.find(this.data.rooms.people, { jid: jid }) ? jid : "lobby";
	        _.map(this.data.rooms, function (group) {
	          _.assign(_.find(group, function (room) {
	            return room.jid == jid;
	          }), {
	            unreadCount: 0,
	            hasMention: false
	          });
	        });
	        this.set({
	          rooms: this.data.rooms,
	          active_chat: selectedJid
	        });
	        this.setRoomOrder();
	        if (this.hc_init_complete) {
	          this.savePrefs({
	            chatToFocus: selectedJid
	          });
	        }
	        this._updateTotalUnreadCount();
	      },
	      writable: true,
	      configurable: true
	    },
	    clearUnreadCountForCurrentChat: {
	      value: function clearUnreadCountForCurrentChat() {
	        if (this.data.active_chat === "lobby") {
	          return;
	        }var jid = this.data.active_chat;
	        _.map(this.data.rooms, function (group) {
	          _.assign(_.find(group, function (room) {
	            return room.jid == jid;
	          }), {
	            unreadCount: 0,
	            hasMention: false
	          });
	        });
	        this.set({
	          rooms: this.data.rooms
	        });
	        this._updateTotalUnreadCount();
	      },
	      writable: true,
	      configurable: true
	    },
	    navigateRooms: {
	      value: function navigateRooms(direction) {
	        var newJid,
	            roomIndex = _.findIndex(this.data.room_order, function (jid) {
	          return jid === this.data.active_chat;
	        }, this);

	        if (direction === "up") {
	          if (roomIndex === 0) {
	            newJid = "lobby";
	          } else {
	            newJid = this.data.room_order[roomIndex - 1];
	          }
	        } else if (direction === "down") {
	          if (roomIndex === -1 && this.data.active_chat === "lobby") {
	            newJid = this.data.room_order[0];
	          } else {
	            newJid = this.data.room_order[roomIndex + 1];
	          }
	        }
	        if (newJid) {
	          AppDispatcher.dispatch("select-room", {
	            jid: newJid
	          });
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    updateRoomOrder: {

	      /* Takes array of room jids */

	      value: function updateRoomOrder(jids) {
	        var currentRoomData = [],
	            fullRoomData,
	            rooms;

	        currentRoomData = currentRoomData.concat(this.data.rooms.rooms, this.data.rooms.people);
	        fullRoomData = _.map(jids, function (jid) {
	          return _.find(currentRoomData, function (item) {
	            return item.jid === jid;
	          });
	        }, this);
	        rooms = _.groupBy(fullRoomData, function (chat) {
	          return chat.type == "groupchat" ? "rooms" : "people";
	        });
	        this.saveRooms(fullRoomData, this.data.active_chat, rooms);
	      },
	      writable: true,
	      configurable: true
	    },
	    saveRooms: {
	      value: function saveRooms(roomData, activeChat, roomObj) {
	        var autoJoin = _.map(roomData, function (room) {
	          return {
	            jid: room.jid,
	            name: room.name
	          };
	        });
	        var archived = _.pluck(_.filter(this.data.rooms.rooms, function (room) {
	          return !!parseInt(room.is_archived);
	        }), "jid");
	        this.set({
	          rooms: roomObj,
	          active_chat: activeChat
	        });
	        if (this.hc_init_complete) {
	          this.savePrefsDebounced({
	            autoJoin: autoJoin.length ? _.reject(autoJoin, function (room) {
	              return !! ~archived.indexOf(room.jid);
	            }) : false,
	            chatToFocus: activeChat
	          });
	          this.setRoomOrder();
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    savePrefs: {
	      value: function savePrefs(data) {
	        AppDispatcher.dispatch("save-preferences", data);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return RoomsNavStore;
	})(Store);

	module.exports = new RoomsNavStore();

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var InfiniteScrollParentMixin = __webpack_require__(249),
	    LobbyListing = __webpack_require__(250),
	    lobbyStore = __webpack_require__(251),
	    LobbyActions = __webpack_require__(52),
	    strings = __webpack_require__(252),
	    AppDispatcher = __webpack_require__(1);

	var debouncedFilter = _.debounce(LobbyActions.applyFilter, 200);

	module.exports = React.createClass({

	  displayName: "Lobby",

	  mixins: [InfiniteScrollParentMixin],

	  getInitialState: function getInitialState() {
	    return this._getDefaultState(this._getState());
	  },

	  componentDidMount: function componentDidMount() {
	    lobbyStore.on("change", this._onChange);
	    AppDispatcher.register("select-room", this._roomSelected);
	    LobbyActions.lobbyMounted();
	    this._focusAndSelect();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    lobbyStore.off("change", this._onChange);
	    AppDispatcher.unregister("select-room", this._roomSelected);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-rooms-container" },
	      React.createElement(
	        "header",
	        { className: "aui-page-header lobby-header" },
	        React.createElement(
	          "div",
	          { className: "aui-page-header-inner" },
	          React.createElement(
	            "div",
	            { className: "aui-page-header-main hc-lobby-search-content" },
	            React.createElement(
	              "form",
	              { className: "aui hc-filter-form", onSubmit: this._onSubmit },
	              React.createElement(
	                "label",
	                { className: "assistive", htmlFor: "rosterfilter" },
	                strings.filter
	              ),
	              React.createElement("input", { ref: "lobbySearchInput", type: "text", placeholder: strings.filter, className: "text hc-filter long-field mousetrap", onChange: this._onSearchFilter, onKeyPress: this._onKeyPress, value: this.state.filter.query })
	            )
	          ),
	          React.createElement(
	            "div",
	            { className: "aui-page-header-actions" },
	            React.createElement(
	              "div",
	              { className: "aui-buttons" },
	              React.createElement(
	                "button",
	                { className: "aui-button aui-button-light " + (this.state.filter.scope === "all" ? "active" : ""), onClick: this._onFilter.bind(null, "all") },
	                strings.all
	              ),
	              React.createElement(
	                "button",
	                { className: "aui-button aui-button-light " + (this.state.filter.scope === "rooms" ? "active" : ""), onClick: this._onFilter.bind(null, "rooms") },
	                strings.rooms
	              ),
	              React.createElement(
	                "button",
	                { className: "aui-button aui-button-light " + (this.state.filter.scope === "people" ? "active" : ""), onClick: this._onFilter.bind(null, "people") },
	                strings.people
	              )
	            ),
	            React.createElement(
	              "div",
	              { className: "aui-buttons" },
	              React.createElement(
	                "button",
	                { onClick: this._onCreateRoom, className: "aui-button aui-button-light", id: "create-room-button" },
	                strings.buttons.create_room
	              )
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "hc-lobby-panel", ref: "scrollable", onScroll: this._onScroll },
	        React.createElement(
	          "div",
	          { className: "aui-page-panel-inner" },
	          React.createElement(
	            "section",
	            { className: "aui-page-panel-content hc-lobby-panel-content" },
	            React.createElement(LobbyListing, { rows: this.state.rows,
	              height: this.state.height,
	              onChatOpen: this._onChatOpen,
	              total: this.state.total,
	              visibleStart: this.state.visibleStart,
	              visibleEnd: this.state.visibleEnd,
	              displayStart: this.state.displayStart,
	              displayEnd: this.state.displayEnd,
	              rowHeight: this.state.rowHeight })
	          )
	        )
	      )
	    );
	  },

	  _getState: function _getState() {
	    var rows;
	    var filter = lobbyStore.get("filter");
	    if (filter.scope === "all" && filter.query === "") {
	      rows = lobbyStore.get("all");
	    } else {
	      rows = lobbyStore.get("filtered");
	    }
	    return {
	      rows: rows,
	      total: _.size(rows),
	      filter: filter,
	      height: 1000
	    };
	  },

	  _onKeyPress: function _onKeyPress(e) {
	    if (e.which === 13) {
	      var firstItem = _.first(_.keys(this.state.rows));
	      if (firstItem) {
	        e.preventDefault();
	        LobbyActions.openChat(this.state.rows[firstItem]);
	      }
	    }
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState(), function () {
	      this._scrollState(0);
	      this.forceUpdate();
	    });
	  },

	  _onFilter: function _onFilter(scope) {
	    LobbyActions.applyFilter({
	      scope: scope
	    });
	    this.refs.scrollable.getDOMNode().scrollTop = 0;
	  },

	  _onSearchFilter: function _onSearchFilter(input) {
	    debouncedFilter({
	      query: input.target.value
	    });

	    // This is necessary since we don't want the UI debounced
	    this.setState({
	      filter: {
	        query: input.target.value
	      }
	    });
	    this.refs.scrollable.getDOMNode().scrollTop = 0;
	  },

	  _onCreateRoom: function _onCreateRoom(e) {
	    e.preventDefault();
	    LobbyActions.showCreateRoomDialog();
	  },

	  _onChatOpen: LobbyActions.openChat,

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	  },

	  _roomSelected: function _roomSelected(data) {
	    if (data.jid === "lobby") {
	      this._focusAndSelect();
	    }
	  },

	  _focusAndSelect: function _focusAndSelect() {
	    var input = this.refs.lobbySearchInput.getDOMNode();
	    if (input !== document.activeElement) {
	      input.focus();
	      input.select();
	    }
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Roster = __webpack_require__(253),
	    Files = __webpack_require__(254),
	    Spinner = __webpack_require__(77),
	    Links = __webpack_require__(255),
	    RosterStore = __webpack_require__(91),
	    LobbyActions = __webpack_require__(52),
	    ClientPreferencesStore = __webpack_require__(38);

	function getPanelState() {
	  return {
	    active_chat: RosterStore.get("active_chat"),
	    current_user: RosterStore.get("current_user"),
	    admins: RosterStore.get("admins"),
	    participants: RosterStore.get("participants"),
	    groupchat_active_panel: ClientPreferencesStore.getGroupChatActivePanel(),
	    chat_active_panel: ClientPreferencesStore.getChatActivePanel(),
	    chat_type: RosterStore.get("chat_type"),
	    active_chat_privacy: RosterStore.get("active_chat_privacy"),
	    files: RosterStore.get("files"),
	    links: RosterStore.get("links"),
	    users: RosterStore.get("users"),
	    loading: RosterStore.get("loading"),
	    initialized: RosterStore.get("initialized"),
	    guest_url: RosterStore.get("guest_url")
	  };
	}

	module.exports = React.createClass({

	  displayName: "RightSideBar",

	  getInitialState: function getInitialState() {
	    return getPanelState();
	  },

	  componentDidMount: function componentDidMount() {
	    RosterStore.on(["change"], this._onChange);
	    ClientPreferencesStore.on(["change"], this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    RosterStore.off(["change"], this._onChange);
	    ClientPreferencesStore.off(["change"], this._onChange);
	  },

	  _getActivePanel: function _getActivePanel() {
	    var panel;
	    if (this.state.chat_type === "chat") {
	      switch (this.state.chat_active_panel) {
	        case "files":
	          panel = this._filesPanel();
	          break;
	        case "links":
	          panel = this._linksPanel();
	          break;
	      }
	    } else if (this.state.chat_type === "groupchat") {
	      switch (this.state.groupchat_active_panel) {
	        case "roster":
	          panel = this._rosterPanel();
	          break;
	        case "files":
	          panel = this._filesPanel();
	          break;
	        case "links":
	          panel = this._linksPanel();
	          break;
	      }
	    }
	    return panel;
	  },

	  _rosterPanel: function _rosterPanel() {
	    return React.createElement(Roster, { admins: this.state.admins,
	      current_user_jid: this.state.current_user.user_jid,
	      participants: this.state.participants,
	      onChatOpen: this._onChatOpen,
	      active_chat_privacy: this.state.active_chat_privacy,
	      users: this.state.users,
	      guest_url: this.state.guest_url });
	  },

	  _filesPanel: function _filesPanel() {
	    return React.createElement(Files, { files: this.state.files,
	      active_chat: this.state.active_chat,
	      users: this.state.users,
	      onChatOpen: this._onChange });
	  },

	  _linksPanel: function _linksPanel() {
	    return React.createElement(Links, { links: this.state.links, users: this.state.users });
	  },

	  _onChange: function _onChange(change) {
	    this.setState(getPanelState());
	  },

	  _onChatOpen: function _onChatOpen(data) {
	    if (_.findWhere(this.state.participants.members, { jid: data.jid })) {
	      LobbyActions.openChat(data);
	    }
	  },

	  render: function render() {
	    var panel = this.state.loading ? "" : this._getActivePanel();
	    return React.createElement(
	      "div",
	      { className: "hc-roster-container" },
	      React.createElement(Spinner, { spin: this.state.loading && this.state.initialized }),
	      panel
	    );
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomActions = __webpack_require__(256),
	    ChatHeaderStore = __webpack_require__(70),
	    ChatHeaderActions = __webpack_require__(45),
	    OTOHeader = __webpack_require__(257),
	    GroupChatHeader = __webpack_require__(258),
	    TopicInput = __webpack_require__(259),
	    PresenceIcon = __webpack_require__(118),
	    Icon = __webpack_require__(247),
	    strings = __webpack_require__(260),
	    Utils = __webpack_require__(4);
	var ClientPreferencesStore = __webpack_require__(38);

	function getState() {
	  return {
	    type: ChatHeaderStore.get("type"),
	    info: ChatHeaderStore.get("chat"),
	    groupchat_active_panel: ClientPreferencesStore.getGroupChatActivePanel(),
	    chat_active_panel: ClientPreferencesStore.getChatActivePanel(),
	    topic_editing: ChatHeaderStore.get("topic_editing"),
	    topic_input_value: ChatHeaderStore.get("topic_input_value")
	  };
	}

	module.exports = React.createClass({

	  displayName: "ChatHeader",

	  getInitialState: function getInitialState() {
	    return getState();
	  },

	  componentDidMount: function componentDidMount() {
	    ChatHeaderStore.on("change", this._onChange);
	    ClientPreferencesStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    ChatHeaderStore.off("change", this._onChange);
	    ClientPreferencesStore.off("change", this._onChange);
	  },

	  _onChange: function _onChange() {
	    this.setState(getState());
	  },

	  _onPanelSelect: function _onPanelSelect(type) {
	    this._clearButtonFocus();
	    ChatHeaderActions.handlePanelSelect({
	      type: type,
	      room: this.state.info.jid
	    });
	  },

	  _clearButtonFocus: function _clearButtonFocus() {
	    var buttons = this.getDOMNode().querySelectorAll(".aui-button");
	    for (var i = 0; i < buttons.length; i++) {
	      buttons[i].blur();
	    }
	  },

	  _getHeader: function _getHeader() {
	    var header;
	    switch (this.state.type) {
	      case "chat":
	        header = React.createElement(OTOHeader, { info: this.state.info,
	          type: this.state.type,
	          chat_active_panel: this.state.chat_active_panel,
	          onPanelSelect: this._onPanelSelect });
	        break;
	      case "groupchat":
	        header = React.createElement(GroupChatHeader, { info: this.state.info,
	          type: this.state.type,
	          topic_editing: this.state.topic_editing,
	          topic_input_value: this.state.topic_input_value,
	          groupchat_active_panel: this.state.groupchat_active_panel,
	          onPanelSelect: this._onPanelSelect,
	          do_emoticons: this.state.do_emoticons });
	        break;
	      default:
	        header = React.createElement("div", null);
	    }
	    return header;
	  },

	  render: function render() {
	    if (!this.state.info) {
	      return React.createElement("div", null);
	    }

	    var header = this._getHeader();

	    return React.createElement(
	      "header",
	      { className: "aui-page-header room-header" },
	      header
	    );
	  }

	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var UI = __webpack_require__(40);
	var ChatInput = __webpack_require__(261);
	var RosterStore = __webpack_require__(91);
	var ClientPreferencesStore = __webpack_require__(38);

	module.exports = React.createClass({

	  displayName: "ChatInputBox",

	  getInitialState: function getInitialState() {
	    return this.getInputBoxState();
	  },

	  componentDidMount: function componentDidMount() {
	    RosterStore.on(["change"], this._onChange);
	    ClientPreferencesStore.on(["change"], this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    RosterStore.off(["change"], this._onChange);
	    ClientPreferencesStore.off(["change"], this._onChange);
	  },

	  getInputBoxState: function getInputBoxState() {
	    return {
	      chat_type: RosterStore.get("chat_type"),
	      chat_show_sidebar: ClientPreferencesStore.shouldShowChatSidebar(),
	      groupchat_show_sidebar: ClientPreferencesStore.shouldShowGroupChatSidebar()
	    };
	  },

	  _onChange: function _onChange() {
	    this.setState(this.getInputBoxState());
	  },

	  _hideSidebar: function _hideSidebar() {
	    return !UI.showSidebar(this.state.chat_type, this.state.groupchat_show_sidebar, this.state.chat_show_sidebar);
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        chatBoxClasses = cx({
	      "hc-chat-box": true,
	      "sidebar-hidden": this._hideSidebar()
	    });

	    return React.createElement(
	      "div",
	      { className: chatBoxClasses },
	      React.createElement(ChatInput, null)
	    );
	  }

	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  /*
	  These two arrays correspond to each other; they must be
	  the same length and the two corresponding messages must be
	  at the same index.
	  */
	  happy: ["Hold tight. Shouldn't take too long.", "Just a sec.", "One HipChat, coming right up.", "Relax. We got this.", "Here it comes.", "Let's get started.", "Workin' on it."],
	  sad: ["Yikes. This really is taking a while...", "Looks like a sec wasn't enough. Give us a minute...", "Well... coming up soon...", "Oh man. Don't freak out, we still got this...", "This hardly ever happens...", "Looks like we'll be starting a little late...", "Still workin' here... You sure do look nice today..."]
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);

	function getErrorMessage(error) {
	  var hasText = Utils.dot(error, "error.text.__text");
	  return hasText ? error.error.text.__text : "An error occurred";
	}

	module.exports = React.createClass({

	  displayName: "GeneralError403",

	  render: function render() {
	    var errorMessage = getErrorMessage(this.props.error);

	    return React.createElement(
	      "section",
	      { role: "main", className: "general-error-display aui-page-notification aui-page-size-medium" },
	      React.createElement(
	        "div",
	        { className: "aui-page-panel" },
	        React.createElement(
	          "div",
	          { className: "aui-page-pannel-inner" },
	          React.createElement(
	            "section",
	            { className: "aui-page-panel-content" },
	            React.createElement(
	              "h1",
	              null,
	              React.createElement("img", { src: "wc/assets/img/embedded/notsureif@3x.png", alt: "Not sure if", title: "Not sure if", className: "error-emoticon", width: "38", height: "50" }),
	              " you're welcome here"
	            ),
	            React.createElement(
	              "div",
	              { className: "aui-page-notification-description" },
	              React.createElement(
	                "p",
	                null,
	                React.createElement(
	                  "strong",
	                  null,
	                  errorMessage
	                )
	              ),
	              React.createElement(
	                "p",
	                null,
	                React.createElement(
	                  "a",
	                  { href: "/sign_in" },
	                  "Sign in"
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  }

	});

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);

	function getErrorMessage(error) {
	  var hasText = Utils.dot(error, "error.text.__text");
	  return hasText ? error.error.text.__text : "An error occurred";
	}

	module.exports = React.createClass({

	  displayName: "GeneralError500",

	  render: function render() {
	    var errorMessage = getErrorMessage(this.props.error);

	    return React.createElement(
	      "section",
	      { role: "main", className: "general-error-display aui-page-notification aui-page-size-medium" },
	      React.createElement(
	        "div",
	        { className: "aui-page-panel" },
	        React.createElement(
	          "div",
	          { className: "aui-page-pannel-inner" },
	          React.createElement(
	            "section",
	            { className: "aui-page-panel-content" },
	            React.createElement(
	              "h1",
	              null,
	              "Whoa! What did you do!? ",
	              React.createElement("img", { className: "error-emoticon", src: "wc/assets/img/embedded/troll@3x.png", width: "50", height: "50" })
	            ),
	            React.createElement(
	              "div",
	              { className: "aui-page-notification-description" },
	              React.createElement(
	                "p",
	                null,
	                React.createElement(
	                  "strong",
	                  null,
	                  errorMessage
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  }

	});

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Utils = __webpack_require__(4);
	var Expando = __webpack_require__(262);
	var FailedMessage = __webpack_require__(263);
	var cx = React.addons.classSet;

	module.exports = React.createClass({

	  displayName: "MessageMessageType",

	  getInitialState: function getInitialState() {
	    return {
	      truncated: true
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    this._replaceImageWithRetina(this.getDOMNode());
	  },

	  _getRenderedMessage: function _getRenderedMessage(msg) {
	    if (msg.format == "code") {
	      return this._codify(msg.rendered_body);
	    } else if (msg.format == "monospace") {
	      return React.createElement(
	        Expando,
	        { setScroll: this.props._setScroll },
	        React.createElement(
	          "pre",
	          null,
	          React.createElement("div", { "data-mid": msg.mid }),
	          msg.body
	        )
	      );
	    }
	    return msg.format == "html" ? React.createElement("div", { "data-mid": msg.mid, dangerouslySetInnerHTML: { __html: msg.body } }) : this._truncateLongText(msg.body, msg.rendered_body, msg.mid);
	  },

	  render: function render() {
	    var msg = this.props.msg;
	    var renderedMessage = this._getRenderedMessage(msg);
	    return msg.status === "failed" ? React.createElement(
	      FailedMessage,
	      { msg: msg },
	      renderedMessage
	    ) : renderedMessage;
	  },

	  _truncateLongText: function _truncateLongText(body, rendered_body, mid) {
	    var matches = body.match(/<br \/>/);
	    if (!matches || matches.length == 0) {
	      matches = body.match(/[\n\r\u2028]+.+/g);
	    }
	    var num_lines = matches ? matches.length + 1 : 1;
	    if (num_lines < Utils.TRUNCATE_LINES && body.length < Utils.TRUNCATE_CHARS) {
	      return React.createElement("div", { "data-mid": mid, className: "msg-line", dangerouslySetInnerHTML: { __html: rendered_body } });
	    }
	    return React.createElement(
	      Expando,
	      { setScroll: this.props._setScroll },
	      React.createElement("div", { className: "msg-wrap", dangerouslySetInnerHTML: { __html: _.escape(body) } })
	    );
	  },

	  _codify: function _codify(body) {
	    var matches = body.match(/<br \/>/);
	    if (!matches || matches.length == 0) {
	      matches = body.match(/[\n\r\u2028]+.+/g);
	    }
	    var num_lines = matches ? matches.length + 1 : 1;
	    if (num_lines < Utils.TRUNCATE_LINES && body.length < Utils.TRUNCATE_CHARS) {
	      return React.createElement(
	        "div",
	        { className: "msg-line" },
	        React.createElement("div", { className: "pre-wrap", dangerouslySetInnerHTML: { __html: prettyPrintOne("<pre class=\"prettyprint\">" + body + "</pre>") } })
	      );
	    }
	    return React.createElement(
	      Expando,
	      { className: "code",
	        setScroll: this.props._setScroll },
	      React.createElement(
	        "div",
	        { className: "msg-line" },
	        React.createElement("div", { className: "pre-wrap", dangerouslySetInnerHTML: { __html: prettyPrintOne("<pre class=\"prettyprint\">" + body + "</pre>") } })
	      )
	    );
	  },

	  _replaceImageWithRetina: function _replaceImageWithRetina(node) {
	    var emotes = $(node).find("img.remoticon"),
	        resolution = Math.ceil(window.devicePixelRatio);
	    for (var i = 0; i < emotes.length; i++) {
	      if (! ~emotes[i].getAttribute("src").indexOf("@" + resolution + "x")) this._doReplaceImage(emotes[i], resolution);
	      if (emotes[i].getAttribute("src").match(/\/img\/emoticons\/scumbag/) && emotes[i + 1] && emotes[i].nextSibling === emotes[i + 1]) {
	        this._scumbagify(emotes[i], emotes[i + 1]);
	      }
	    }
	  },

	  _doReplaceImage: function _doReplaceImage(img, resolution) {
	    var src = img.getAttribute("src"),
	        ext = src.split(".").pop();
	    if (resolution && resolution > 1) {
	      var image = new Image();
	      image.onload = function () {
	        img.src = src.replace("." + ext, "@" + resolution + "x." + ext);
	      };
	      image.src = src.replace("." + ext, "@" + resolution + "x." + ext);
	    }
	  },

	  _scumbagify: function _scumbagify(hat, scumbag) {
	    $(scumbag).on("load", function () {
	      var width = $(scumbag).width();
	      hat.parentNode.style.position = "relative";
	      hat.style.position = "absolute";
	      hat.style.top = scumbag.offsetTop - 3 + "px";
	      hat.style.left = scumbag.offsetLeft + width / 2 - 10 + "px";
	    });
	  }

	});

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "NotificationMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps);
	  },

	  render: function render() {
	    return this.props.msg.format == "html" ? React.createElement("div", { className: "notification msg-line", "data-mid": this.props.msg.mid, dangerouslySetInnerHTML: { __html: this.props.msg.body } }) : React.createElement("div", { className: "notification msg-line", "data-mid": this.props.msg.mid, dangerouslySetInnerHTML: { __html: this.props.msg.rendered_body } });
	  }

	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "InfoMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps);
	  },

	  render: function render() {
	    return React.createElement("div", { className: "info msg-line", "data-mid": this.props.msg.mid, dangerouslySetInnerHTML: { __html: this.props.msg.rendered_body } });
	  }

	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Utils = __webpack_require__(4);
	var FileViewerActions = __webpack_require__(264);
	var fileHelper = __webpack_require__(90);

	module.exports = React.createClass({

	  displayName: "FileMessageType",

	  getInitialState: function getInitialState() {
	    return {
	      userExpanded: null
	    };
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps) || !_.isEqual(this.state, nextState);
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.props._setScroll();
	  },

	  _shouldBeExpanded: function _shouldBeExpanded() {
	    return this.props.shouldHideGifs ? Utils.file.get_extension(this.props.msg.file_data.url) !== "gif" : true;
	  },

	  _isExpanded: function _isExpanded() {
	    return this.state.userExpanded === null ? this._shouldBeExpanded() : this.state.userExpanded;
	  },

	  render: function render() {
	    var description = React.createElement("span", { className: "description", dangerouslySetInnerHTML: { __html: this.props.msg.rendered_body } });
	    var cx = React.addons.classSet,
	        fileIcons = cx({
	      "aui-icon": true,
	      "hipchat-icon-small": true,
	      "hc-file-icon": true
	    }),
	        fileName = decodeURIComponent(this.props.msg.file_data.url.split("/").pop());

	    fileIcons = fileIcons + " " + Utils.file.get_icon_class(fileName);

	    switch (this.props.msg.file_data.filetype) {
	      case "img":
	        return React.createElement(
	          "div",
	          { "data-mid": this.props.msg.mid, className: "msg-line" },
	          React.createElement(
	            "div",
	            { className: "toggle-wrap", onClick: this._toggleImage },
	            React.createElement("span", { className: "toggle-image collapse" })
	          ),
	          React.createElement(
	            "div",
	            { className: "file-meta" },
	            React.createElement("span", { className: fileIcons }),
	            React.createElement(
	              "a",
	              { href: this.props.msg.file_data.url, target: "_blank" },
	              fileName
	            ),
	            React.createElement(
	              "span",
	              { className: "file-size" },
	              this.props.msg.file_data.file_size
	            )
	          ),
	          this._isExpanded() ? React.createElement(
	            "div",
	            { className: "file-preview-wrapper" },
	            React.createElement(
	              "a",
	              { href: this.props.msg.file_data.url, target: "_blank", title: fileHelper.basename(this.props.msg.file_data.name), onClick: this._onClick },
	              React.createElement("img", { src: this.props.msg.file_data.thumb_url })
	            )
	          ) : React.createElement(
	            "div",
	            { className: "file-preview-wrapper info" },
	            React.createElement(
	              "i",
	              null,
	              "Image hidden"
	            )
	          ),
	          description
	        );
	        break;
	      case "video":
	        return React.createElement(
	          "div",
	          { "data-mid": this.props.msg.mid, className: "msg-line" },
	          React.createElement(
	            "div",
	            { className: "file-meta" },
	            React.createElement("span", { className: fileIcons }),
	            React.createElement(
	              "a",
	              { href: this.props.msg.file_data.url, target: "_blank" },
	              fileName
	            ),
	            React.createElement(
	              "span",
	              { className: "file-size" },
	              this.props.msg.file_data.file_size
	            )
	          ),
	          React.createElement(
	            "div",
	            { className: "file-preview-wrapper video-wrap" },
	            React.createElement("span", { className: "file-video-default-poster", onClick: this._onClick })
	          ),
	          description
	        );
	        break;
	      default:
	        return React.createElement(
	          "div",
	          { "data-mid": this.props.msg.mid, className: "msg-line" },
	          React.createElement(
	            "div",
	            { className: "file-meta" },
	            React.createElement("span", { className: fileIcons }),
	            React.createElement(
	              "a",
	              { href: this.props.msg.file_data.url, target: "_blank" },
	              fileName
	            ),
	            React.createElement(
	              "span",
	              { className: "file-size" },
	              this.props.msg.file_data.file_size
	            )
	          ),
	          description
	        );
	        break;
	    }
	  },

	  _toggleImage: function _toggleImage(e) {
	    this.setState({
	      userExpanded: !this._isExpanded()
	    });
	    $(e.currentTarget).find("span").toggleClass("expand collapse");
	  },

	  _videoTypeSupported: function _videoTypeSupported(ext) {
	    var video = document.createElement("video");
	    if (video.canPlayType) {
	      return ({
	        mp4: video.canPlayType("video/mp4; codecs=\"mp4v.20.8\"") || video.canPlayType("video/mp4; codecs=\"avc1.42E01E\"") || video.canPlayType("video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\""),
	        m4v: video.canPlayType("video/mp4; codecs=\"mp4v.20.8\"") || video.canPlayType("video/mp4; codecs=\"avc1.42E01E\"") || video.canPlayType("video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\""),
	        ogv: video.canPlayType("video/ogg; codecs=\"theora\""),
	        webm: video.canPlayType("video/webm; codecs=\"vp8, vorbis\"")
	      })[ext];
	    }
	    return false;
	  },

	  _onClick: function _onClick(evt) {
	    if (fileHelper.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      FileViewerActions.openInFileViewer(this.props.msg.file_data);
	    }
	  }

	});

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "LinkMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "msg-line", "data-mid": this.props.msg.mid },
	      React.createElement("img", { src: this.props.msg.link_details.favicon_url }),
	      React.createElement(
	        "b",
	        null,
	        this.props.msg.link_details.header_text + " - "
	      ),
	      React.createElement(
	        "a",
	        { href: this.props.msg.link_details.url, target: "_blank" },
	        this._getHostname(this.props.msg.link_details.full_url || this.props.msg.link_details.url)
	      ),
	      React.createElement(
	        "div",
	        null,
	        this.props.msg.link_details.desc
	      )
	    );
	  },

	  _getHostname: function _getHostname(url) {
	    var link = document.createElement("a");
	    link.href = url;
	    return link.hostname;
	  }

	});

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ClientPreferencesStore = __webpack_require__(38);
	var Utils = __webpack_require__(4);
	var FileViewerActions = __webpack_require__(264);
	var fileHelper = __webpack_require__(90);

	module.exports = React.createClass({

	  displayName: "ImageMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps) || !_.isEqual(this.state, nextState);
	  },

	  getInitialState: function getInitialState() {
	    return {
	      userExpanded: null
	    };
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.props._setScroll();
	  },

	  _shouldBeExpanded: function _shouldBeExpanded() {
	    return this.props.shouldHideGifs ? Utils.file.get_extension(this.props.msg.link_details.image) !== "gif" : true;
	  },

	  _isExpanded: function _isExpanded() {
	    return this.state.userExpanded === null ? this._shouldBeExpanded() : this.state.userExpanded;
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "msg-line", "data-mid": this.props.msg.mid },
	      React.createElement(
	        "div",
	        { className: "toggle-wrap", onClick: this._toggleImage },
	        React.createElement("span", { className: "toggle-image collapse" })
	      ),
	      this._isExpanded() ? React.createElement(
	        "div",
	        { className: "image-preview-wrapper" },
	        React.createElement(
	          "a",
	          { href: this.props.msg.link_details.url, target: "_blank", title: fileHelper.basename(this.props.msg.link_details.url), onClick: this._onClick },
	          React.createElement("img", { src: this.props.msg.link_details.image })
	        )
	      ) : React.createElement(
	        "div",
	        { className: "info" },
	        React.createElement(
	          "i",
	          null,
	          "Image hidden"
	        )
	      )
	    );
	  },

	  _toggleImage: function _toggleImage(e) {
	    this.setState({
	      userExpanded: !this._isExpanded()
	    });
	    $(e.currentTarget).find("span").toggleClass("expand collapse");
	  },

	  _onClick: function _onClick(evt) {
	    if (fileHelper.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      FileViewerActions.openInFileViewer(this.props.msg.link_details);
	    }
	  }

	});

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Utils = __webpack_require__(4);
	var FileViewerActions = __webpack_require__(264);
	var fileHelper = __webpack_require__(90);

	module.exports = React.createClass({

	  displayName: "VideoMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "msg-line" },
	      React.createElement(
	        "div",
	        { "data-mid": this.props.msg.mid, className: "video-wrap" },
	        React.createElement(
	          "a",
	          { href: this.props.msg.link_details.url, className: "file-video-default-poster", onClick: this._onClick },
	          React.createElement("img", { src: this.props.msg.link_details.thumb })
	        ),
	        React.createElement(
	          "p",
	          { className: "linkTitle" },
	          React.createElement(
	            "a",
	            { href: this.props.msg.link_details.url, target: "_blank" },
	            this.props.msg.link_details.title
	          )
	        ),
	        React.createElement(
	          "p",
	          { className: "linkDesc" },
	          Utils.formatNumber(this.props.msg.link_details.views),
	          " views",
	          React.createElement("br", null),
	          this.props.msg.link_details.author
	        )
	      )
	    );
	  },

	  _getVideoId: function _getVideoId(url) {
	    var arr = url.split("?v=");
	    if (arr[1]) {
	      return arr[1];
	    }
	  },

	  _onClick: function _onClick(evt) {
	    if (fileHelper.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      FileViewerActions.openInFileViewer(this.props.msg.link_details);
	    }
	  }

	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "UserStateMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "state info msg-line", "data-mid": this.props.msg.mid },
	      this.props.msg.body
	    );
	  }

	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1);
	var appConfig = __webpack_require__(3);

	module.exports = React.createClass({

	  displayName: "TwitterStatusMessageType",

	  componentWillMount: function componentWillMount() {
	    this.onTwitterEmbedRendered = function (evt) {
	      AppDispatcher.dispatch("twitter-card-rendered", { element: evt.target });
	      twttr.events.unbind("rendered", this.onTwitterEmbedRendered);
	    };
	    this._isEmbedded = window.HC && HC.isEmbeddedComponent ? true : false;
	    if (!this._isEmbedded && appConfig.render_twitter_cards) {
	      this._debouncedTwttrLoad = _.debounce(twttr.widgets.load, 100, { leading: true, trailing: false });
	      twttr.events.bind("rendered", this.onTwitterEmbedRendered);
	    }
	  },

	  componentDidMount: function componentDidMount() {
	    if (!this._isEmbedded && appConfig.render_twitter_cards) {
	      this._debouncedTwttrLoad();
	    }
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    if (!this._isEmbedded && appConfig.render_twitter_cards) {
	      twttr.events.unbind("rendered", this.onTwitterEmbedRendered);
	    }
	  },

	  render: function render() {
	    var tweet;
	    if (this._isEmbedded || !appConfig.render_twitter_cards) {
	      tweet = React.createElement("div", { "data-mid": this.props.msg.mid, className: "link-wrap", dangerouslySetInnerHTML: {
	          __html: "<a class=\"linkImage\" name=\"link\" target=\"_blank\" href=\"http://twitter.com/" + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + "\" >" + "<img class=\"twitterAvatar\" height=\"48\" width=\"48\" src=\"" + (this.props.msg.link_details.profile_image_url || this.props.msg.link_details.profileImageUrl) + "\" />" + "</a><p class=\"tweet\">" + this.props.msg.body + "</p>" + "<p class=\"linkDesc tweet\">– " + this.props.msg.link_details.name + " (<a target=\"_blank\" href=\"http://twitter.com/" + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + "\" >@" + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + "</a>) via " + this.props.msg.link_details.source + "</p>"
	        } });
	    } else {
	      tweet = React.createElement(
	        "blockquote",
	        { className: "twitter-tweet hidden" },
	        React.createElement(
	          "p",
	          null,
	          this.props.msg.body
	        ),
	        React.createElement(
	          "a",
	          { href: this.props.msg.link_details.url },
	          this.props.msg.link_details.url
	        )
	      );
	    }
	    return React.createElement(
	      "div",
	      { className: "msg-line" },
	      tweet
	    );
	  }

	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "TwitterUserMessageType",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return !_.isEqual(this.props, nextProps);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "msg-line" },
	      React.createElement("div", { "data-mid": this.props.msg.mid, className: "link-wrap", dangerouslySetInnerHTML: {
	          __html: "<a class=\"linkImage\" name=\"link\" target=\"_blank\" href=\"http://twitter.com/" + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + "\" >" + "<img class=\"twitterAvatar\" height=\"48\" width=\"48\" src=\"" + (this.props.msg.link_details.profile_image_url || this.props.msg.link_details.profileImageUrl) + "\" />" + "</a><p class=\"linkDesc tweet\">" + this.props.msg.link_details.name + " (<a target=\"_blank\" href=\"http://twitter.com/" + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + "\" >@" + (this.props.msg.link_details.screen_name || this.props.msg.link_details.screenName) + "</a>)</p>" + "<p class=\"followers\">" + Utils.formatNumber(this.props.msg.link_details.followers) + " followers</p>"
	        } })
	    );
	  }

	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomsNavItem = __webpack_require__(265),
	    LobbyNavItem = __webpack_require__(266),
	    RoomsNavStore = __webpack_require__(122),
	    RoomsNavActions = __webpack_require__(55);

	function getRooms() {
	  return {
	    rooms: RoomsNavStore.get("rooms"),
	    room_order: RoomsNavStore.get("room_order"),
	    active_chat: RoomsNavStore.get("active_chat")
	  };
	}

	module.exports = React.createClass({

	  displayName: "RoomsNav",

	  getInitialState: function getInitialState() {
	    return getRooms();
	  },
	  componentDidMount: function componentDidMount() {
	    RoomsNavStore.on("change", this._onChange);
	    this.placeholder = document.createElement("li");
	    this.placeholder.className = "hc-sortable-placeholder";
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    RoomsNavStore.off("change", this._onChange);
	    this.placeholder = null;
	  },
	  _onChange: function _onChange() {
	    this.setState(getRooms());
	  },
	  _onTabSelect: function _onTabSelect(jid, type) {
	    this.setState({
	      active_chat: jid
	    });
	    RoomsNavActions.select(jid, type);
	  },
	  _onTabClose: function _onTabClose(jid, type) {
	    RoomsNavActions.close(jid, type);
	  },
	  _dragStart: function _dragStart(e) {
	    e.dataTransfer.effectAllowed = "move";
	    e.dataTransfer.setData("text/html", e.currentTarget);
	    this.setState({
	      target: e.currentTarget
	    });
	  },
	  _dragEnd: function _dragEnd(e) {
	    var jid_order = _.cloneDeep(this.state.room_order),
	        $placeholder = $(".hc-sortable").find(".hc-sortable-placeholder"),
	        end = _.indexOf(jid_order, this.state.target.dataset.jid),
	        start = Number($placeholder.index() - 1);

	    if (this.state.target && this.state.target.classList.contains("hc-person")) {
	      start = start + this.getDOMNode().querySelectorAll(".hc-room").length;
	    }
	    $placeholder.remove();
	    if (end < start) start--;
	    jid_order.splice(start, 0, jid_order.splice(end, 1)[0]);
	    RoomsNavActions.update_room_order(jid_order);
	  },
	  _dragOver: function _dragOver(e) {
	    e.preventDefault();

	    var $tabTarget = $(e.target).closest(".hc-tab"),
	        $container = $tabTarget.closest(".hc-sortable"),
	        relY,
	        height = $tabTarget.height() / 2;

	    if (this._allowDrop($container) && $tabTarget.length) {
	      relY = e.clientY - $tabTarget.offset().top;
	      if (relY > height) {
	        $tabTarget.after(this.placeholder);
	      } else if (relY < height) {
	        $tabTarget.before(this.placeholder);
	      }
	    }
	  },
	  _allowDrop: function _allowDrop($container) {
	    // Prevent dropping rooms in people list & vice versa
	    return this.state.target.classList.contains("hc-room") && $container.hasClass("hc-rooms") || this.state.target.classList.contains("hc-person") && $container.hasClass("hc-people");
	  },
	  render: function render() {
	    var _this = this;

	    var groups = ["rooms", "people"];
	    var hasItems = _.any(groups, function (group) {
	      return _this.state.rooms[group] && _this.state.rooms[group].length;
	    });
	    var content = hasItems ? this._renderPopulated(groups) : this._renderEmpty();
	    return React.createElement(
	      "div",
	      { className: "aui-navgroup-inner" },
	      React.createElement(
	        "ul",
	        { className: "aui-nav hc-sidebar-nav hc-lobby", "data-skate-ignore": true },
	        React.createElement(LobbyNavItem, { active: !this.state.active_chat || /^lobby/.test(this.state.active_chat),
	          switchTab: this._onTabSelect.bind(null, "lobby") })
	      ),
	      content
	    );
	  },

	  _renderPopulated: function _renderPopulated(groups) {
	    return _.map(groups, function (groupName) {
	      return React.createElement(
	        "div",
	        { key: "RoomsNav" + groupName },
	        this.state.rooms[groupName] && this.state.rooms[groupName].length ? React.createElement(
	          "ul",
	          { className: "aui-nav hc-sidebar-nav hc-sortable hc-" + groupName, onDragOver: this._dragOver, "data-skate-ignore": true },
	          React.createElement(
	            "li",
	            { className: "aui-nav-heading" },
	            React.createElement(
	              "strong",
	              null,
	              groupName
	            )
	          ),
	          _.map(this.state.rooms[groupName], function (room) {
	            return React.createElement(RoomsNavItem, { room: room,
	              key: "RoomsNavItem" + room.jid + room.type,
	              jid: room.jid,
	              active: this.state.active_chat == room.jid,
	              switchTab: this._onTabSelect.bind(null, room.jid, room.type),
	              closeTab: this._onTabClose.bind(null, room.jid, room.type),
	              dragStart: this._dragStart,
	              dragEnd: this._dragEnd });
	          }, this)
	        ) : _.noop(groupName)
	      );
	    }, this);
	  },

	  _renderEmpty: function _renderEmpty() {
	    return React.createElement(
	      "div",
	      { className: "noRooms" },
	      React.createElement(
	        "header",
	        null,
	        React.createElement("img", { src: "wc/assets/img/embedded/foreveralone@3x.png", width: "25", height: "25", alt: "No open chats", title: "(foreveralone)" })
	      ),
	      React.createElement(
	        "article",
	        null,
	        "No open chats"
	      )
	    );
	  }
	});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomNavStore = __webpack_require__(122),
	    Utils = __webpack_require__(4),
	    SidebarStrings = __webpack_require__(267);

	function isBelow(el, boundary) {
	  return el.offsetTop > boundary;
	}

	function isAbove(el, boundary) {
	  return el.offsetTop + el.offsetHeight < boundary;
	}

	module.exports = React.createClass({

	  displayName: "UnreadScroller",

	  getInitialState: function getInitialState() {
	    return {
	      hideTop: true,
	      hideBottom: true
	    };
	  },

	  componentWillMount: function componentWillMount() {
	    this._debouncedOnChange = _.throttle(this._onChange, 100, { trailing: true, leading: true });
	    this._tabsAbove = [];
	    this._tabsBelow = [];
	    RoomNavStore.on("change", this._debouncedOnChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    RoomNavStore.off("change", this._debouncedOnChange);
	  },

	  render: function render() {
	    var cx = React.addons.classSet;
	    var topClass = cx({
	      hidden: this.state.hideTop
	    });
	    var bottomClass = cx({
	      hidden: this.state.hideBottom
	    });
	    return React.createElement(
	      "nav",
	      { className: "aui-navgroup aui-navgroup-vertical hc-sidebar hc-sidebar-scroll", ref: "target", onScroll: this._debouncedOnChange },
	      React.createElement(
	        "div",
	        { className: "hc-unread-scroller hc-unread-scroller-top " + topClass },
	        React.createElement(
	          "a",
	          { href: "#", onClick: this._scrollUpToUnread },
	          React.createElement(
	            "span",
	            { className: "aui-icon aui-icon-small aui-iconfont-arrows-up" },
	            SidebarStrings.scroll_up_to_unread
	          )
	        )
	      ),
	      this.props.children,
	      React.createElement(
	        "div",
	        { className: "hc-unread-scroller hc-unread-scroller-bottom " + bottomClass },
	        React.createElement(
	          "a",
	          { href: "#", onClick: this._scrollDownToUnread },
	          React.createElement(
	            "span",
	            { className: "aui-icon aui-icon-small aui-iconfont-arrows-down" },
	            SidebarStrings.scroll_down_to_unread
	          )
	        )
	      )
	    );
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  _getState: function _getState() {
	    var node = this.refs.target.getDOMNode();
	    var tabs = $(".hc-badge").closest(".hc-tab");
	    this._tabsAbove = tabs.filter(function (idx, el) {
	      return isAbove(el, node.scrollTop);
	    });
	    this._tabsBelow = tabs.filter(function (idx, el) {
	      return isBelow(el, node.scrollTop + node.offsetHeight);
	    });
	    return {
	      hideTop: !this._tabsAbove.length,
	      hideBottom: !this._tabsBelow.length,
	      topBoundary: node.scrollTop,
	      bottomBoundary: node.scrollTop + node.offsetHeight
	    };
	  },

	  _scrollUpToUnread: function _scrollUpToUnread(evt) {
	    evt.preventDefault();
	    this.setState(this._getState());
	    if (this._tabsAbove.length > 0) {
	      Utils.scrollIntoViewIfNeeded(this._tabsAbove.get(this._tabsAbove.length - 1), this.refs.target.getDOMNode());
	    }
	  },

	  _scrollDownToUnread: function _scrollDownToUnread(evt) {
	    evt.preventDefault();
	    this.setState(this._getState());
	    if (this._tabsBelow.length > 0) {
	      Utils.scrollIntoViewIfNeeded(this._tabsBelow.get(0), this.refs.target.getDOMNode());
	    }
	  }
	});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : afrikaans (af)
	// author : Werner Mollentze : https://github.com/wernerm

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('af', {
	        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	        meridiemParse: /vm|nm/i,
	        isPM : function (input) {
	            return /^nm$/i.test(input);
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower ? 'vm' : 'VM';
	            } else {
	                return isLower ? 'nm' : 'NM';
	            }
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Vandag om] LT',
	            nextDay : '[Môre om] LT',
	            nextWeek : 'dddd [om] LT',
	            lastDay : '[Gister om] LT',
	            lastWeek : '[Laas] dddd [om] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'oor %s',
	            past : '%s gelede',
	            s : '\'n paar sekondes',
	            m : '\'n minuut',
	            mm : '%d minute',
	            h : '\'n uur',
	            hh : '%d ure',
	            d : '\'n dag',
	            dd : '%d dae',
	            M : '\'n maand',
	            MM : '%d maande',
	            y : '\'n jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	        },
	        week : {
	            dow : 1, // Maandag is die eerste dag van die week.
	            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	        }
	    });
	}));


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Moroccan Arabic (ar-ma)
	// author : ElFadili Yassine : https://github.com/ElFadiliY
	// author : Abdel Said : https://github.com/abdelsaid

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ar-ma', {
	        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Arabic Saudi Arabia (ar-sa)
	// author : Suhail Alkowaileet : https://github.com/xsoh

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    };

	    return moment.defineLocale('ar-sa', {
	        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'في %s',
	            past : 'منذ %s',
	            s : 'ثوان',
	            m : 'دقيقة',
	            mm : '%d دقائق',
	            h : 'ساعة',
	            hh : '%d ساعات',
	            d : 'يوم',
	            dd : '%d أيام',
	            M : 'شهر',
	            MM : '%d أشهر',
	            y : 'سنة',
	            yy : '%d سنوات'
	        },
	        preparse: function (string) {
	            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale  : Tunisian Arabic (ar-tn)

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ar-tn', {
	        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'LT:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[اليوم على الساعة] LT',
	            nextDay: '[غدا على الساعة] LT',
	            nextWeek: 'dddd [على الساعة] LT',
	            lastDay: '[أمس على الساعة] LT',
	            lastWeek: 'dddd [على الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'في %s',
	            past: 'منذ %s',
	            s: 'ثوان',
	            m: 'دقيقة',
	            mm: '%d دقائق',
	            h: 'ساعة',
	            hh: '%d ساعات',
	            d: 'يوم',
	            dd: '%d أيام',
	            M: 'شهر',
	            MM: '%d أشهر',
	            y: 'سنة',
	            yy: '%d سنوات'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// Locale: Arabic (ar)
	// Author: Abdel Said: https://github.com/abdelsaid
	// Changes in months, weekdays: Ahmed Elkhatib
	// Native plural forms: forabi https://github.com/forabi

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '١',
	        '2': '٢',
	        '3': '٣',
	        '4': '٤',
	        '5': '٥',
	        '6': '٦',
	        '7': '٧',
	        '8': '٨',
	        '9': '٩',
	        '0': '٠'
	    }, numberMap = {
	        '١': '1',
	        '٢': '2',
	        '٣': '3',
	        '٤': '4',
	        '٥': '5',
	        '٦': '6',
	        '٧': '7',
	        '٨': '8',
	        '٩': '9',
	        '٠': '0'
	    }, pluralForm = function (n) {
	        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	    }, plurals = {
	        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	    }, pluralize = function (u) {
	        return function (number, withoutSuffix, string, isFuture) {
	            var f = pluralForm(number),
	                str = plurals[u][pluralForm(number)];
	            if (f === 2) {
	                str = str[withoutSuffix ? 0 : 1];
	            }
	            return str.replace(/%d/i, number);
	        };
	    }, months = [
	        'كانون الثاني يناير',
	        'شباط فبراير',
	        'آذار مارس',
	        'نيسان أبريل',
	        'أيار مايو',
	        'حزيران يونيو',
	        'تموز يوليو',
	        'آب أغسطس',
	        'أيلول سبتمبر',
	        'تشرين الأول أكتوبر',
	        'تشرين الثاني نوفمبر',
	        'كانون الأول ديسمبر'
	    ];

	    return moment.defineLocale('ar', {
	        months : months,
	        monthsShort : months,
	        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        meridiemParse: /ص|م/,
	        isPM : function (input) {
	            return 'م' === input;
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ص';
	            } else {
	                return 'م';
	            }
	        },
	        calendar : {
	            sameDay: '[اليوم عند الساعة] LT',
	            nextDay: '[غدًا عند الساعة] LT',
	            nextWeek: 'dddd [عند الساعة] LT',
	            lastDay: '[أمس عند الساعة] LT',
	            lastWeek: 'dddd [عند الساعة] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'بعد %s',
	            past : 'منذ %s',
	            s : pluralize('s'),
	            m : pluralize('m'),
	            mm : pluralize('m'),
	            h : pluralize('h'),
	            hh : pluralize('h'),
	            d : pluralize('d'),
	            dd : pluralize('d'),
	            M : pluralize('M'),
	            MM : pluralize('M'),
	            y : pluralize('y'),
	            yy : pluralize('y')
	        },
	        preparse: function (string) {
	            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : azerbaijani (az)
	// author : topchiyev : https://github.com/topchiyev

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var suffixes = {
	        1: '-inci',
	        5: '-inci',
	        8: '-inci',
	        70: '-inci',
	        80: '-inci',

	        2: '-nci',
	        7: '-nci',
	        20: '-nci',
	        50: '-nci',

	        3: '-üncü',
	        4: '-üncü',
	        100: '-üncü',

	        6: '-ncı',

	        9: '-uncu',
	        10: '-uncu',
	        30: '-uncu',

	        60: '-ıncı',
	        90: '-ıncı'
	    };
	    return moment.defineLocale('az', {
	        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[sabah saat] LT',
	            nextWeek : '[gələn həftə] dddd [saat] LT',
	            lastDay : '[dünən] LT',
	            lastWeek : '[keçən həftə] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s əvvəl',
	            s : 'birneçə saniyyə',
	            m : 'bir dəqiqə',
	            mm : '%d dəqiqə',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir il',
	            yy : '%d il'
	        },
	        meridiemParse: /gecə|səhər|gündüz|axşam/,
	        isPM : function (input) {
	            return /^(gündüz|axşam)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'gecə';
	            } else if (hour < 12) {
	                return 'səhər';
	            } else if (hour < 17) {
	                return 'gündüz';
	            } else {
	                return 'axşam';
	            }
	        },
	        ordinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '-ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;

	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : belarusian (be)
	// author : Dmitry Demidov : https://github.com/demidov91
	// author: Praleska: http://praleska.pro/
	// Author : Menelion Elensúle : https://github.com/Oire

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }

	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	            'dd': 'дзень_дні_дзён',
	            'MM': 'месяц_месяцы_месяцаў',
	            'yy': 'год_гады_гадоў'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвіліна' : 'хвіліну';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'гадзіна' : 'гадзіну';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }

	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_'),
	            'accusative': 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_')
	        },

	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';

	        return months[nounCase][m.month()];
	    }

	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	            'accusative': 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_')
	        },

	        nounCase = (/\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';

	        return weekdays[nounCase][m.day()];
	    }

	    return moment.defineLocale('be', {
	        months : monthsCaseReplace,
	        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., LT',
	            LLLL : 'dddd, D MMMM YYYY г., LT'
	        },
	        calendar : {
	            sameDay: '[Сёння ў] LT',
	            nextDay: '[Заўтра ў] LT',
	            lastDay: '[Учора ў] LT',
	            nextWeek: function () {
	                return '[У] dddd [ў] LT';
	            },
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[У мінулую] dddd [ў] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[У мінулы] dddd [ў] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'праз %s',
	            past : '%s таму',
	            s : 'некалькі секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : relativeTimeWithPlural,
	            hh : relativeTimeWithPlural,
	            d : 'дзень',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },
	        meridiemParse: /ночы|раніцы|дня|вечара/,
	        isPM : function (input) {
	            return /^(дня|вечара)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночы';
	            } else if (hour < 12) {
	                return 'раніцы';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечара';
	            }
	        },

	        ordinalParse: /\d{1,2}-(і|ы|га)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	            case 'D':
	                return number + '-га';
	            default:
	                return number;
	            }
	        },

	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : bulgarian (bg)
	// author : Krasen Borisov : https://github.com/kraz

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('bg', {
	        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Днес в] LT',
	            nextDay : '[Утре в] LT',
	            nextWeek : 'dddd [в] LT',
	            lastDay : '[Вчера в] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[В изминалата] dddd [в] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[В изминалия] dddd [в] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'след %s',
	            past : 'преди %s',
	            s : 'няколко секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дни',
	            M : 'месец',
	            MM : '%d месеца',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Bengali (bn)
	// author : Kaushik Gandhi : https://github.com/kaushikgandhi

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '১',
	        '2': '২',
	        '3': '৩',
	        '4': '৪',
	        '5': '৫',
	        '6': '৬',
	        '7': '৭',
	        '8': '৮',
	        '9': '৯',
	        '0': '০'
	    },
	    numberMap = {
	        '১': '1',
	        '২': '2',
	        '৩': '3',
	        '৪': '4',
	        '৫': '5',
	        '৬': '6',
	        '৭': '7',
	        '৮': '8',
	        '৯': '9',
	        '০': '0'
	    };

	    return moment.defineLocale('bn', {
	        months : 'জানুয়ারী_ফেবুয়ারী_মার্চ_এপ্রিল_মে_জুন_জুলাই_অগাস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	        monthsShort : 'জানু_ফেব_মার্চ_এপর_মে_জুন_জুল_অগ_সেপ্ট_অক্টো_নভ_ডিসেম্'.split('_'),
	        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পত্তিবার_শুক্রুবার_শনিবার'.split('_'),
	        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পত্তি_শুক্রু_শনি'.split('_'),
	        weekdaysMin : 'রব_সম_মঙ্গ_বু_ব্রিহ_শু_শনি'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm সময়',
	            LTS : 'A h:mm:ss সময়',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[আজ] LT',
	            nextDay : '[আগামীকাল] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[গতকাল] LT',
	            lastWeek : '[গত] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s পরে',
	            past : '%s আগে',
	            s : 'কএক সেকেন্ড',
	            m : 'এক মিনিট',
	            mm : '%d মিনিট',
	            h : 'এক ঘন্টা',
	            hh : '%d ঘন্টা',
	            d : 'এক দিন',
	            dd : '%d দিন',
	            M : 'এক মাস',
	            MM : '%d মাস',
	            y : 'এক বছর',
	            yy : '%d বছর'
	        },
	        preparse: function (string) {
	            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /রাত|শকাল|দুপুর|বিকেল|রাত/,
	        isPM: function (input) {
	            return /^(দুপুর|বিকেল|রাত)$/.test(input);
	        },
	        //Bengali is a vast language its spoken
	        //in different forms in various parts of the world.
	        //I have just generalized with most common one used
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'রাত';
	            } else if (hour < 10) {
	                return 'শকাল';
	            } else if (hour < 17) {
	                return 'দুপুর';
	            } else if (hour < 20) {
	                return 'বিকেল';
	            } else {
	                return 'রাত';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : tibetan (bo)
	// author : Thupten N. Chakrishar : https://github.com/vajradog

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '༡',
	        '2': '༢',
	        '3': '༣',
	        '4': '༤',
	        '5': '༥',
	        '6': '༦',
	        '7': '༧',
	        '8': '༨',
	        '9': '༩',
	        '0': '༠'
	    },
	    numberMap = {
	        '༡': '1',
	        '༢': '2',
	        '༣': '3',
	        '༤': '4',
	        '༥': '5',
	        '༦': '6',
	        '༧': '7',
	        '༨': '8',
	        '༩': '9',
	        '༠': '0'
	    };

	    return moment.defineLocale('bo', {
	        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[དི་རིང] LT',
	            nextDay : '[སང་ཉིན] LT',
	            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	            lastDay : '[ཁ་སང] LT',
	            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s ལ་',
	            past : '%s སྔན་ལ',
	            s : 'ལམ་སང',
	            m : 'སྐར་མ་གཅིག',
	            mm : '%d སྐར་མ',
	            h : 'ཆུ་ཚོད་གཅིག',
	            hh : '%d ཆུ་ཚོད',
	            d : 'ཉིན་གཅིག',
	            dd : '%d ཉིན་',
	            M : 'ཟླ་བ་གཅིག',
	            MM : '%d ཟླ་བ',
	            y : 'ལོ་གཅིག',
	            yy : '%d ལོ'
	        },
	        preparse: function (string) {
	            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	        isPM: function (input) {
	            return /^(ཉིན་གུང|དགོང་དག|མཚན་མོ)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'མཚན་མོ';
	            } else if (hour < 10) {
	                return 'ཞོགས་ཀས';
	            } else if (hour < 17) {
	                return 'ཉིན་གུང';
	            } else if (hour < 20) {
	                return 'དགོང་དག';
	            } else {
	                return 'མཚན་མོ';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : breton (br)
	// author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function relativeTimeWithMutation(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'munutenn',
	            'MM': 'miz',
	            'dd': 'devezh'
	        };
	        return number + ' ' + mutation(format[key], number);
	    }

	    function specialMutationForYears(number) {
	        switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	        }
	    }

	    function lastNumber(number) {
	        if (number > 9) {
	            return lastNumber(number % 10);
	        }
	        return number;
	    }

	    function mutation(text, number) {
	        if (number === 2) {
	            return softMutation(text);
	        }
	        return text;
	    }

	    function softMutation(text) {
	        var mutationTable = {
	            'm': 'v',
	            'b': 'v',
	            'd': 'z'
	        };
	        if (mutationTable[text.charAt(0)] === undefined) {
	            return text;
	        }
	        return mutationTable[text.charAt(0)] + text.substring(1);
	    }

	    return moment.defineLocale('br', {
	        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h[e]mm A',
	            LTS : 'h[e]mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D [a viz] MMMM YYYY',
	            LLL : 'D [a viz] MMMM YYYY LT',
	            LLLL : 'dddd, D [a viz] MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Hiziv da] LT',
	            nextDay : '[Warc\'hoazh da] LT',
	            nextWeek : 'dddd [da] LT',
	            lastDay : '[Dec\'h da] LT',
	            lastWeek : 'dddd [paset da] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'a-benn %s',
	            past : '%s \'zo',
	            s : 'un nebeud segondennoù',
	            m : 'ur vunutenn',
	            mm : relativeTimeWithMutation,
	            h : 'un eur',
	            hh : '%d eur',
	            d : 'un devezh',
	            dd : relativeTimeWithMutation,
	            M : 'ur miz',
	            MM : relativeTimeWithMutation,
	            y : 'ur bloaz',
	            yy : specialMutationForYears
	        },
	        ordinalParse: /\d{1,2}(añ|vet)/,
	        ordinal : function (number) {
	            var output = (number === 1) ? 'añ' : 'vet';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : bosnian (bs)
	// author : Nedim Cholich : https://github.com/frontyard
	// based on (hr) translation by Bojan Marković

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }

	    return moment.defineLocale('bs', {
	        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',

	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : catalan (ca)
	// author : Juan G. Hurtado : https://github.com/juanghurtado

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ca', {
	        months : 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextDay : function () {
	                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastDay : function () {
	                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'fa %s',
	            s : 'uns segons',
	            m : 'un minut',
	            mm : '%d minuts',
	            h : 'una hora',
	            hh : '%d hores',
	            d : 'un dia',
	            dd : '%d dies',
	            M : 'un mes',
	            MM : '%d mesos',
	            y : 'un any',
	            yy : '%d anys'
	        },
	        ordinalParse: /\d{1,2}(r|n|t|è|a)/,
	        ordinal : function (number, period) {
	            var output = (number === 1) ? 'r' :
	                (number === 2) ? 'n' :
	                (number === 3) ? 'r' :
	                (number === 4) ? 't' : 'è';
	            if (period === 'w' || period === 'W') {
	                output = 'a';
	            }
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : czech (cs)
	// author : petrbela : https://github.com/petrbela

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
	        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');

	    function plural(n) {
	        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	    }

	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dní');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'měsíce' : 'měsíců');
	            } else {
	                return result + 'měsíci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	        }
	    }

	    return moment.defineLocale('cs', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[dnes v] LT',
	            nextDay: '[zítra v] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v neděli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve středu v] LT';
	                case 4:
	                    return '[ve čtvrtek v] LT';
	                case 5:
	                    return '[v pátek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	                }
	            },
	            lastDay: '[včera v] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulou neděli v] LT';
	                case 1:
	                case 2:
	                    return '[minulé] dddd [v] LT';
	                case 3:
	                    return '[minulou středu v] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'před %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse : /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : chuvash (cv)
	// author : Anatoly Mironov : https://github.com/mirontoli

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('cv', {
	        months : 'кăрлач_нарăс_пуш_ака_май_çĕртме_утă_çурла_авăн_юпа_чӳк_раштав'.split('_'),
	        monthsShort : 'кăр_нар_пуш_ака_май_çĕр_утă_çур_ав_юпа_чӳк_раш'.split('_'),
	        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кĕçнерникун_эрнекун_шăматкун'.split('_'),
	        weekdaysShort : 'выр_тун_ытл_юн_кĕç_эрн_шăм'.split('_'),
	        weekdaysMin : 'вр_тн_ыт_юн_кç_эр_шм'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ]',
	            LLL : 'YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT',
	            LLLL : 'dddd, YYYY [çулхи] MMMM [уйăхĕн] D[-мĕшĕ], LT'
	        },
	        calendar : {
	            sameDay: '[Паян] LT [сехетре]',
	            nextDay: '[Ыран] LT [сехетре]',
	            lastDay: '[Ĕнер] LT [сехетре]',
	            nextWeek: '[Çитес] dddd LT [сехетре]',
	            lastWeek: '[Иртнĕ] dddd LT [сехетре]',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (output) {
	                var affix = /сехет$/i.exec(output) ? 'рен' : /çул$/i.exec(output) ? 'тан' : 'ран';
	                return output + affix;
	            },
	            past : '%s каялла',
	            s : 'пĕр-ик çеккунт',
	            m : 'пĕр минут',
	            mm : '%d минут',
	            h : 'пĕр сехет',
	            hh : '%d сехет',
	            d : 'пĕр кун',
	            dd : '%d кун',
	            M : 'пĕр уйăх',
	            MM : '%d уйăх',
	            y : 'пĕр çул',
	            yy : '%d çул'
	        },
	        ordinalParse: /\d{1,2}-мĕш/,
	        ordinal : '%d-мĕш',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Welsh (cy)
	// author : Robert Allen

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('cy', {
	        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	        // time formats are the same as en-gb
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'LT:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd, D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[Heddiw am] LT',
	            nextDay: '[Yfory am] LT',
	            nextWeek: 'dddd [am] LT',
	            lastDay: '[Ddoe am] LT',
	            lastWeek: 'dddd [diwethaf am] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'mewn %s',
	            past: '%s yn ôl',
	            s: 'ychydig eiliadau',
	            m: 'munud',
	            mm: '%d munud',
	            h: 'awr',
	            hh: '%d awr',
	            d: 'diwrnod',
	            dd: '%d diwrnod',
	            M: 'mis',
	            MM: '%d mis',
	            y: 'blwyddyn',
	            yy: '%d flynedd'
	        },
	        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	        ordinal: function (number) {
	            var b = number,
	                output = '',
	                lookup = [
	                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	                ];

	            if (b > 20) {
	                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                    output = 'fed'; // not 30ain, 70ain or 90ain
	                } else {
	                    output = 'ain';
	                }
	            } else if (b > 0) {
	                output = lookup[b];
	            }

	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : danish (da)
	// author : Ulrik Nielsen : https://github.com/mrbase

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('da', {
	        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd [d.] D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[I dag kl.] LT',
	            nextDay : '[I morgen kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[I går kl.] LT',
	            lastWeek : '[sidste] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : '%s siden',
	            s : 'få sekunder',
	            m : 'et minut',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dage',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'et år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : austrian german (de-at)
	// author : lluchs : https://github.com/lluchs
	// author: Menelion Elensúle: https://github.com/Oire
	// author : Martin Groller : https://github.com/MadMG

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    return moment.defineLocale('de-at', {
	        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : german (de)
	// author : lluchs : https://github.com/lluchs
	// author: Menelion Elensúle: https://github.com/Oire

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eine Minute', 'einer Minute'],
	            'h': ['eine Stunde', 'einer Stunde'],
	            'd': ['ein Tag', 'einem Tag'],
	            'dd': [number + ' Tage', number + ' Tagen'],
	            'M': ['ein Monat', 'einem Monat'],
	            'MM': [number + ' Monate', number + ' Monaten'],
	            'y': ['ein Jahr', 'einem Jahr'],
	            'yy': [number + ' Jahre', number + ' Jahren']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    return moment.defineLocale('de', {
	        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Heute um] LT [Uhr]',
	            sameElse: 'L',
	            nextDay: '[Morgen um] LT [Uhr]',
	            nextWeek: 'dddd [um] LT [Uhr]',
	            lastDay: '[Gestern um] LT [Uhr]',
	            lastWeek: '[letzten] dddd [um] LT [Uhr]'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : 'vor %s',
	            s : 'ein paar Sekunden',
	            m : processRelativeTime,
	            mm : '%d Minuten',
	            h : processRelativeTime,
	            hh : '%d Stunden',
	            d : processRelativeTime,
	            dd : processRelativeTime,
	            M : processRelativeTime,
	            MM : processRelativeTime,
	            y : processRelativeTime,
	            yy : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : modern greek (el)
	// author : Aggelos Karalias : https://github.com/mehiel

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('el', {
	        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	        months : function (momentToFormat, format) {
	            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	                return this._monthsGenitiveEl[momentToFormat.month()];
	            } else {
	                return this._monthsNominativeEl[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'μμ' : 'ΜΜ';
	            } else {
	                return isLower ? 'πμ' : 'ΠΜ';
	            }
	        },
	        isPM : function (input) {
	            return ((input + '').toLowerCase()[0] === 'μ');
	        },
	        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendarEl : {
	            sameDay : '[Σήμερα {}] LT',
	            nextDay : '[Αύριο {}] LT',
	            nextWeek : 'dddd [{}] LT',
	            lastDay : '[Χθες {}] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                    case 6:
	                        return '[το προηγούμενο] dddd [{}] LT';
	                    default:
	                        return '[την προηγούμενη] dddd [{}] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        calendar : function (key, mom) {
	            var output = this._calendarEl[key],
	                hours = mom && mom.hours();

	            if (typeof output === 'function') {
	                output = output.apply(mom);
	            }

	            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	        },
	        relativeTime : {
	            future : 'σε %s',
	            past : '%s πριν',
	            s : 'λίγα δευτερόλεπτα',
	            m : 'ένα λεπτό',
	            mm : '%d λεπτά',
	            h : 'μία ώρα',
	            hh : '%d ώρες',
	            d : 'μία μέρα',
	            dd : '%d μέρες',
	            M : 'ένας μήνας',
	            MM : '%d μήνες',
	            y : 'ένας χρόνος',
	            yy : '%d χρόνια'
	        },
	        ordinalParse: /\d{1,2}η/,
	        ordinal: '%dη',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : australian english (en-au)

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('en-au', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : canadian english (en-ca)
	// author : Jonathan Abourbih : https://github.com/jonbca

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('en-ca', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM, YYYY',
	            LLL : 'D MMMM, YYYY LT',
	            LLLL : 'dddd, D MMMM, YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        }
	    });
	}));


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : great britain english (en-gb)
	// author : Chris Gedrim : https://github.com/chrisgedrim

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('en-gb', {
	        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'HH:mm:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Today at] LT',
	            nextDay : '[Tomorrow at] LT',
	            nextWeek : 'dddd [at] LT',
	            lastDay : '[Yesterday at] LT',
	            lastWeek : '[Last] dddd [at] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'in %s',
	            past : '%s ago',
	            s : 'a few seconds',
	            m : 'a minute',
	            mm : '%d minutes',
	            h : 'an hour',
	            hh : '%d hours',
	            d : 'a day',
	            dd : '%d days',
	            M : 'a month',
	            MM : '%d months',
	            y : 'a year',
	            yy : '%d years'
	        },
	        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'th' :
	                (b === 1) ? 'st' :
	                (b === 2) ? 'nd' :
	                (b === 3) ? 'rd' : 'th';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : esperanto (eo)
	// author : Colin Dean : https://github.com/colindean
	// komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('eo', {
	        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	        weekdays : 'Dimanĉo_Lundo_Mardo_Merkredo_Ĵaŭdo_Vendredo_Sabato'.split('_'),
	        weekdaysShort : 'Dim_Lun_Mard_Merk_Ĵaŭ_Ven_Sab'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Ĵa_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D[-an de] MMMM, YYYY',
	            LLL : 'D[-an de] MMMM, YYYY LT',
	            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY LT'
	        },
	        meridiemParse: /[ap]\.t\.m/i,
	        isPM: function (input) {
	            return input.charAt(0).toLowerCase() === 'p';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours > 11) {
	                return isLower ? 'p.t.m.' : 'P.T.M.';
	            } else {
	                return isLower ? 'a.t.m.' : 'A.T.M.';
	            }
	        },
	        calendar : {
	            sameDay : '[Hodiaŭ je] LT',
	            nextDay : '[Morgaŭ je] LT',
	            nextWeek : 'dddd [je] LT',
	            lastDay : '[Hieraŭ je] LT',
	            lastWeek : '[pasinta] dddd [je] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'je %s',
	            past : 'antaŭ %s',
	            s : 'sekundoj',
	            m : 'minuto',
	            mm : '%d minutoj',
	            h : 'horo',
	            hh : '%d horoj',
	            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	            dd : '%d tagoj',
	            M : 'monato',
	            MM : '%d monatoj',
	            y : 'jaro',
	            yy : '%d jaroj'
	        },
	        ordinalParse: /\d{1,2}a/,
	        ordinal : '%da',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : spanish (es)
	// author : Julio Napurí : https://github.com/julionc

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
	        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	    return moment.defineLocale('es', {
	        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShort[m.month()];
	            } else {
	                return monthsShortDot[m.month()];
	            }
	        },
	        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY LT',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastDay : function () {
	                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            lastWeek : function () {
	                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'en %s',
	            past : 'hace %s',
	            s : 'unos segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'una hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un año',
	            yy : '%d años'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : estonian (et)
	// author : Henry Kehlmann : https://github.com/madhenry
	// improvements : Illimar Tambek : https://github.com/ragulka

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	            'm' : ['ühe minuti', 'üks minut'],
	            'mm': [number + ' minuti', number + ' minutit'],
	            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	            'hh': [number + ' tunni', number + ' tundi'],
	            'd' : ['ühe päeva', 'üks päev'],
	            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	            'MM': [number + ' kuu', number + ' kuud'],
	            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	            'yy': [number + ' aasta', number + ' aastat']
	        };
	        if (withoutSuffix) {
	            return format[key][2] ? format[key][2] : format[key][1];
	        }
	        return isFuture ? format[key][0] : format[key][1];
	    }

	    return moment.defineLocale('et', {
	        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	        longDateFormat : {
	            LT   : 'H:mm',
	            LTS : 'LT:ss',
	            L    : 'DD.MM.YYYY',
	            LL   : 'D. MMMM YYYY',
	            LLL  : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[Täna,] LT',
	            nextDay  : '[Homme,] LT',
	            nextWeek : '[Järgmine] dddd LT',
	            lastDay  : '[Eile,] LT',
	            lastWeek : '[Eelmine] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s pärast',
	            past   : '%s tagasi',
	            s      : processRelativeTime,
	            m      : processRelativeTime,
	            mm     : processRelativeTime,
	            h      : processRelativeTime,
	            hh     : processRelativeTime,
	            d      : processRelativeTime,
	            dd     : '%d päeva',
	            M      : processRelativeTime,
	            MM     : processRelativeTime,
	            y      : processRelativeTime,
	            yy     : processRelativeTime
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : euskara (eu)
	// author : Eneko Illarramendi : https://github.com/eillarra

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('eu', {
	        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY[ko] MMMM[ren] D[a]',
	            LLL : 'YYYY[ko] MMMM[ren] D[a] LT',
	            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] LT',
	            l : 'YYYY-M-D',
	            ll : 'YYYY[ko] MMM D[a]',
	            lll : 'YYYY[ko] MMM D[a] LT',
	            llll : 'ddd, YYYY[ko] MMM D[a] LT'
	        },
	        calendar : {
	            sameDay : '[gaur] LT[etan]',
	            nextDay : '[bihar] LT[etan]',
	            nextWeek : 'dddd LT[etan]',
	            lastDay : '[atzo] LT[etan]',
	            lastWeek : '[aurreko] dddd LT[etan]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s barru',
	            past : 'duela %s',
	            s : 'segundo batzuk',
	            m : 'minutu bat',
	            mm : '%d minutu',
	            h : 'ordu bat',
	            hh : '%d ordu',
	            d : 'egun bat',
	            dd : '%d egun',
	            M : 'hilabete bat',
	            MM : '%d hilabete',
	            y : 'urte bat',
	            yy : '%d urte'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Persian (fa)
	// author : Ebrahim Byagowi : https://github.com/ebraminio

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '۱',
	        '2': '۲',
	        '3': '۳',
	        '4': '۴',
	        '5': '۵',
	        '6': '۶',
	        '7': '۷',
	        '8': '۸',
	        '9': '۹',
	        '0': '۰'
	    }, numberMap = {
	        '۱': '1',
	        '۲': '2',
	        '۳': '3',
	        '۴': '4',
	        '۵': '5',
	        '۶': '6',
	        '۷': '7',
	        '۸': '8',
	        '۹': '9',
	        '۰': '0'
	    };

	    return moment.defineLocale('fa', {
	        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        meridiemParse: /قبل از ظهر|بعد از ظهر/,
	        isPM: function (input) {
	            return /بعد از ظهر/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'قبل از ظهر';
	            } else {
	                return 'بعد از ظهر';
	            }
	        },
	        calendar : {
	            sameDay : '[امروز ساعت] LT',
	            nextDay : '[فردا ساعت] LT',
	            nextWeek : 'dddd [ساعت] LT',
	            lastDay : '[دیروز ساعت] LT',
	            lastWeek : 'dddd [پیش] [ساعت] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'در %s',
	            past : '%s پیش',
	            s : 'چندین ثانیه',
	            m : 'یک دقیقه',
	            mm : '%d دقیقه',
	            h : 'یک ساعت',
	            hh : '%d ساعت',
	            d : 'یک روز',
	            dd : '%d روز',
	            M : 'یک ماه',
	            MM : '%d ماه',
	            y : 'یک سال',
	            yy : '%d سال'
	        },
	        preparse: function (string) {
	            return string.replace(/[۰-۹]/g, function (match) {
	                return numberMap[match];
	            }).replace(/،/g, ',');
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            }).replace(/,/g, '،');
	        },
	        ordinalParse: /\d{1,2}م/,
	        ordinal : '%dم',
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : finnish (fi)
	// author : Tarmo Aidantausta : https://github.com/bleadof

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
	        numbersFuture = [
	            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	            numbersPast[7], numbersPast[8], numbersPast[9]
	        ];

	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = '';
	        switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'päivän' : 'päivä';
	        case 'dd':
	            result = isFuture ? 'päivän' : 'päivää';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	        }
	        result = verbalNumber(number, isFuture) + ' ' + result;
	        return result;
	    }

	    function verbalNumber(number, isFuture) {
	        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	    }

	    return moment.defineLocale('fi', {
	        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'HH.mm.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'Do MMMM[ta] YYYY',
	            LLL : 'Do MMMM[ta] YYYY, [klo] LT',
	            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] LT',
	            l : 'D.M.YYYY',
	            ll : 'Do MMM YYYY',
	            lll : 'Do MMM YYYY, [klo] LT',
	            llll : 'ddd, Do MMM YYYY, [klo] LT'
	        },
	        calendar : {
	            sameDay : '[tänään] [klo] LT',
	            nextDay : '[huomenna] [klo] LT',
	            nextWeek : 'dddd [klo] LT',
	            lastDay : '[eilen] [klo] LT',
	            lastWeek : '[viime] dddd[na] [klo] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s päästä',
	            past : '%s sitten',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : faroese (fo)
	// author : Ragnar Johannesen : https://github.com/ragnar123

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('fo', {
	        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D. MMMM, YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Í dag kl.] LT',
	            nextDay : '[Í morgin kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[Í gjár kl.] LT',
	            lastWeek : '[síðstu] dddd [kl] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'um %s',
	            past : '%s síðani',
	            s : 'fá sekund',
	            m : 'ein minutt',
	            mm : '%d minuttir',
	            h : 'ein tími',
	            hh : '%d tímar',
	            d : 'ein dagur',
	            dd : '%d dagar',
	            M : 'ein mánaði',
	            MM : '%d mánaðir',
	            y : 'eitt ár',
	            yy : '%d ár'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : canadian french (fr-ca)
	// author : Jonathan Abourbih : https://github.com/jonbca

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('fr-ca', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        }
	    });
	}));


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : french (fr)
	// author : John Fischer : https://github.com/jfroffice

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('fr', {
	        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Aujourd\'hui à] LT',
	            nextDay: '[Demain à] LT',
	            nextWeek: 'dddd [à] LT',
	            lastDay: '[Hier à] LT',
	            lastWeek: 'dddd [dernier à] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dans %s',
	            past : 'il y a %s',
	            s : 'quelques secondes',
	            m : 'une minute',
	            mm : '%d minutes',
	            h : 'une heure',
	            hh : '%d heures',
	            d : 'un jour',
	            dd : '%d jours',
	            M : 'un mois',
	            MM : '%d mois',
	            y : 'un an',
	            yy : '%d ans'
	        },
	        ordinalParse: /\d{1,2}(er|)/,
	        ordinal : function (number) {
	            return number + (number === 1 ? 'er' : '');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : frisian (fy)
	// author : Robin van der Vliet : https://github.com/robin0van0der0v

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	    return moment.defineLocale('fy', {
	        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[hjoed om] LT',
	            nextDay: '[moarn om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[juster om] LT',
	            lastWeek: '[ôfrûne] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'oer %s',
	            past : '%s lyn',
	            s : 'in pear sekonden',
	            m : 'ien minút',
	            mm : '%d minuten',
	            h : 'ien oere',
	            hh : '%d oeren',
	            d : 'ien dei',
	            dd : '%d dagen',
	            M : 'ien moanne',
	            MM : '%d moannen',
	            y : 'ien jier',
	            yy : '%d jierren'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : galician (gl)
	// author : Juan G. Hurtado : https://github.com/juanghurtado

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('gl', {
	        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuño_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
	        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xuñ._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
	        weekdays : 'Domingo_Luns_Martes_Mércores_Xoves_Venres_Sábado'.split('_'),
	        weekdaysShort : 'Dom._Lun._Mar._Mér._Xov._Ven._Sáb.'.split('_'),
	        weekdaysMin : 'Do_Lu_Ma_Mé_Xo_Ve_Sá'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : function () {
	                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextDay : function () {
	                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	            },
	            nextWeek : function () {
	                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            lastDay : function () {
	                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	            },
	            lastWeek : function () {
	                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (str) {
	                if (str === 'uns segundos') {
	                    return 'nuns segundos';
	                }
	                return 'en ' + str;
	            },
	            past : 'hai %s',
	            s : 'uns segundos',
	            m : 'un minuto',
	            mm : '%d minutos',
	            h : 'unha hora',
	            hh : '%d horas',
	            d : 'un día',
	            dd : '%d días',
	            M : 'un mes',
	            MM : '%d meses',
	            y : 'un ano',
	            yy : '%d anos'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Hebrew (he)
	// author : Tomer Cohen : https://github.com/tomer
	// author : Moshe Simantov : https://github.com/DevelopmentIL
	// author : Tal Ater : https://github.com/TalAter

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('he', {
	        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [ב]MMMM YYYY',
	            LLL : 'D [ב]MMMM YYYY LT',
	            LLLL : 'dddd, D [ב]MMMM YYYY LT',
	            l : 'D/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY LT',
	            llll : 'ddd, D MMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[היום ב־]LT',
	            nextDay : '[מחר ב־]LT',
	            nextWeek : 'dddd [בשעה] LT',
	            lastDay : '[אתמול ב־]LT',
	            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'בעוד %s',
	            past : 'לפני %s',
	            s : 'מספר שניות',
	            m : 'דקה',
	            mm : '%d דקות',
	            h : 'שעה',
	            hh : function (number) {
	                if (number === 2) {
	                    return 'שעתיים';
	                }
	                return number + ' שעות';
	            },
	            d : 'יום',
	            dd : function (number) {
	                if (number === 2) {
	                    return 'יומיים';
	                }
	                return number + ' ימים';
	            },
	            M : 'חודש',
	            MM : function (number) {
	                if (number === 2) {
	                    return 'חודשיים';
	                }
	                return number + ' חודשים';
	            },
	            y : 'שנה',
	            yy : function (number) {
	                if (number === 2) {
	                    return 'שנתיים';
	                } else if (number % 10 === 0 && number !== 10) {
	                    return number + ' שנה';
	                }
	                return number + ' שנים';
	            }
	        }
	    });
	}));


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : hindi (hi)
	// author : Mayank Singhal : https://github.com/mayanksinghal

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };

	    return moment.defineLocale('hi', {
	        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm बजे',
	            LTS : 'A h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[कल] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[कल] LT',
	            lastWeek : '[पिछले] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s में',
	            past : '%s पहले',
	            s : 'कुछ ही क्षण',
	            m : 'एक मिनट',
	            mm : '%d मिनट',
	            h : 'एक घंटा',
	            hh : '%d घंटे',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महीने',
	            MM : '%d महीने',
	            y : 'एक वर्ष',
	            yy : '%d वर्ष'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	        meridiemParse: /रात|सुबह|दोपहर|शाम/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सुबह') {
	                return hour;
	            } else if (meridiem === 'दोपहर') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'शाम') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'रात';
	            } else if (hour < 10) {
	                return 'सुबह';
	            } else if (hour < 17) {
	                return 'दोपहर';
	            } else if (hour < 20) {
	                return 'शाम';
	            } else {
	                return 'रात';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : hrvatski (hr)
	// author : Bojan Marković : https://github.com/bmarkovic

	// based on (sl) translation by Robert Sedovšek

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	        }
	    }

	    return moment.defineLocale('hr', {
	        months : 'sječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
	        monthsShort : 'sje._vel._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[danas u] LT',
	            nextDay  : '[sutra u] LT',

	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[jučer u] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'prije %s',
	            s      : 'par sekundi',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'dan',
	            dd     : translate,
	            M      : 'mjesec',
	            MM     : translate,
	            y      : 'godinu',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : hungarian (hu)
	// author : Adam Brunner : https://github.com/adambrunner

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');

	    function translate(number, withoutSuffix, key, isFuture) {
	        var num = number,
	            suffix;

	        switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	        }

	        return '';
	    }

	    function week(isFuture) {
	        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	    }

	    return moment.defineLocale('hu', {
	        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY.MM.DD.',
	            LL : 'YYYY. MMMM D.',
	            LLL : 'YYYY. MMMM D., LT',
	            LLLL : 'YYYY. MMMM D., dddd LT'
	        },
	        meridiemParse: /de|du/i,
	        isPM: function (input) {
	            return input.charAt(1).toLowerCase() === 'u';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 12) {
	                return isLower === true ? 'de' : 'DE';
	            } else {
	                return isLower === true ? 'du' : 'DU';
	            }
	        },
	        calendar : {
	            sameDay : '[ma] LT[-kor]',
	            nextDay : '[holnap] LT[-kor]',
	            nextWeek : function () {
	                return week.call(this, true);
	            },
	            lastDay : '[tegnap] LT[-kor]',
	            lastWeek : function () {
	                return week.call(this, false);
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s múlva',
	            past : '%s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Armenian (hy-am)
	// author : Armendarabyan : https://github.com/armendarabyan

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_'),
	            'accusative': 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_')
	        },

	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';

	        return months[nounCase][m.month()];
	    }

	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_');

	        return monthsShort[m.month()];
	    }

	    function weekdaysCaseReplace(m, format) {
	        var weekdays = 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_');

	        return weekdays[m.day()];
	    }

	    return moment.defineLocale('hy-am', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY թ.',
	            LLL : 'D MMMM YYYY թ., LT',
	            LLLL : 'dddd, D MMMM YYYY թ., LT'
	        },
	        calendar : {
	            sameDay: '[այսօր] LT',
	            nextDay: '[վաղը] LT',
	            lastDay: '[երեկ] LT',
	            nextWeek: function () {
	                return 'dddd [օրը ժամը] LT';
	            },
	            lastWeek: function () {
	                return '[անցած] dddd [օրը ժամը] LT';
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s հետո',
	            past : '%s առաջ',
	            s : 'մի քանի վայրկյան',
	            m : 'րոպե',
	            mm : '%d րոպե',
	            h : 'ժամ',
	            hh : '%d ժամ',
	            d : 'օր',
	            dd : '%d օր',
	            M : 'ամիս',
	            MM : '%d ամիս',
	            y : 'տարի',
	            yy : '%d տարի'
	        },

	        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	        isPM: function (input) {
	            return /^(ցերեկվա|երեկոյան)$/.test(input);
	        },
	        meridiem : function (hour) {
	            if (hour < 4) {
	                return 'գիշերվա';
	            } else if (hour < 12) {
	                return 'առավոտվա';
	            } else if (hour < 17) {
	                return 'ցերեկվա';
	            } else {
	                return 'երեկոյան';
	            }
	        },

	        ordinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-ին';
	                }
	                return number + '-րդ';
	            default:
	                return number;
	            }
	        },

	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Bahasa Indonesia (id)
	// author : Mohammad Satrio Utomo : https://github.com/tyok
	// reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('id', {
	        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'LT.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] LT',
	            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
	        },
	        meridiemParse: /pagi|siang|sore|malam/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'siang') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'sore' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'siang';
	            } else if (hours < 19) {
	                return 'sore';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Besok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kemarin pukul] LT',
	            lastWeek : 'dddd [lalu pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lalu',
	            s : 'beberapa detik',
	            m : 'semenit',
	            mm : '%d menit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : icelandic (is)
	// author : Hinrik Örn Sigurðsson : https://github.com/hinrik

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(n) {
	        if (n % 100 === 11) {
	            return true;
	        } else if (n % 10 === 1) {
	            return false;
	        }
	        return true;
	    }

	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	        case 'm':
	            return withoutSuffix ? 'mínúta' : 'mínútu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	            } else if (withoutSuffix) {
	                return result + 'mínúta';
	            }
	            return result + 'mínútu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dögum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mánuður';
	            }
	            return isFuture ? 'mánuð' : 'mánuði';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mánuðir';
	                }
	                return result + (isFuture ? 'mánuði' : 'mánuðum');
	            } else if (withoutSuffix) {
	                return result + 'mánuður';
	            }
	            return result + (isFuture ? 'mánuð' : 'mánuði');
	        case 'y':
	            return withoutSuffix || isFuture ? 'ár' : 'ári';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	            }
	            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	        }
	    }

	    return moment.defineLocale('is', {
	        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] LT',
	            LLLL : 'dddd, D. MMMM YYYY [kl.] LT'
	        },
	        calendar : {
	            sameDay : '[í dag kl.] LT',
	            nextDay : '[á morgun kl.] LT',
	            nextWeek : 'dddd [kl.] LT',
	            lastDay : '[í gær kl.] LT',
	            lastWeek : '[síðasta] dddd [kl.] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'eftir %s',
	            past : 'fyrir %s síðan',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : 'klukkustund',
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : italian (it)
	// author : Lorenzo : https://github.com/aliem
	// author: Mattia Larentis: https://github.com/nostalgiaz

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('it', {
	        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	        weekdays : 'Domenica_Lunedì_Martedì_Mercoledì_Giovedì_Venerdì_Sabato'.split('_'),
	        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Oggi alle] LT',
	            nextDay: '[Domani alle] LT',
	            nextWeek: 'dddd [alle] LT',
	            lastDay: '[Ieri alle] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                    case 0:
	                        return '[la scorsa] dddd [alle] LT';
	                    default:
	                        return '[lo scorso] dddd [alle] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	            },
	            past : '%s fa',
	            s : 'alcuni secondi',
	            m : 'un minuto',
	            mm : '%d minuti',
	            h : 'un\'ora',
	            hh : '%d ore',
	            d : 'un giorno',
	            dd : '%d giorni',
	            M : 'un mese',
	            MM : '%d mesi',
	            y : 'un anno',
	            yy : '%d anni'
	        },
	        ordinalParse : /\d{1,2}º/,
	        ordinal: '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : japanese (ja)
	// author : LI Long : https://github.com/baryon

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ja', {
	        months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	        longDateFormat : {
	            LT : 'Ah時m分',
	            LTS : 'LTs秒',
	            L : 'YYYY/MM/DD',
	            LL : 'YYYY年M月D日',
	            LLL : 'YYYY年M月D日LT',
	            LLLL : 'YYYY年M月D日LT dddd'
	        },
	        meridiemParse: /午前|午後/i,
	        isPM : function (input) {
	            return input === '午後';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return '午前';
	            } else {
	                return '午後';
	            }
	        },
	        calendar : {
	            sameDay : '[今日] LT',
	            nextDay : '[明日] LT',
	            nextWeek : '[来週]dddd LT',
	            lastDay : '[昨日] LT',
	            lastWeek : '[前週]dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s後',
	            past : '%s前',
	            s : '数秒',
	            m : '1分',
	            mm : '%d分',
	            h : '1時間',
	            hh : '%d時間',
	            d : '1日',
	            dd : '%d日',
	            M : '1ヶ月',
	            MM : '%dヶ月',
	            y : '1年',
	            yy : '%d年'
	        }
	    });
	}));


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Georgian (ka)
	// author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	            'accusative': 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	        },

	        nounCase = (/D[oD] *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';

	        return months[nounCase][m.month()];
	    }

	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	            'accusative': 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_')
	        },

	        nounCase = (/(წინა|შემდეგ)/).test(format) ?
	            'accusative' :
	            'nominative';

	        return weekdays[nounCase][m.day()];
	    }

	    return moment.defineLocale('ka', {
	        months : monthsCaseReplace,
	        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	        longDateFormat : {
	            LT : 'h:mm A',
	            LTS : 'h:mm:ss A',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[დღეს] LT[-ზე]',
	            nextDay : '[ხვალ] LT[-ზე]',
	            lastDay : '[გუშინ] LT[-ზე]',
	            nextWeek : '[შემდეგ] dddd LT[-ზე]',
	            lastWeek : '[წინა] dddd LT-ზე',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : function (s) {
	                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                    s.replace(/ი$/, 'ში') :
	                    s + 'ში';
	            },
	            past : function (s) {
	                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                    return s.replace(/(ი|ე)$/, 'ის წინ');
	                }
	                if ((/წელი/).test(s)) {
	                    return s.replace(/წელი$/, 'წლის წინ');
	                }
	            },
	            s : 'რამდენიმე წამი',
	            m : 'წუთი',
	            mm : '%d წუთი',
	            h : 'საათი',
	            hh : '%d საათი',
	            d : 'დღე',
	            dd : '%d დღე',
	            M : 'თვე',
	            MM : '%d თვე',
	            y : 'წელი',
	            yy : '%d წელი'
	        },
	        ordinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	        ordinal : function (number) {
	            if (number === 0) {
	                return number;
	            }

	            if (number === 1) {
	                return number + '-ლი';
	            }

	            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	                return 'მე-' + number;
	            }

	            return number + '-ე';
	        },
	        week : {
	            dow : 1,
	            doy : 7
	        }
	    });
	}));


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : khmer (km)
	// author : Kruy Vanna : https://github.com/kruyvanna

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('km', {
	        months: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        monthsShort: 'មករា_កុម្ភៈ_មិនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS : 'LT:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd, D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[ថ្ងៃនៈ ម៉ោង] LT',
	            nextDay: '[ស្អែក ម៉ោង] LT',
	            nextWeek: 'dddd [ម៉ោង] LT',
	            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: '%sទៀត',
	            past: '%sមុន',
	            s: 'ប៉ុន្មានវិនាទី',
	            m: 'មួយនាទី',
	            mm: '%d នាទី',
	            h: 'មួយម៉ោង',
	            hh: '%d ម៉ោង',
	            d: 'មួយថ្ងៃ',
	            dd: '%d ថ្ងៃ',
	            M: 'មួយខែ',
	            MM: '%d ខែ',
	            y: 'មួយឆ្នាំ',
	            yy: '%d ឆ្នាំ'
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : korean (ko)
	//
	// authors
	//
	// - Kyungwook, Park : https://github.com/kyungw00k
	// - Jeeeyul Lee <jeeeyul@gmail.com>
	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ko', {
	        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	        longDateFormat : {
	            LT : 'A h시 m분',
	            LTS : 'A h시 m분 s초',
	            L : 'YYYY.MM.DD',
	            LL : 'YYYY년 MMMM D일',
	            LLL : 'YYYY년 MMMM D일 LT',
	            LLLL : 'YYYY년 MMMM D일 dddd LT'
	        },
	        calendar : {
	            sameDay : '오늘 LT',
	            nextDay : '내일 LT',
	            nextWeek : 'dddd LT',
	            lastDay : '어제 LT',
	            lastWeek : '지난주 dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s 후',
	            past : '%s 전',
	            s : '몇초',
	            ss : '%d초',
	            m : '일분',
	            mm : '%d분',
	            h : '한시간',
	            hh : '%d시간',
	            d : '하루',
	            dd : '%d일',
	            M : '한달',
	            MM : '%d달',
	            y : '일년',
	            yy : '%d년'
	        },
	        ordinalParse : /\d{1,2}일/,
	        ordinal : '%d일',
	        meridiemParse : /오전|오후/,
	        isPM : function (token) {
	            return token === '오후';
	        },
	        meridiem : function (hour, minute, isUpper) {
	            return hour < 12 ? '오전' : '오후';
	        }
	    });
	}));


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Luxembourgish (lb)
	// author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

	// Note: Luxembourgish has a very particular phonological rule ('Eifeler Regel') that causes the
	// deletion of the final 'n' in certain contexts. That's what the 'eifelerRegelAppliesToWeekday'
	// and 'eifelerRegelAppliesToNumber' methods are meant for

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function processRelativeTime(number, withoutSuffix, key, isFuture) {
	        var format = {
	            'm': ['eng Minutt', 'enger Minutt'],
	            'h': ['eng Stonn', 'enger Stonn'],
	            'd': ['een Dag', 'engem Dag'],
	            'M': ['ee Mount', 'engem Mount'],
	            'y': ['ee Joer', 'engem Joer']
	        };
	        return withoutSuffix ? format[key][0] : format[key][1];
	    }

	    function processFutureTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'a ' + string;
	        }
	        return 'an ' + string;
	    }

	    function processPastTime(string) {
	        var number = string.substr(0, string.indexOf(' '));
	        if (eifelerRegelAppliesToNumber(number)) {
	            return 'viru ' + string;
	        }
	        return 'virun ' + string;
	    }

	    /**
	     * Returns true if the word before the given number loses the '-n' ending.
	     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	     *
	     * @param number {integer}
	     * @returns {boolean}
	     */
	    function eifelerRegelAppliesToNumber(number) {
	        number = parseInt(number, 10);
	        if (isNaN(number)) {
	            return false;
	        }
	        if (number < 0) {
	            // Negative Number --> always true
	            return true;
	        } else if (number < 10) {
	            // Only 1 digit
	            if (4 <= number && number <= 7) {
	                return true;
	            }
	            return false;
	        } else if (number < 100) {
	            // 2 digits
	            var lastDigit = number % 10, firstDigit = number / 10;
	            if (lastDigit === 0) {
	                return eifelerRegelAppliesToNumber(firstDigit);
	            }
	            return eifelerRegelAppliesToNumber(lastDigit);
	        } else if (number < 10000) {
	            // 3 or 4 digits --> recursively check first digit
	            while (number >= 10) {
	                number = number / 10;
	            }
	            return eifelerRegelAppliesToNumber(number);
	        } else {
	            // Anything larger than 4 digits: recursively check first n-3 digits
	            number = number / 1000;
	            return eifelerRegelAppliesToNumber(number);
	        }
	    }

	    return moment.defineLocale('lb', {
	        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	        longDateFormat: {
	            LT: 'H:mm [Auer]',
	            LTS: 'H:mm:ss [Auer]',
	            L: 'DD.MM.YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY LT',
	            LLLL: 'dddd, D. MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[Haut um] LT',
	            sameElse: 'L',
	            nextDay: '[Muer um] LT',
	            nextWeek: 'dddd [um] LT',
	            lastDay: '[Gëschter um] LT',
	            lastWeek: function () {
	                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	                switch (this.day()) {
	                    case 2:
	                    case 4:
	                        return '[Leschten] dddd [um] LT';
	                    default:
	                        return '[Leschte] dddd [um] LT';
	                }
	            }
	        },
	        relativeTime : {
	            future : processFutureTime,
	            past : processPastTime,
	            s : 'e puer Sekonnen',
	            m : processRelativeTime,
	            mm : '%d Minutten',
	            h : processRelativeTime,
	            hh : '%d Stonnen',
	            d : processRelativeTime,
	            dd : '%d Deeg',
	            M : processRelativeTime,
	            MM : '%d Méint',
	            y : processRelativeTime,
	            yy : '%d Joer'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal: '%d.',
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Lithuanian (lt)
	// author : Mindaugas Mozūras : https://github.com/mmozuras

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var units = {
	        'm' : 'minutė_minutės_minutę',
	        'mm': 'minutės_minučių_minutes',
	        'h' : 'valanda_valandos_valandą',
	        'hh': 'valandos_valandų_valandas',
	        'd' : 'diena_dienos_dieną',
	        'dd': 'dienos_dienų_dienas',
	        'M' : 'mėnuo_mėnesio_mėnesį',
	        'MM': 'mėnesiai_mėnesių_mėnesius',
	        'y' : 'metai_metų_metus',
	        'yy': 'metai_metų_metus'
	    },
	    weekDays = 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_');

	    function translateSeconds(number, withoutSuffix, key, isFuture) {
	        if (withoutSuffix) {
	            return 'kelios sekundės';
	        } else {
	            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	        }
	    }

	    function translateSingular(number, withoutSuffix, key, isFuture) {
	        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	    }

	    function special(number) {
	        return number % 10 === 0 || (number > 10 && number < 20);
	    }

	    function forms(key) {
	        return units[key].split('_');
	    }

	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        if (number === 1) {
	            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	        } else if (withoutSuffix) {
	            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	        } else {
	            if (isFuture) {
	                return result + forms(key)[1];
	            } else {
	                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	            }
	        }
	    }

	    function relativeWeekDay(moment, format) {
	        var nominative = format.indexOf('dddd HH:mm') === -1,
	            weekDay = weekDays[moment.day()];

	        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + 'į';
	    }

	    return moment.defineLocale('lt', {
	        months : 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
	        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	        weekdays : relativeWeekDay,
	        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY [m.] MMMM D [d.]',
	            LLL : 'YYYY [m.] MMMM D [d.], LT [val.]',
	            LLLL : 'YYYY [m.] MMMM D [d.], dddd, LT [val.]',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY [m.] MMMM D [d.]',
	            lll : 'YYYY [m.] MMMM D [d.], LT [val.]',
	            llll : 'YYYY [m.] MMMM D [d.], ddd, LT [val.]'
	        },
	        calendar : {
	            sameDay : '[Šiandien] LT',
	            nextDay : '[Rytoj] LT',
	            nextWeek : 'dddd LT',
	            lastDay : '[Vakar] LT',
	            lastWeek : '[Praėjusį] dddd LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'po %s',
	            past : 'prieš %s',
	            s : translateSeconds,
	            m : translateSingular,
	            mm : translate,
	            h : translateSingular,
	            hh : translate,
	            d : translateSingular,
	            dd : translate,
	            M : translateSingular,
	            MM : translate,
	            y : translateSingular,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}-oji/,
	        ordinal : function (number) {
	            return number + '-oji';
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : latvian (lv)
	// author : Kristaps Karlsons : https://github.com/skakri

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var units = {
	        'mm': 'minūti_minūtes_minūte_minūtes',
	        'hh': 'stundu_stundas_stunda_stundas',
	        'dd': 'dienu_dienas_diena_dienas',
	        'MM': 'mēnesi_mēnešus_mēnesis_mēneši',
	        'yy': 'gadu_gadus_gads_gadi'
	    };

	    function format(word, number, withoutSuffix) {
	        var forms = word.split('_');
	        if (withoutSuffix) {
	            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
	        } else {
	            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
	        }
	    }

	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        return number + ' ' + format(units[key], number, withoutSuffix);
	    }

	    return moment.defineLocale('lv', {
	        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'YYYY. [gada] D. MMMM',
	            LLL : 'YYYY. [gada] D. MMMM, LT',
	            LLLL : 'YYYY. [gada] D. MMMM, dddd, LT'
	        },
	        calendar : {
	            sameDay : '[Šodien pulksten] LT',
	            nextDay : '[Rīt pulksten] LT',
	            nextWeek : 'dddd [pulksten] LT',
	            lastDay : '[Vakar pulksten] LT',
	            lastWeek : '[Pagājušā] dddd [pulksten] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s vēlāk',
	            past : '%s agrāk',
	            s : 'dažas sekundes',
	            m : 'minūti',
	            mm : relativeTimeWithPlural,
	            h : 'stundu',
	            hh : relativeTimeWithPlural,
	            d : 'dienu',
	            dd : relativeTimeWithPlural,
	            M : 'mēnesi',
	            MM : relativeTimeWithPlural,
	            y : 'gadu',
	            yy : relativeTimeWithPlural
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : macedonian (mk)
	// author : Borislav Mickov : https://github.com/B0k0

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('mk', {
	        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'D.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Денес во] LT',
	            nextDay : '[Утре во] LT',
	            nextWeek : 'dddd [во] LT',
	            lastDay : '[Вчера во] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[Во изминатата] dddd [во] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[Во изминатиот] dddd [во] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'после %s',
	            past : 'пред %s',
	            s : 'неколку секунди',
	            m : 'минута',
	            mm : '%d минути',
	            h : 'час',
	            hh : '%d часа',
	            d : 'ден',
	            dd : '%d дена',
	            M : 'месец',
	            MM : '%d месеци',
	            y : 'година',
	            yy : '%d години'
	        },
	        ordinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	        ordinal : function (number) {
	            var lastDigit = number % 10,
	                last2Digits = number % 100;
	            if (number === 0) {
	                return number + '-ев';
	            } else if (last2Digits === 0) {
	                return number + '-ен';
	            } else if (last2Digits > 10 && last2Digits < 20) {
	                return number + '-ти';
	            } else if (lastDigit === 1) {
	                return number + '-ви';
	            } else if (lastDigit === 2) {
	                return number + '-ри';
	            } else if (lastDigit === 7 || lastDigit === 8) {
	                return number + '-ми';
	            } else {
	                return number + '-ти';
	            }
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : malayalam (ml)
	// author : Floyd Pink : https://github.com/floydpink

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ml', {
	        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm -നു',
	            LTS : 'A h:mm:ss -നു',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[ഇന്ന്] LT',
	            nextDay : '[നാളെ] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[ഇന്നലെ] LT',
	            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s കഴിഞ്ഞ്',
	            past : '%s മുൻപ്',
	            s : 'അൽപ നിമിഷങ്ങൾ',
	            m : 'ഒരു മിനിറ്റ്',
	            mm : '%d മിനിറ്റ്',
	            h : 'ഒരു മണിക്കൂർ',
	            hh : '%d മണിക്കൂർ',
	            d : 'ഒരു ദിവസം',
	            dd : '%d ദിവസം',
	            M : 'ഒരു മാസം',
	            MM : '%d മാസം',
	            y : 'ഒരു വർഷം',
	            yy : '%d വർഷം'
	        },
	        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	        isPM : function (input) {
	            return /^(ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'രാത്രി';
	            } else if (hour < 12) {
	                return 'രാവിലെ';
	            } else if (hour < 17) {
	                return 'ഉച്ച കഴിഞ്ഞ്';
	            } else if (hour < 20) {
	                return 'വൈകുന്നേരം';
	            } else {
	                return 'രാത്രി';
	            }
	        }
	    });
	}));


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Marathi (mr)
	// author : Harshad Kale : https://github.com/kalehv

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };

	    return moment.defineLocale('mr', {
	        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	        longDateFormat : {
	            LT : 'A h:mm वाजता',
	            LTS : 'A h:mm:ss वाजता',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[उद्या] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[काल] LT',
	            lastWeek: '[मागील] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s नंतर',
	            past : '%s पूर्वी',
	            s : 'सेकंद',
	            m: 'एक मिनिट',
	            mm: '%d मिनिटे',
	            h : 'एक तास',
	            hh : '%d तास',
	            d : 'एक दिवस',
	            dd : '%d दिवस',
	            M : 'एक महिना',
	            MM : '%d महिने',
	            y : 'एक वर्ष',
	            yy : '%d वर्षे'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'रात्री') {
	                return hour < 4 ? hour : hour + 12;
	            } else if (meridiem === 'सकाळी') {
	                return hour;
	            } else if (meridiem === 'दुपारी') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'सायंकाळी') {
	                return hour + 12;
	            }
	        },
	        meridiem: function (hour, minute, isLower)
	        {
	            if (hour < 4) {
	                return 'रात्री';
	            } else if (hour < 10) {
	                return 'सकाळी';
	            } else if (hour < 17) {
	                return 'दुपारी';
	            } else if (hour < 20) {
	                return 'सायंकाळी';
	            } else {
	                return 'रात्री';
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Bahasa Malaysia (ms-MY)
	// author : Weldan Jamili : https://github.com/weldan

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('ms-my', {
	        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	        longDateFormat : {
	            LT : 'HH.mm',
	            LTS : 'LT.ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY [pukul] LT',
	            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
	        },
	        meridiemParse: /pagi|tengahari|petang|malam/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'pagi') {
	                return hour;
	            } else if (meridiem === 'tengahari') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === 'petang' || meridiem === 'malam') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hours, minutes, isLower) {
	            if (hours < 11) {
	                return 'pagi';
	            } else if (hours < 15) {
	                return 'tengahari';
	            } else if (hours < 19) {
	                return 'petang';
	            } else {
	                return 'malam';
	            }
	        },
	        calendar : {
	            sameDay : '[Hari ini pukul] LT',
	            nextDay : '[Esok pukul] LT',
	            nextWeek : 'dddd [pukul] LT',
	            lastDay : '[Kelmarin pukul] LT',
	            lastWeek : 'dddd [lepas pukul] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'dalam %s',
	            past : '%s yang lepas',
	            s : 'beberapa saat',
	            m : 'seminit',
	            mm : '%d minit',
	            h : 'sejam',
	            hh : '%d jam',
	            d : 'sehari',
	            dd : '%d hari',
	            M : 'sebulan',
	            MM : '%d bulan',
	            y : 'setahun',
	            yy : '%d tahun'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Burmese (my)
	// author : Squar team, mysquar.com

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '၁',
	        '2': '၂',
	        '3': '၃',
	        '4': '၄',
	        '5': '၅',
	        '6': '၆',
	        '7': '၇',
	        '8': '၈',
	        '9': '၉',
	        '0': '၀'
	    }, numberMap = {
	        '၁': '1',
	        '၂': '2',
	        '၃': '3',
	        '၄': '4',
	        '၅': '5',
	        '၆': '6',
	        '၇': '7',
	        '၈': '8',
	        '၉': '9',
	        '၀': '0'
	    };
	    return moment.defineLocale('my', {
	        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	        weekdaysShort: 'နွေ_လာ_င်္ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	        weekdaysMin: 'နွေ_လာ_င်္ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	        longDateFormat: {
	            LT: 'HH:mm',
	            LTS: 'HH:mm:ss',
	            L: 'DD/MM/YYYY',
	            LL: 'D MMMM YYYY',
	            LLL: 'D MMMM YYYY LT',
	            LLLL: 'dddd D MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[ယနေ.] LT [မှာ]',
	            nextDay: '[မနက်ဖြန်] LT [မှာ]',
	            nextWeek: 'dddd LT [မှာ]',
	            lastDay: '[မနေ.က] LT [မှာ]',
	            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	            sameElse: 'L'
	        },
	        relativeTime: {
	            future: 'လာမည့် %s မှာ',
	            past: 'လွန်ခဲ့သော %s က',
	            s: 'စက္ကန်.အနည်းငယ်',
	            m: 'တစ်မိနစ်',
	            mm: '%d မိနစ်',
	            h: 'တစ်နာရီ',
	            hh: '%d နာရီ',
	            d: 'တစ်ရက်',
	            dd: '%d ရက်',
	            M: 'တစ်လ',
	            MM: '%d လ',
	            y: 'တစ်နှစ်',
	            yy: '%d နှစ်'
	        },
	        preparse: function (string) {
	            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        week: {
	            dow: 1, // Monday is the first day of the week.
	            doy: 4 // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : norwegian bokmål (nb)
	// authors : Espen Hovlandsdal : https://github.com/rexxars
	//           Sigurd Gartmann : https://github.com/sigurdga

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('nb', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	        weekdaysShort : 'søn_man_tirs_ons_tors_fre_lør'.split('_'),
	        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'H.mm',
	            LTS : 'LT.ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY [kl.] LT',
	            LLLL : 'dddd D. MMMM YYYY [kl.] LT'
	        },
	        calendar : {
	            sameDay: '[i dag kl.] LT',
	            nextDay: '[i morgen kl.] LT',
	            nextWeek: 'dddd [kl.] LT',
	            lastDay: '[i går kl.] LT',
	            lastWeek: '[forrige] dddd [kl.] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s siden',
	            s : 'noen sekunder',
	            m : 'ett minutt',
	            mm : '%d minutter',
	            h : 'en time',
	            hh : '%d timer',
	            d : 'en dag',
	            dd : '%d dager',
	            M : 'en måned',
	            MM : '%d måneder',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : nepali/nepalese
	// author : suvash : https://github.com/suvash

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var symbolMap = {
	        '1': '१',
	        '2': '२',
	        '3': '३',
	        '4': '४',
	        '5': '५',
	        '6': '६',
	        '7': '७',
	        '8': '८',
	        '9': '९',
	        '0': '०'
	    },
	    numberMap = {
	        '१': '1',
	        '२': '2',
	        '३': '3',
	        '४': '4',
	        '५': '5',
	        '६': '6',
	        '७': '7',
	        '८': '8',
	        '९': '9',
	        '०': '0'
	    };

	    return moment.defineLocale('ne', {
	        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	        weekdaysMin : 'आइ._सो._मङ्_बु._बि._शु._श.'.split('_'),
	        longDateFormat : {
	            LT : 'Aको h:mm बजे',
	            LTS : 'Aको h:mm:ss बजे',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        preparse: function (string) {
	            return string.replace(/[१२३४५६७८९०]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },
	        meridiemParse: /राती|बिहान|दिउँसो|बेलुका|साँझ|राती/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'राती') {
	                return hour < 3 ? hour : hour + 12;
	            } else if (meridiem === 'बिहान') {
	                return hour;
	            } else if (meridiem === 'दिउँसो') {
	                return hour >= 10 ? hour : hour + 12;
	            } else if (meridiem === 'बेलुका' || meridiem === 'साँझ') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 3) {
	                return 'राती';
	            } else if (hour < 10) {
	                return 'बिहान';
	            } else if (hour < 15) {
	                return 'दिउँसो';
	            } else if (hour < 18) {
	                return 'बेलुका';
	            } else if (hour < 20) {
	                return 'साँझ';
	            } else {
	                return 'राती';
	            }
	        },
	        calendar : {
	            sameDay : '[आज] LT',
	            nextDay : '[भोली] LT',
	            nextWeek : '[आउँदो] dddd[,] LT',
	            lastDay : '[हिजो] LT',
	            lastWeek : '[गएको] dddd[,] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%sमा',
	            past : '%s अगाडी',
	            s : 'केही समय',
	            m : 'एक मिनेट',
	            mm : '%d मिनेट',
	            h : 'एक घण्टा',
	            hh : '%d घण्टा',
	            d : 'एक दिन',
	            dd : '%d दिन',
	            M : 'एक महिना',
	            MM : '%d महिना',
	            y : 'एक बर्ष',
	            yy : '%d बर्ष'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : dutch (nl)
	// author : Joris Röling : https://github.com/jjupiter

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	    return moment.defineLocale('nl', {
	        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	        monthsShort : function (m, format) {
	            if (/-MMM-/.test(format)) {
	                return monthsShortWithoutDots[m.month()];
	            } else {
	                return monthsShortWithDots[m.month()];
	            }
	        },
	        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD-MM-YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[vandaag om] LT',
	            nextDay: '[morgen om] LT',
	            nextWeek: 'dddd [om] LT',
	            lastDay: '[gisteren om] LT',
	            lastWeek: '[afgelopen] dddd [om] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'over %s',
	            past : '%s geleden',
	            s : 'een paar seconden',
	            m : 'één minuut',
	            mm : '%d minuten',
	            h : 'één uur',
	            hh : '%d uur',
	            d : 'één dag',
	            dd : '%d dagen',
	            M : 'één maand',
	            MM : '%d maanden',
	            y : 'één jaar',
	            yy : '%d jaar'
	        },
	        ordinalParse: /\d{1,2}(ste|de)/,
	        ordinal : function (number) {
	            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : norwegian nynorsk (nn)
	// author : https://github.com/mechuwind

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('nn', {
	        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[I dag klokka] LT',
	            nextDay: '[I morgon klokka] LT',
	            nextWeek: 'dddd [klokka] LT',
	            lastDay: '[I går klokka] LT',
	            lastWeek: '[Føregåande] dddd [klokka] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'for %s sidan',
	            s : 'nokre sekund',
	            m : 'eit minutt',
	            mm : '%d minutt',
	            h : 'ein time',
	            hh : '%d timar',
	            d : 'ein dag',
	            dd : '%d dagar',
	            M : 'ein månad',
	            MM : '%d månader',
	            y : 'eit år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : polish (pl)
	// author : Rafal Hirsz : https://github.com/evoL

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
	        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');

	    function plural(n) {
	        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	    }

	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minutę';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzinę';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesiące' : 'miesięcy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	        }
	    }

	    return moment.defineLocale('pl', {
	        months : function (momentToFormat, format) {
	            if (/D MMMM/.test(format)) {
	                return monthsSubjective[momentToFormat.month()];
	            } else {
	                return monthsNominative[momentToFormat.month()];
	            }
	        },
	        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	        weekdaysShort : 'nie_pon_wt_śr_czw_pt_sb'.split('_'),
	        weekdaysMin : 'N_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Dziś o] LT',
	            nextDay: '[Jutro o] LT',
	            nextWeek: '[W] dddd [o] LT',
	            lastDay: '[Wczoraj o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[W zeszłą niedzielę o] LT';
	                case 3:
	                    return '[W zeszłą środę o] LT';
	                case 6:
	                    return '[W zeszłą sobotę o] LT';
	                default:
	                    return '[W zeszły] dddd [o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : '%s temu',
	            s : 'kilka sekund',
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : '1 dzień',
	            dd : '%d dni',
	            M : 'miesiąc',
	            MM : translate,
	            y : 'rok',
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : brazilian portuguese (pt-br)
	// author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('pt-br', {
	        months : 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
	        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
	        weekdays : 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split('_'),
	        weekdaysShort : 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
	        weekdaysMin : 'dom_2ª_3ª_4ª_5ª_6ª_sáb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY [às] LT',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] LT'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : '%s atrás',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº'
	    });
	}));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : portuguese (pt)
	// author : Jefferson : https://github.com/jalex79

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('pt', {
	        months : 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
	        monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
	        weekdays : 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split('_'),
	        weekdaysShort : 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
	        weekdaysMin : 'dom_2ª_3ª_4ª_5ª_6ª_sáb'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D [de] MMMM [de] YYYY',
	            LLL : 'D [de] MMMM [de] YYYY LT',
	            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Hoje às] LT',
	            nextDay: '[Amanhã às] LT',
	            nextWeek: 'dddd [às] LT',
	            lastDay: '[Ontem às] LT',
	            lastWeek: function () {
	                return (this.day() === 0 || this.day() === 6) ?
	                    '[Último] dddd [às] LT' : // Saturday + Sunday
	                    '[Última] dddd [às] LT'; // Monday - Friday
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'em %s',
	            past : 'há %s',
	            s : 'segundos',
	            m : 'um minuto',
	            mm : '%d minutos',
	            h : 'uma hora',
	            hh : '%d horas',
	            d : 'um dia',
	            dd : '%d dias',
	            M : 'um mês',
	            MM : '%d meses',
	            y : 'um ano',
	            yy : '%d anos'
	        },
	        ordinalParse: /\d{1,2}º/,
	        ordinal : '%dº',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : romanian (ro)
	// author : Vlad Gurdiga : https://github.com/gurdiga
	// author : Valentin Agachi : https://github.com/avaly

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	                'mm': 'minute',
	                'hh': 'ore',
	                'dd': 'zile',
	                'MM': 'luni',
	                'yy': 'ani'
	            },
	            separator = ' ';
	        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	            separator = ' de ';
	        }

	        return number + separator + format[key];
	    }

	    return moment.defineLocale('ro', {
	        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY H:mm',
	            LLLL : 'dddd, D MMMM YYYY H:mm'
	        },
	        calendar : {
	            sameDay: '[azi la] LT',
	            nextDay: '[mâine la] LT',
	            nextWeek: 'dddd [la] LT',
	            lastDay: '[ieri la] LT',
	            lastWeek: '[fosta] dddd [la] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'peste %s',
	            past : '%s în urmă',
	            s : 'câteva secunde',
	            m : 'un minut',
	            mm : relativeTimeWithPlural,
	            h : 'o oră',
	            hh : relativeTimeWithPlural,
	            d : 'o zi',
	            dd : relativeTimeWithPlural,
	            M : 'o lună',
	            MM : relativeTimeWithPlural,
	            y : 'un an',
	            yy : relativeTimeWithPlural
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : russian (ru)
	// author : Viktorminator : https://github.com/Viktorminator
	// Author : Menelion Elensúle : https://github.com/Oire

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }

	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	            'hh': 'час_часа_часов',
	            'dd': 'день_дня_дней',
	            'MM': 'месяц_месяца_месяцев',
	            'yy': 'год_года_лет'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'минута' : 'минуту';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }

	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	            'accusative': 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_')
	        },

	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';

	        return months[nounCase][m.month()];
	    }

	    function monthsShortCaseReplace(m, format) {
	        var monthsShort = {
	            'nominative': 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
	            'accusative': 'янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек'.split('_')
	        },

	        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';

	        return monthsShort[nounCase][m.month()];
	    }

	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
	            'accusative': 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_')
	        },

	        nounCase = (/\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/).test(format) ?
	            'accusative' :
	            'nominative';

	        return weekdays[nounCase][m.day()];
	    }

	    return moment.defineLocale('ru', {
	        months : monthsCaseReplace,
	        monthsShort : monthsShortCaseReplace,
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	        monthsParse : [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i],
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY г.',
	            LLL : 'D MMMM YYYY г., LT',
	            LLLL : 'dddd, D MMMM YYYY г., LT'
	        },
	        calendar : {
	            sameDay: '[Сегодня в] LT',
	            nextDay: '[Завтра в] LT',
	            lastDay: '[Вчера в] LT',
	            nextWeek: function () {
	                return this.day() === 2 ? '[Во] dddd [в] LT' : '[В] dddd [в] LT';
	            },
	            lastWeek: function (now) {
	                if (now.week() !== this.week()) {
	                    switch (this.day()) {
	                    case 0:
	                        return '[В прошлое] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В прошлый] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В прошлую] dddd [в] LT';
	                    }
	                } else {
	                    if (this.day() === 2) {
	                        return '[Во] dddd [в] LT';
	                    } else {
	                        return '[В] dddd [в] LT';
	                    }
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'через %s',
	            past : '%s назад',
	            s : 'несколько секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'час',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'месяц',
	            MM : relativeTimeWithPlural,
	            y : 'год',
	            yy : relativeTimeWithPlural
	        },

	        meridiemParse: /ночи|утра|дня|вечера/i,
	        isPM : function (input) {
	            return /^(дня|вечера)$/.test(input);
	        },

	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночи';
	            } else if (hour < 12) {
	                return 'утра';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечера';
	            }
	        },

	        ordinalParse: /\d{1,2}-(й|го|я)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            case 'w':
	            case 'W':
	                return number + '-я';
	            default:
	                return number;
	            }
	        },

	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : slovak (sk)
	// author : Martin Minka : https://github.com/k2s
	// based on work of petrbela : https://github.com/petrbela

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
	        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');

	    function plural(n) {
	        return (n > 1) && (n < 5);
	    }

	    function translate(number, withoutSuffix, key, isFuture) {
	        var result = number + ' ';
	        switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minúty' : 'minút');
	            } else {
	                return result + 'minútami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodín');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dní');
	            } else {
	                return result + 'dňami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	        }
	    }

	    return moment.defineLocale('sk', {
	        months : months,
	        monthsShort : monthsShort,
	        monthsParse : (function (months, monthsShort) {
	            var i, _monthsParse = [];
	            for (i = 0; i < 12; i++) {
	                // use custom parser to solve problem with July (červenec)
	                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	            }
	            return _monthsParse;
	        }(months, monthsShort)),
	        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	        longDateFormat : {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[dnes o] LT',
	            nextDay: '[zajtra o] LT',
	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo štvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	                }
	            },
	            lastDay: '[včera o] LT',
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[minulú nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[minulý] dddd [o] LT';
	                case 3:
	                    return '[minulú stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [o] LT';
	                case 6:
	                    return '[minulú sobotu o] LT';
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past : 'pred %s',
	            s : translate,
	            m : translate,
	            mm : translate,
	            h : translate,
	            hh : translate,
	            d : translate,
	            dd : translate,
	            M : translate,
	            MM : translate,
	            y : translate,
	            yy : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : slovenian (sl)
	// author : Robert Sedovšek : https://github.com/sedovsek

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function translate(number, withoutSuffix, key) {
	        var result = number + ' ';
	        switch (key) {
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2) {
	                result += 'minuti';
	            } else if (number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minut';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += 'ura';
	            } else if (number === 2) {
	                result += 'uri';
	            } else if (number === 3 || number === 4) {
	                result += 'ure';
	            } else {
	                result += 'ur';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dni';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mesec';
	            } else if (number === 2) {
	                result += 'meseca';
	            } else if (number === 3 || number === 4) {
	                result += 'mesece';
	            } else {
	                result += 'mesecev';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'leto';
	            } else if (number === 2) {
	                result += 'leti';
	            } else if (number === 3 || number === 4) {
	                result += 'leta';
	            } else {
	                result += 'let';
	            }
	            return result;
	        }
	    }

	    return moment.defineLocale('sl', {
	        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	        longDateFormat : {
	            LT : 'H:mm',
	            LTS : 'LT:ss',
	            L : 'DD. MM. YYYY',
	            LL : 'D. MMMM YYYY',
	            LLL : 'D. MMMM YYYY LT',
	            LLLL : 'dddd, D. MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay  : '[danes ob] LT',
	            nextDay  : '[jutri ob] LT',

	            nextWeek : function () {
	                switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	                }
	            },
	            lastDay  : '[včeraj ob] LT',
	            lastWeek : function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[prejšnja] dddd [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejšnji] dddd [ob] LT';
	                }
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'čez %s',
	            past   : '%s nazaj',
	            s      : 'nekaj sekund',
	            m      : translate,
	            mm     : translate,
	            h      : translate,
	            hh     : translate,
	            d      : 'en dan',
	            dd     : translate,
	            M      : 'en mesec',
	            MM     : translate,
	            y      : 'eno leto',
	            yy     : translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Albanian (sq)
	// author : Flakërim Ismani : https://github.com/flakerimi
	// author: Menelion Elensúle: https://github.com/Oire (tests)
	// author : Oerd Cukalla : https://github.com/oerd (fixes)

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('sq', {
	        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	        meridiemParse: /PD|MD/,
	        isPM: function (input) {
	            return input.charAt(0) === 'M';
	        },
	        meridiem : function (hours, minutes, isLower) {
	            return hours < 12 ? 'PD' : 'MD';
	        },
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[Sot në] LT',
	            nextDay : '[Nesër në] LT',
	            nextWeek : 'dddd [në] LT',
	            lastDay : '[Dje në] LT',
	            lastWeek : 'dddd [e kaluar në] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'në %s',
	            past : '%s më parë',
	            s : 'disa sekonda',
	            m : 'një minutë',
	            mm : '%d minuta',
	            h : 'një orë',
	            hh : '%d orë',
	            d : 'një ditë',
	            dd : '%d ditë',
	            M : 'një muaj',
	            MM : '%d muaj',
	            y : 'një vit',
	            yy : '%d vite'
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Serbian-cyrillic (sr-cyrl)
	// author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['један минут', 'једне минуте'],
	            mm: ['минут', 'минуте', 'минута'],
	            h: ['један сат', 'једног сата'],
	            hh: ['сат', 'сата', 'сати'],
	            dd: ['дан', 'дана', 'дана'],
	            MM: ['месец', 'месеца', 'месеци'],
	            yy: ['година', 'године', 'година']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    return moment.defineLocale('sr-cyrl', {
	        months: ['јануар', 'фебруар', 'март', 'април', 'мај', 'јун', 'јул', 'август', 'септембар', 'октобар', 'новембар', 'децембар'],
	        monthsShort: ['јан.', 'феб.', 'мар.', 'апр.', 'мај', 'јун', 'јул', 'авг.', 'сеп.', 'окт.', 'нов.', 'дец.'],
	        weekdays: ['недеља', 'понедељак', 'уторак', 'среда', 'четвртак', 'петак', 'субота'],
	        weekdaysShort: ['нед.', 'пон.', 'уто.', 'сре.', 'чет.', 'пет.', 'суб.'],
	        weekdaysMin: ['не', 'по', 'ут', 'ср', 'че', 'пе', 'су'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY LT',
	            LLLL: 'dddd, D. MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[данас у] LT',
	            nextDay: '[сутра у] LT',

	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[у] [недељу] [у] LT';
	                case 3:
	                    return '[у] [среду] [у] LT';
	                case 6:
	                    return '[у] [суботу] [у] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[у] dddd [у] LT';
	                }
	            },
	            lastDay  : '[јуче у] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[прошле] [недеље] [у] LT',
	                    '[прошлог] [понедељка] [у] LT',
	                    '[прошлог] [уторка] [у] LT',
	                    '[прошле] [среде] [у] LT',
	                    '[прошлог] [четвртка] [у] LT',
	                    '[прошлог] [петка] [у] LT',
	                    '[прошле] [суботе] [у] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past   : 'пре %s',
	            s      : 'неколико секунди',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'дан',
	            dd     : translator.translate,
	            M      : 'месец',
	            MM     : translator.translate,
	            y      : 'годину',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Serbian-latin (sr)
	// author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var translator = {
	        words: { //Different grammatical cases
	            m: ['jedan minut', 'jedne minute'],
	            mm: ['minut', 'minute', 'minuta'],
	            h: ['jedan sat', 'jednog sata'],
	            hh: ['sat', 'sata', 'sati'],
	            dd: ['dan', 'dana', 'dana'],
	            MM: ['mesec', 'meseca', 'meseci'],
	            yy: ['godina', 'godine', 'godina']
	        },
	        correctGrammaticalCase: function (number, wordKey) {
	            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	        },
	        translate: function (number, withoutSuffix, key) {
	            var wordKey = translator.words[key];
	            if (key.length === 1) {
	                return withoutSuffix ? wordKey[0] : wordKey[1];
	            } else {
	                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	            }
	        }
	    };

	    return moment.defineLocale('sr', {
	        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
	        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
	        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'četvrtak', 'petak', 'subota'],
	        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'čet.', 'pet.', 'sub.'],
	        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'če', 'pe', 'su'],
	        longDateFormat: {
	            LT: 'H:mm',
	            LTS : 'LT:ss',
	            L: 'DD. MM. YYYY',
	            LL: 'D. MMMM YYYY',
	            LLL: 'D. MMMM YYYY LT',
	            LLLL: 'dddd, D. MMMM YYYY LT'
	        },
	        calendar: {
	            sameDay: '[danas u] LT',
	            nextDay: '[sutra u] LT',

	            nextWeek: function () {
	                switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	                }
	            },
	            lastDay  : '[juče u] LT',
	            lastWeek : function () {
	                var lastWeekDays = [
	                    '[prošle] [nedelje] [u] LT',
	                    '[prošlog] [ponedeljka] [u] LT',
	                    '[prošlog] [utorka] [u] LT',
	                    '[prošle] [srede] [u] LT',
	                    '[prošlog] [četvrtka] [u] LT',
	                    '[prošlog] [petka] [u] LT',
	                    '[prošle] [subote] [u] LT'
	                ];
	                return lastWeekDays[this.day()];
	            },
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'za %s',
	            past   : 'pre %s',
	            s      : 'nekoliko sekundi',
	            m      : translator.translate,
	            mm     : translator.translate,
	            h      : translator.translate,
	            hh     : translator.translate,
	            d      : 'dan',
	            dd     : translator.translate,
	            M      : 'mesec',
	            MM     : translator.translate,
	            y      : 'godinu',
	            yy     : translator.translate
	        },
	        ordinalParse: /\d{1,2}\./,
	        ordinal : '%d.',
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : swedish (sv)
	// author : Jens Alm : https://github.com/ulmus

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('sv', {
	        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'YYYY-MM-DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Idag] LT',
	            nextDay: '[Imorgon] LT',
	            lastDay: '[Igår] LT',
	            nextWeek: 'dddd LT',
	            lastWeek: '[Förra] dddd[en] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'om %s',
	            past : 'för %s sedan',
	            s : 'några sekunder',
	            m : 'en minut',
	            mm : '%d minuter',
	            h : 'en timme',
	            hh : '%d timmar',
	            d : 'en dag',
	            dd : '%d dagar',
	            M : 'en månad',
	            MM : '%d månader',
	            y : 'ett år',
	            yy : '%d år'
	        },
	        ordinalParse: /\d{1,2}(e|a)/,
	        ordinal : function (number) {
	            var b = number % 10,
	                output = (~~(number % 100 / 10) === 1) ? 'e' :
	                (b === 1) ? 'a' :
	                (b === 2) ? 'a' :
	                (b === 3) ? 'e' : 'e';
	            return number + output;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : tamil (ta)
	// author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    /*var symbolMap = {
	            '1': '௧',
	            '2': '௨',
	            '3': '௩',
	            '4': '௪',
	            '5': '௫',
	            '6': '௬',
	            '7': '௭',
	            '8': '௮',
	            '9': '௯',
	            '0': '௦'
	        },
	        numberMap = {
	            '௧': '1',
	            '௨': '2',
	            '௩': '3',
	            '௪': '4',
	            '௫': '5',
	            '௬': '6',
	            '௭': '7',
	            '௮': '8',
	            '௯': '9',
	            '௦': '0'
	        }; */

	    return moment.defineLocale('ta', {
	        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY, LT',
	            LLLL : 'dddd, D MMMM YYYY, LT'
	        },
	        calendar : {
	            sameDay : '[இன்று] LT',
	            nextDay : '[நாளை] LT',
	            nextWeek : 'dddd, LT',
	            lastDay : '[நேற்று] LT',
	            lastWeek : '[கடந்த வாரம்] dddd, LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s இல்',
	            past : '%s முன்',
	            s : 'ஒரு சில விநாடிகள்',
	            m : 'ஒரு நிமிடம்',
	            mm : '%d நிமிடங்கள்',
	            h : 'ஒரு மணி நேரம்',
	            hh : '%d மணி நேரம்',
	            d : 'ஒரு நாள்',
	            dd : '%d நாட்கள்',
	            M : 'ஒரு மாதம்',
	            MM : '%d மாதங்கள்',
	            y : 'ஒரு வருடம்',
	            yy : '%d ஆண்டுகள்'
	        },
	/*        preparse: function (string) {
	            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	                return numberMap[match];
	            });
	        },
	        postformat: function (string) {
	            return string.replace(/\d/g, function (match) {
	                return symbolMap[match];
	            });
	        },*/
	        ordinalParse: /\d{1,2}வது/,
	        ordinal : function (number) {
	            return number + 'வது';
	        },


	        // refer http://ta.wikipedia.org/s/1er1
	        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 2) {
	                return ' யாமம்';
	            } else if (hour < 6) {
	                return ' வைகறை';  // வைகறை
	            } else if (hour < 10) {
	                return ' காலை'; // காலை
	            } else if (hour < 14) {
	                return ' நண்பகல்'; // நண்பகல்
	            } else if (hour < 18) {
	                return ' எற்பாடு'; // எற்பாடு
	            } else if (hour < 22) {
	                return ' மாலை'; // மாலை
	            } else {
	                return ' யாமம்';
	            }
	        },
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === 'யாமம்') {
	                return hour < 2 ? hour : hour + 12;
	            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	                return hour;
	            } else if (meridiem === 'நண்பகல்') {
	                return hour >= 10 ? hour : hour + 12;
	            } else {
	                return hour + 12;
	            }
	        },
	        week : {
	            dow : 0, // Sunday is the first day of the week.
	            doy : 6  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : thai (th)
	// author : Kridsada Thanabulpong : https://github.com/sirn

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('th', {
	        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	        monthsShort : 'มกรา_กุมภา_มีนา_เมษา_พฤษภา_มิถุนา_กรกฎา_สิงหา_กันยา_ตุลา_พฤศจิกา_ธันวา'.split('_'),
	        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	        longDateFormat : {
	            LT : 'H นาฬิกา m นาที',
	            LTS : 'LT s วินาที',
	            L : 'YYYY/MM/DD',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY เวลา LT',
	            LLLL : 'วันddddที่ D MMMM YYYY เวลา LT'
	        },
	        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	        isPM: function (input) {
	            return input === 'หลังเที่ยง';
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 12) {
	                return 'ก่อนเที่ยง';
	            } else {
	                return 'หลังเที่ยง';
	            }
	        },
	        calendar : {
	            sameDay : '[วันนี้ เวลา] LT',
	            nextDay : '[พรุ่งนี้ เวลา] LT',
	            nextWeek : 'dddd[หน้า เวลา] LT',
	            lastDay : '[เมื่อวานนี้ เวลา] LT',
	            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'อีก %s',
	            past : '%sที่แล้ว',
	            s : 'ไม่กี่วินาที',
	            m : '1 นาที',
	            mm : '%d นาที',
	            h : '1 ชั่วโมง',
	            hh : '%d ชั่วโมง',
	            d : '1 วัน',
	            dd : '%d วัน',
	            M : '1 เดือน',
	            MM : '%d เดือน',
	            y : '1 ปี',
	            yy : '%d ปี'
	        }
	    });
	}));


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Tagalog/Filipino (tl-ph)
	// author : Dan Hagman

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('tl-ph', {
	        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'MM/D/YYYY',
	            LL : 'MMMM D, YYYY',
	            LLL : 'MMMM D, YYYY LT',
	            LLLL : 'dddd, MMMM DD, YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Ngayon sa] LT',
	            nextDay: '[Bukas sa] LT',
	            nextWeek: 'dddd [sa] LT',
	            lastDay: '[Kahapon sa] LT',
	            lastWeek: 'dddd [huling linggo] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'sa loob ng %s',
	            past : '%s ang nakalipas',
	            s : 'ilang segundo',
	            m : 'isang minuto',
	            mm : '%d minuto',
	            h : 'isang oras',
	            hh : '%d oras',
	            d : 'isang araw',
	            dd : '%d araw',
	            M : 'isang buwan',
	            MM : '%d buwan',
	            y : 'isang taon',
	            yy : '%d taon'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : turkish (tr)
	// authors : Erhan Gundogan : https://github.com/erhangundogan,
	//           Burak Yiğit Kaya: https://github.com/BYK

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    var suffixes = {
	        1: '\'inci',
	        5: '\'inci',
	        8: '\'inci',
	        70: '\'inci',
	        80: '\'inci',

	        2: '\'nci',
	        7: '\'nci',
	        20: '\'nci',
	        50: '\'nci',

	        3: '\'üncü',
	        4: '\'üncü',
	        100: '\'üncü',

	        6: '\'ncı',

	        9: '\'uncu',
	        10: '\'uncu',
	        30: '\'uncu',

	        60: '\'ıncı',
	        90: '\'ıncı'
	    };

	    return moment.defineLocale('tr', {
	        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd, D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay : '[bugün saat] LT',
	            nextDay : '[yarın saat] LT',
	            nextWeek : '[haftaya] dddd [saat] LT',
	            lastDay : '[dün] LT',
	            lastWeek : '[geçen hafta] dddd [saat] LT',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : '%s sonra',
	            past : '%s önce',
	            s : 'birkaç saniye',
	            m : 'bir dakika',
	            mm : '%d dakika',
	            h : 'bir saat',
	            hh : '%d saat',
	            d : 'bir gün',
	            dd : '%d gün',
	            M : 'bir ay',
	            MM : '%d ay',
	            y : 'bir yıl',
	            yy : '%d yıl'
	        },
	        ordinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	        ordinal : function (number) {
	            if (number === 0) {  // special case for zero
	                return number + '\'ıncı';
	            }
	            var a = number % 10,
	                b = number % 100 - a,
	                c = number >= 100 ? 100 : null;

	            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Morocco Central Atlas Tamaziɣt in Latin (tzm-latn)
	// author : Abdel Said : https://github.com/abdelsaid

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('tzm-latn', {
	        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[asdkh g] LT',
	            nextDay: '[aska g] LT',
	            nextWeek: 'dddd [g] LT',
	            lastDay: '[assant g] LT',
	            lastWeek: 'dddd [g] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'dadkh s yan %s',
	            past : 'yan %s',
	            s : 'imik',
	            m : 'minuḍ',
	            mm : '%d minuḍ',
	            h : 'saɛa',
	            hh : '%d tassaɛin',
	            d : 'ass',
	            dd : '%d ossan',
	            M : 'ayowr',
	            MM : '%d iyyirn',
	            y : 'asgas',
	            yy : '%d isgasn'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : Morocco Central Atlas Tamaziɣt (tzm)
	// author : Abdel Said : https://github.com/abdelsaid

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('tzm', {
	        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS: 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'dddd D MMMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	            nextWeek: 'dddd [ⴴ] LT',
	            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	            lastWeek: 'dddd [ⴴ] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	            past : 'ⵢⴰⵏ %s',
	            s : 'ⵉⵎⵉⴽ',
	            m : 'ⵎⵉⵏⵓⴺ',
	            mm : '%d ⵎⵉⵏⵓⴺ',
	            h : 'ⵙⴰⵄⴰ',
	            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	            d : 'ⴰⵙⵙ',
	            dd : '%d oⵙⵙⴰⵏ',
	            M : 'ⴰⵢoⵓⵔ',
	            MM : '%d ⵉⵢⵢⵉⵔⵏ',
	            y : 'ⴰⵙⴳⴰⵙ',
	            yy : '%d ⵉⵙⴳⴰⵙⵏ'
	        },
	        week : {
	            dow : 6, // Saturday is the first day of the week.
	            doy : 12  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : ukrainian (uk)
	// author : zemlanin : https://github.com/zemlanin
	// Author : Menelion Elensúle : https://github.com/Oire

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    function plural(word, num) {
	        var forms = word.split('_');
	        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	    }

	    function relativeTimeWithPlural(number, withoutSuffix, key) {
	        var format = {
	            'mm': 'хвилина_хвилини_хвилин',
	            'hh': 'година_години_годин',
	            'dd': 'день_дні_днів',
	            'MM': 'місяць_місяці_місяців',
	            'yy': 'рік_роки_років'
	        };
	        if (key === 'm') {
	            return withoutSuffix ? 'хвилина' : 'хвилину';
	        }
	        else if (key === 'h') {
	            return withoutSuffix ? 'година' : 'годину';
	        }
	        else {
	            return number + ' ' + plural(format[key], +number);
	        }
	    }

	    function monthsCaseReplace(m, format) {
	        var months = {
	            'nominative': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_'),
	            'accusative': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_')
	        },

	        nounCase = (/D[oD]? *MMMM?/).test(format) ?
	            'accusative' :
	            'nominative';

	        return months[nounCase][m.month()];
	    }

	    function weekdaysCaseReplace(m, format) {
	        var weekdays = {
	            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	        },

	        nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	            'accusative' :
	            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	                'genitive' :
	                'nominative');

	        return weekdays[nounCase][m.day()];
	    }

	    function processHoursFunction(str) {
	        return function () {
	            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	        };
	    }

	    return moment.defineLocale('uk', {
	        months : monthsCaseReplace,
	        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	        weekdays : weekdaysCaseReplace,
	        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD.MM.YYYY',
	            LL : 'D MMMM YYYY р.',
	            LLL : 'D MMMM YYYY р., LT',
	            LLLL : 'dddd, D MMMM YYYY р., LT'
	        },
	        calendar : {
	            sameDay: processHoursFunction('[Сьогодні '),
	            nextDay: processHoursFunction('[Завтра '),
	            lastDay: processHoursFunction('[Вчора '),
	            nextWeek: processHoursFunction('[У] dddd ['),
	            lastWeek: function () {
	                switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[Минулої] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[Минулого] dddd [').call(this);
	                }
	            },
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : 'за %s',
	            past : '%s тому',
	            s : 'декілька секунд',
	            m : relativeTimeWithPlural,
	            mm : relativeTimeWithPlural,
	            h : 'годину',
	            hh : relativeTimeWithPlural,
	            d : 'день',
	            dd : relativeTimeWithPlural,
	            M : 'місяць',
	            MM : relativeTimeWithPlural,
	            y : 'рік',
	            yy : relativeTimeWithPlural
	        },

	        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason

	        meridiemParse: /ночі|ранку|дня|вечора/,
	        isPM: function (input) {
	            return /^(дня|вечора)$/.test(input);
	        },
	        meridiem : function (hour, minute, isLower) {
	            if (hour < 4) {
	                return 'ночі';
	            } else if (hour < 12) {
	                return 'ранку';
	            } else if (hour < 17) {
	                return 'дня';
	            } else {
	                return 'вечора';
	            }
	        },

	        ordinalParse: /\d{1,2}-(й|го)/,
	        ordinal: function (number, period) {
	            switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            default:
	                return number;
	            }
	        },

	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 1st is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : uzbek (uz)
	// author : Sardor Muminov : https://github.com/muminoff

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('uz', {
	        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM YYYY',
	            LLL : 'D MMMM YYYY LT',
	            LLLL : 'D MMMM YYYY, dddd LT'
	        },
	        calendar : {
	            sameDay : '[Бугун соат] LT [да]',
	            nextDay : '[Эртага] LT [да]',
	            nextWeek : 'dddd [куни соат] LT [да]',
	            lastDay : '[Кеча соат] LT [да]',
	            lastWeek : '[Утган] dddd [куни соат] LT [да]',
	            sameElse : 'L'
	        },
	        relativeTime : {
	            future : 'Якин %s ичида',
	            past : 'Бир неча %s олдин',
	            s : 'фурсат',
	            m : 'бир дакика',
	            mm : '%d дакика',
	            h : 'бир соат',
	            hh : '%d соат',
	            d : 'бир кун',
	            dd : '%d кун',
	            M : 'бир ой',
	            MM : '%d ой',
	            y : 'бир йил',
	            yy : '%d йил'
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 7  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : vietnamese (vi)
	// author : Bang Nguyen : https://github.com/bangnk

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('vi', {
	        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	        longDateFormat : {
	            LT : 'HH:mm',
	            LTS : 'LT:ss',
	            L : 'DD/MM/YYYY',
	            LL : 'D MMMM [năm] YYYY',
	            LLL : 'D MMMM [năm] YYYY LT',
	            LLLL : 'dddd, D MMMM [năm] YYYY LT',
	            l : 'DD/M/YYYY',
	            ll : 'D MMM YYYY',
	            lll : 'D MMM YYYY LT',
	            llll : 'ddd, D MMM YYYY LT'
	        },
	        calendar : {
	            sameDay: '[Hôm nay lúc] LT',
	            nextDay: '[Ngày mai lúc] LT',
	            nextWeek: 'dddd [tuần tới lúc] LT',
	            lastDay: '[Hôm qua lúc] LT',
	            lastWeek: 'dddd [tuần rồi lúc] LT',
	            sameElse: 'L'
	        },
	        relativeTime : {
	            future : '%s tới',
	            past : '%s trước',
	            s : 'vài giây',
	            m : 'một phút',
	            mm : '%d phút',
	            h : 'một giờ',
	            hh : '%d giờ',
	            d : 'một ngày',
	            dd : '%d ngày',
	            M : 'một tháng',
	            MM : '%d tháng',
	            y : 'một năm',
	            yy : '%d năm'
	        },
	        ordinalParse: /\d{1,2}/,
	        ordinal : function (number) {
	            return number;
	        },
	        week : {
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : chinese (zh-cn)
	// author : suupic : https://github.com/suupic
	// author : Zeno Zeng : https://github.com/zenozeng

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('zh-cn', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah点mm',
	            LTS : 'Ah点m分s秒',
	            L : 'YYYY-MM-DD',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日LT',
	            LLLL : 'YYYY年MMMD日ddddLT',
	            l : 'YYYY-MM-DD',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日LT',
	            llll : 'YYYY年MMMD日ddddLT'
	        },
	        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	        meridiemHour: function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '凌晨' || meridiem === '早上' ||
	                    meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            } else {
	                // '中午'
	                return hour >= 11 ? hour : hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 600) {
	                return '凌晨';
	            } else if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : function () {
	                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
	            },
	            nextDay : function () {
	                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
	            },
	            lastDay : function () {
	                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
	            },
	            nextWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            lastWeek : function () {
	                var startOfWeek, prefix;
	                startOfWeek = moment().startOf('week');
	                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
	                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
	            },
	            sameElse : 'LL'
	        },
	        ordinalParse: /\d{1,2}(日|月|周)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            case 'M':
	                return number + '月';
	            case 'w':
	            case 'W':
	                return number + '周';
	            default:
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s内',
	            past : '%s前',
	            s : '几秒',
	            m : '1分钟',
	            mm : '%d分钟',
	            h : '1小时',
	            hh : '%d小时',
	            d : '1天',
	            dd : '%d天',
	            M : '1个月',
	            MM : '%d个月',
	            y : '1年',
	            yy : '%d年'
	        },
	        week : {
	            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	            dow : 1, // Monday is the first day of the week.
	            doy : 4  // The week that contains Jan 4th is the first week of the year.
	        }
	    });
	}));


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// moment.js locale configuration
	// locale : traditional chinese (zh-tw)
	// author : Ben : https://github.com/ben-lin

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('../moment')); // Node
	    } else {
	        factory((typeof global !== 'undefined' ? global : this).moment); // node or other global
	    }
	}(function (moment) {
	    return moment.defineLocale('zh-tw', {
	        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	        longDateFormat : {
	            LT : 'Ah點mm',
	            LTS : 'Ah點m分s秒',
	            L : 'YYYY年MMMD日',
	            LL : 'YYYY年MMMD日',
	            LLL : 'YYYY年MMMD日LT',
	            LLLL : 'YYYY年MMMD日ddddLT',
	            l : 'YYYY年MMMD日',
	            ll : 'YYYY年MMMD日',
	            lll : 'YYYY年MMMD日LT',
	            llll : 'YYYY年MMMD日ddddLT'
	        },
	        meridiemParse: /早上|上午|中午|下午|晚上/,
	        meridiemHour : function (hour, meridiem) {
	            if (hour === 12) {
	                hour = 0;
	            }
	            if (meridiem === '早上' || meridiem === '上午') {
	                return hour;
	            } else if (meridiem === '中午') {
	                return hour >= 11 ? hour : hour + 12;
	            } else if (meridiem === '下午' || meridiem === '晚上') {
	                return hour + 12;
	            }
	        },
	        meridiem : function (hour, minute, isLower) {
	            var hm = hour * 100 + minute;
	            if (hm < 900) {
	                return '早上';
	            } else if (hm < 1130) {
	                return '上午';
	            } else if (hm < 1230) {
	                return '中午';
	            } else if (hm < 1800) {
	                return '下午';
	            } else {
	                return '晚上';
	            }
	        },
	        calendar : {
	            sameDay : '[今天]LT',
	            nextDay : '[明天]LT',
	            nextWeek : '[下]ddddLT',
	            lastDay : '[昨天]LT',
	            lastWeek : '[上]ddddLT',
	            sameElse : 'L'
	        },
	        ordinalParse: /\d{1,2}(日|月|週)/,
	        ordinal : function (number, period) {
	            switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	            }
	        },
	        relativeTime : {
	            future : '%s內',
	            past : '%s前',
	            s : '幾秒',
	            m : '一分鐘',
	            mm : '%d分鐘',
	            h : '一小時',
	            hh : '%d小時',
	            d : '一天',
	            dd : '%d天',
	            M : '一個月',
	            MM : '%d個月',
	            y : '一年',
	            yy : '%d年'
	        }
	    });
	}));


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "InlineDialog",

	  propTypes: {
	    onShow: React.PropTypes.func
	  },

	  componentDidMount: function componentDidMount() {
	    this._shouldShow();
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this._shouldShow();
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      dialogId: "dialog",
	      onShow: _.noop
	    };
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "aui-inline-dialog", "aria-hidden": this.props.invisible ? "true" : "false", id: this.props.dialogId },
	      React.createElement(
	        "div",
	        { className: "aui-inline-dialog-contents" },
	        this.props.children,
	        React.createElement("div", { className: "aui-inline-dialog-arrow arrow aui-css-arrow" })
	      )
	    );
	  },

	  _shouldShow: function _shouldShow() {
	    if (!this.props.invisible) this.props.onShow();
	  }
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var utils = __webpack_require__(4);

	var IframeMessenger = (function () {
	  function IframeMessenger(frame, messageHandler) {
	    _classCallCheck(this, IframeMessenger);

	    var src = frame.getAttribute("src");
	    this.frameOrigin = utils.getOriginFromUrl(src);
	    this.iFrameWindow = frame.contentWindow;
	    this.messageHandler = messageHandler;
	    this.listenForMessages();
	  }

	  _prototypeProperties(IframeMessenger, null, {
	    listenForMessages: {
	      value: function listenForMessages() {
	        this._boundMessageReceived = _.bind(this._onMessageReceived, this);
	        window.addEventListener("message", this._boundMessageReceived, false);
	      },
	      writable: true,
	      configurable: true
	    },
	    _onMessageReceived: {
	      value: function _onMessageReceived(msg) {
	        if (msg.source === this.iFrameWindow) {
	          this.messageHandler(msg);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    postMessage: {
	      value: function postMessage(msg) {
	        // Only post message if iFrameWindow has loaded
	        if (this.iFrameWindow) {
	          var serializedMsg = this._serializeMessage(msg);
	          this.iFrameWindow.postMessage(serializedMsg, this.frameOrigin);
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    _serializeMessage: {
	      value: function _serializeMessage(msg) {
	        if (typeof msg === "string") {
	          return msg;
	        }

	        return JSON.stringify(msg);
	      },
	      writable: true,
	      configurable: true
	    },
	    destroy: {
	      value: function destroy() {
	        window.removeEventListener("message", this._boundMessageReceived);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return IframeMessenger;
	})();

	module.exports = IframeMessenger;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43),
	    Storage = __webpack_require__(120),
	    AppDispatcher = __webpack_require__(1),
	    AppConfig = __webpack_require__(3);

	var AceStpStore = (function (Store) {
	  function AceStpStore() {
	    _classCallCheck(this, AceStpStore);

	    if (Store != null) {
	      Store.apply(this, arguments);
	    }
	  }

	  _inherits(AceStpStore, Store);

	  _prototypeProperties(AceStpStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          button_status: "help"
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "hide-inline-dialog": function (data) {
	            if (data.dialog_type === "ace-stp-inline-dialog") {
	              _this.updateButtonStatus("help");
	            }
	          },
	          "toggle-inline-dialog": function (data) {
	            if (data.current_dialog_type === "ace-stp-inline-dialog") {
	              _this.updateButtonStatus("help");
	            }
	          },
	          "ace-stp-button-update": function (data) {
	            _this.updateButtonStatus(data.type);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    updateButtonStatus: {
	      value: function updateButtonStatus(type) {
	        if (type === "newMessage") {
	          type = "message";
	        } else if (type === "dismissedMessage") {
	          type = "help";
	        }

	        this.setIfNotEqual("button_status", type);
	      },
	      writable: true,
	      configurable: true
	    },
	    getIFrameUrl: {
	      value: function getIFrameUrl() {
	        // We want to be able to override the iFrame URL for unit test and also testing new versions of the iFrame in production
	        var iFrameUrl = Storage.get("ace.stp.menu.hipchat.frame.url");
	        if (iFrameUrl) {
	          return iFrameUrl;
	        }
	        return AppConfig.ace_stp_iframe_url;
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return AceStpStore;
	})(Store);

	module.exports = new AceStpStore();

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var HeaderStrings = __webpack_require__(268),
	    AppHeaderActions = __webpack_require__(48),
	    KeyboardShortcuts = __webpack_require__(11),
	    DialogActions = __webpack_require__(28);

	module.exports = React.createClass({

	  displayName: "HelpMenu",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onClick: _.noop
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    // Can't use standard React events here since AUI has mutated the drop-down.
	    // React can't operate on DOM that's mutated since it's been created. In most
	    // other cases, we should stick with React events.
	    document.querySelector(".hc-keyboard-shortcuts").addEventListener("click", this._onKeyboardShortcutsClick);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    document.querySelector(".hc-keyboard-shortcuts").removeEventListener("click", this._onKeyboardShortcutsClick);
	  },

	  _onKeyboardShortcutsClick: function _onKeyboardShortcutsClick() {
	    this.props.onClick();
	    var shortcuts = KeyboardShortcuts.getShortcuts();
	    DialogActions.showKeyboardShortcutsDialog(shortcuts);
	  },

	  render: function render() {
	    return React.createElement(
	      "ul",
	      { id: "ace-stp-help-links" },
	      React.createElement(
	        "li",
	        null,
	        React.createElement(
	          "a",
	          { className: "hc-online-help", href: "http://help.hipchat.com/", target: "_blank" },
	          HeaderStrings.online_help
	        )
	      ),
	      React.createElement(
	        "li",
	        null,
	        React.createElement(
	          "a",
	          { className: "hc-keyboard-shortcuts" },
	          HeaderStrings.keyboard_shortcuts
	        )
	      )
	    );
	  }
	});

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  help: "Help",
	  ask_a_question: "Ask a question"
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var DialogActions = __webpack_require__(28);
	var strings = __webpack_require__(232);
	var Spinner = __webpack_require__(77);
	var invariant = __webpack_require__(239);

	module.exports = React.createClass({

	  displayName: "ModalDialog",

	  componentWillMount: function componentWillMount() {
	    invariant(_.contains(["small", "medium", "large"], this.props.size), "Size must be either small, medium or large");
	  },

	  componentDidMount: function componentDidMount() {
	    document.querySelector("body").addEventListener("keydown", this._onKeyDown);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    document.querySelector("body").removeEventListener("keydown", this._onKeyDown);
	    if (document.getElementById("hc-message-input")) {
	      document.getElementById("hc-message-input").focus();
	    }
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      closeLinkText: "Close",
	      dialogId: "dialog",
	      dialogBody: _.noop,
	      dialogFooterButton: _.noop,
	      btnLoading: false,
	      size: "medium"
	    };
	  },

	  _getCloseBtn: function _getCloseBtn() {
	    return React.createElement(
	      "a",
	      { className: "aui-dialog2-header-close", onClick: this._onClick },
	      React.createElement(
	        "span",
	        { className: "aui-icon aui-icon-small aui-iconfont-close-dialog" },
	        strings.close
	      )
	    );
	  },

	  close: function close() {
	    DialogActions.closeDialog();
	  },

	  _onKeyDown: function _onKeyDown(e) {
	    var key = window.Event ? e.which : e.keyCode;
	    if (key === 27 && !this.props.btnLoading) {
	      this.close();
	    }
	  },

	  _onClick: function _onClick(e) {
	    if (!this.props.btnLoading) {
	      this.close();
	    }
	  },

	  render: function render() {

	    var sizeClass = "aui-dialog2-" + this.props.size,
	        closeBtn = this.props.btnLoading ? "" : this._getCloseBtn();

	    return React.createElement(
	      "section",
	      { role: "dialog", id: this.props.dialogId, className: "aui-layer aui-dialog2 " + sizeClass },
	      React.createElement(
	        "header",
	        { className: "aui-dialog2-header" },
	        React.createElement(
	          "h2",
	          { className: "aui-dialog2-header-main" },
	          this.props.title
	        ),
	        closeBtn
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dialog2-content" },
	        this.props.dialogBody()
	      ),
	      React.createElement(
	        "footer",
	        { className: "aui-dialog2-footer" },
	        React.createElement(
	          "div",
	          { className: "aui-dialog2-footer-actions" },
	          React.createElement(
	            "div",
	            { className: "hc-dialog-btn-spinner" },
	            React.createElement(Spinner, { spin: this.props.btnLoading, size: "small" })
	          ),
	          this.props.dialogFooterButton(),
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-link", "aria-disabled": this.props.btnLoading, onClick: this._onClick },
	            this.props.closeLinkText
	          )
	        )
	      )
	    );
	  }
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var NavPanelContent = __webpack_require__(229);
	var invariant = __webpack_require__(239);

	module.exports = React.createClass({

	  displayName: "NavPanel",

	  _onClick: function _onClick(e) {
	    this.setState({
	      activeTab: e.target.getAttribute("name")
	    });
	  },

	  componentWillMount: function componentWillMount() {
	    invariant(this.props.children.length > 1, "Require more than one tab");

	    var allChildrenNamed = _.every(this.props.children, function (child) {
	      return child.props.name;
	    });

	    invariant(allChildrenNamed, "All NavPanel children must have a name attribute");
	  },

	  getInitialState: function getInitialState() {
	    return {
	      activeTab: this.props.children[0].props.name
	    };
	  },

	  render: function render() {
	    var _this = this;

	    var menuItems = React.Children.map(this.props.children, function (child) {
	      if (child.type.displayName == "NavPanelContent") {
	        return React.createElement(
	          "li",
	          { role: "tab", selected: _this.state.activeTab === child.props.name, key: _.uniqueId() },
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-link", onClick: _this._onClick,
	              name: child.props.name },
	            child.props.name
	          )
	        );
	      }
	    });
	    var tabPanels = React.Children.map(this.props.children, function (child) {
	      if (child.type.displayName == "NavPanelContent") {
	        return React.createElement(
	          NavPanelContent,
	          { name: child.props.name, selected: _this.state.activeTab === child.props.name,
	            key: _.uniqueId() },
	          child.props.children
	        );
	      }
	    });

	    return React.createElement(
	      "div",
	      _extends({}, this.props, { className: "hc-nav-panel aui-group" }),
	      React.createElement(
	        "ul",
	        { className: "aui-item aui-nav", "data-skate-ignore": true },
	        menuItems
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-item" },
	        tabPanels
	      )
	    );
	  }

	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "NavPanelContent",

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "nav-panel-content", "aria-hidden": !this.props.selected, "aria-labeledby": this.props.tabId },
	      React.createElement(
	        "h2",
	        null,
	        this.props.name
	      ),
	      this.props.children
	    );
	  }
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var AuiCheckboxField = __webpack_require__(274);
	var PreferencesStore = __webpack_require__(21);
	var ClientPreferencesStore = __webpack_require__(38);
	var PreferencesKeys = __webpack_require__(68);

	module.exports = React.createClass({

	  displayName: "PreferenceCheckboxField",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      isReverse: false
	    };
	  },

	  _isDefaultChecked: function _isDefaultChecked() {
	    var isServerPref = _.contains(_.values(PreferencesKeys), this.props.id);
	    var store = isServerPref ? PreferencesStore : ClientPreferencesStore;
	    var isChecked = store.get(this.props.id);

	    if (this.props.isReverse) {
	      isChecked = !isChecked;
	    }

	    return isChecked;
	  },

	  render: function render() {
	    return React.createElement(AuiCheckboxField, _extends({}, this.props, { defaultChecked: this._isDefaultChecked() }));
	  }
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AuiRadio = __webpack_require__(275);
	var PreferencesStore = __webpack_require__(21);
	var ClientPreferencesStore = __webpack_require__(38);
	var PreferencesKeys = __webpack_require__(68);
	var strings = __webpack_require__(232);

	module.exports = React.createClass({

	  displayName: "PreferenceRadioField",

	  _isDefaultChecked: function _isDefaultChecked(val) {
	    var isServerPref = _.contains(_.values(PreferencesKeys), this.props.id);
	    var store = isServerPref ? PreferencesStore : ClientPreferencesStore;
	    return val === store.get(this.props.id);
	  },

	  render: function render() {
	    var _this = this;

	    return React.createElement(
	      "fieldset",
	      { className: "group" },
	      React.createElement(
	        "legend",
	        null,
	        React.createElement(
	          "span",
	          null,
	          this.props.label
	        )
	      ),
	      _(this.props.options).map(function (option) {
	        return React.createElement(AuiRadio, {
	          val: option,
	          id: option,
	          label: strings[option],
	          name: _this.props.id,
	          defaultChecked: _this._isDefaultChecked(option),
	          onChange: _.noop });
	      }, this)
	    );
	  }
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  create_room: "Create room",
	  delete_room: "Delete room",
	  disable_guest: "Disable guest access",
	  join: "Join room",
	  ok: "Ok",
	  close: "Close",
	  cancel: "Cancel",
	  rename: "Rename",
	  try_again: "Try again",
	  archive: "Archive",
	  archive_room: "Archive room",
	  unarchive: "Unarchive",
	  unarchive_room: "Unarchive room",
	  confirm_archive: "This will prevent any users from chatting in the room.",
	  confirm_disable_guest: "The room URL will be disabled and current guests will be kicked from the room",
	  show_avatars: "Show user avatars",
	  confirm_delete: function confirm_delete(room) {
	    return "Are you sure you want to delete " + room + "?";
	  },
	  room_deleted: function room_deleted(room) {
	    return "" + room + " deleted.";
	  },
	  room_archived: "Room archived.",
	  room_unarchived: "Room unarchived.",
	  archive_room_name: function archive_room_name(room) {
	    return "Archive " + room;
	  },
	  unarchive_room_name: function unarchive_room_name(room) {
	    return "Unarchive " + room;
	  },
	  really_archive: function really_archive(room) {
	    return "Are you sure you want to archive the " + room + " room?";
	  },
	  really_unarchive: function really_unarchive(room) {
	    return "Are you sure you want to unarchive the " + room + " room?";
	  },
	  really_disable_guest: "Are you sure you want to disable guest access?",
	  invite_users: function invite_users(room) {
	    return "Invite people to " + room;
	  },
	  choose_removed_members: "Remove people",
	  join_room: function join_room(room) {
	    return "Join " + room;
	  },
	  rename_room: function rename_room(room) {
	    return "Rename " + room;
	  },
	  invited_to_join: function invited_to_join(inviter, room) {
	    return "" + inviter + " invited you to join " + room;
	  },
	  disable_guest_fail: "Couldn't disable guest access.",
	  archive_fail: "Couldn't archive room.",
	  unarchive_fail: "Couldn't unarchive room.",
	  delete_room_fail: "Couldn't delete room.",
	  set_privacy: "Set privacy",
	  notify_for_room: "A message is sent to an open room I'm in",
	  notify_for_private_room: "A message is sent to a private room I'm in",
	  notify_for_tag: "I'm mentioned in a room",
	  notify_for_private: "I receive a private message",
	  disable_sounds: "Playing a sound",
	  show_toasters: "Showing a popup",
	  hide_presence_messages: "Show room join and leave messages",
	  use_24_hour_format: "Display time in 24-hour format",
	  hide_gifs_by_default: "Hide gifs by default",
	  replace_text_emoticons: "Replace text emoticons with images",
	  show_unread_divider: "Show divider for unread messages",
	  create_a_new_room: "Create a new room",
	  change_privacy: "Change privacy",
	  theme: "Theme",
	  density: "Density",
	  clean: "Clean",
	  dark: "Dark",
	  normal: "Normal",
	  tighter: "Tighter"
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Promise = __webpack_require__(69).Promise;
	var AuiSelect2FieldGroup = __webpack_require__(276),
	    AuiTextAreaFieldGroup = __webpack_require__(277),
	    FlagActions = __webpack_require__(49),
	    FormActions = __webpack_require__(50),
	    DialogActions = __webpack_require__(28),
	    AppDispatcher = __webpack_require__(1),
	    FormsStore = __webpack_require__(269),
	    strings = __webpack_require__(270),
	    FormErrors = __webpack_require__(271),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "InviteUsersForm",

	  componentDidMount: function componentDidMount() {
	    FormsStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    FormsStore.off("change", this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return this._getState();
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  _getState: function _getState() {
	    return {
	      roster: FormsStore.get("roster"),
	      currentUser: FormsStore.get("currentUser"),
	      activeChatParticipants: FormsStore.get("activeChatParticipants"),
	      errors: {}
	    };
	  },

	  _rosterForSelect: function _rosterForSelect() {
	    return Utils.roster.format_for_select2(_.union(this.state.currentUser.user_jid, this.state.activeChatParticipants), this.state.roster);
	  },

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(this.refs.form.getDOMNode()).serializeArray(),
	        users = form_inputs[0].value,
	        msg = form_inputs[1].value,
	        promises = [],
	        errors;

	    errors = this._validate(users, msg);
	    if (errors) {
	      this.setState({
	        errors: errors
	      });
	    } else {
	      promises.push(this._inviteUsers(users.split(","), msg));
	      this._handlePromises(promises);
	      this._closeDialog();
	    }
	  },

	  _validate: function _validate(users, msg) {
	    if (!users) {
	      return {
	        user: FormErrors.invite_users_form.no_users
	      };
	    } else if (msg && msg.length > 250) {
	      return {
	        msg: FormErrors.invite_users_form.msg_too_long
	      };
	    }
	  },

	  _inviteUsers: function _inviteUsers(user_jids, msg) {
	    var _this = this;

	    return new Promise(function (resolve, reject) {
	      FormActions.inviteUsers({
	        room_jid: _this.props.room_jid,
	        user_jids: user_jids,
	        reason: msg
	      });
	      resolve();
	    });
	  },

	  _handlePromises: function _handlePromises(promises) {
	    Promise.all(promises).then((function (data) {
	      this._throwFlagSuccess();
	    }).bind(this), (function (error) {
	      this._throwFlagError();
	    }).bind(this));
	  },

	  _throwFlagSuccess: function _throwFlagSuccess() {
	    FlagActions.showFlag({
	      type: "success",
	      body: strings.success.users_invited,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError() {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagErrorActions(strings.fail.invite_fail),
	      close: "manual"
	    });
	  },

	  _flagErrorActions: function _flagErrorActions(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._flagActionClick, href: "#" },
	            "strings.button.try_again"
	          )
	        )
	      )
	    );
	  },

	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data("flag-index");
	    FlagActions.removeFlag(flag_index);
	    this._showDialog();
	  },

	  _showDialog: function _showDialog() {
	    DialogActions.showInviteUsersDialog();
	  },

	  _closeDialog: function _closeDialog() {
	    DialogActions.closeDialog();
	  },

	  render: function render() {
	    var errors = this.state.errors;
	    return React.createElement(
	      "form",
	      { id: "invite-users-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(AuiSelect2FieldGroup, { id: "invite-users-people", label: strings.label.these_people, multiple: true, data: this._rosterForSelect(), error: errors.user, ref: "user-select" }),
	      React.createElement(AuiTextAreaFieldGroup, { id: "invite-users-message", label: strings.label.message, rows: "5", error: errors.msg, ref: "invite_message" })
	    );
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1),
	    AuiInputFieldGroup = __webpack_require__(278),
	    FlagActions = __webpack_require__(49),
	    DialogActions = __webpack_require__(28),
	    FormActions = __webpack_require__(50),
	    FormErrors = __webpack_require__(271),
	    FormsStore = __webpack_require__(269),
	    strings = __webpack_require__(270),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "RenameRoomForm",

	  componentDidMount: function componentDidMount() {
	    FormsStore.on("change:allRooms", this._onChange);
	    this._focusInput();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    FormsStore.off("change:allRooms", this._onChange);
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.errors.name) {
	      this.refs.nameField.focus();
	    }
	  },

	  getInitialState: function getInitialState() {
	    return this._getState();
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  _getState: function _getState() {
	    return {
	      allRooms: FormsStore.get("allRooms"),
	      errors: {}
	    };
	  },

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(this.refs.form.getDOMNode()).serializeArray(),
	        name = form_inputs[0].value.trim();

	    var errors = this._validate(name);
	    if (errors) {
	      this.setState({
	        errors: errors
	      });
	    } else {
	      this._clearErrors();
	      DialogActions.startBtnLoading();
	      FormActions.changeRoomName({
	        jid: this.props.jid,
	        name: Utils.escape(name)
	      }, this._handleResponse);
	    }
	  },

	  _validate: function _validate(name) {
	    if (!name) {
	      return {
	        name: FormErrors.rename_room_form.no_room_name
	      };
	    } else if (name.length > 50) {
	      return {
	        name: FormErrors.rename_room_form.name_too_long
	      };
	    } else if (name === this.props.name) {
	      return {
	        name: FormErrors.rename_room_form.same_name
	      };
	    } else if (_.find(this.state.allRooms, function (room) {
	      return room.name && room.name.toLowerCase() === name.toLowerCase();
	    })) {
	      return {
	        name: FormErrors.rename_room_form.room_already_exists
	      };
	    }
	  },

	  _clearErrors: function _clearErrors() {
	    this.setState({
	      errors: {}
	    });
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = Utils.dot(data, "error.text.__text") ? data.error.text.__text : strings.fail.rename_flag;
	      this._throwFlagError(error_msg);
	    } else {
	      this._throwFlagSuccess(strings.success.rename_flag);
	    }
	    this._closeDialog();
	  },

	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    FlagActions.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      title: error,
	      body: this._flagBody(),
	      close: "manual"
	    });
	  },

	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data("flag-index");
	    FlagActions.removeFlag(flag_index);
	    this._showDialog();
	  },

	  _flagBody: function _flagBody() {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._flagActionClick, href: "#" },
	            strings.button.try_again
	          )
	        )
	      )
	    );
	  },

	  _showDialog: function _showDialog() {
	    DialogActions.showRenameRoomDialog({
	      jid: this.props.jid,
	      name: this.props.name
	    });
	  },

	  _closeDialog: function _closeDialog() {
	    DialogActions.closeDialog();
	  },

	  _focusInput: function _focusInput() {
	    this.refs.form.getDOMNode().querySelector("#room-name").focus();
	  },

	  render: function render() {
	    var errors = this.state.errors;

	    return React.createElement(
	      "form",
	      { id: "rename-room-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(AuiInputFieldGroup, { id: "room-name", ref: "nameField", disabled: this.props.loading, maxLength: "50", label: strings.label.new_room_name, error: errors.name })
	    );
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1),
	    AuiCheckboxField = __webpack_require__(274),
	    FormResetMixin = __webpack_require__(272),
	    FlagActions = __webpack_require__(49),
	    DialogActions = __webpack_require__(28),
	    FormActions = __webpack_require__(50),
	    FormsStore = __webpack_require__(269),
	    strings = __webpack_require__(270),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "RemoveUsersForm",

	  mixins: [FormResetMixin],

	  shouldComponentUpdate: function shouldComponentUpdate() {
	    return !this.refs.form.getDOMNode().querySelectorAll(":checked").length;
	  },

	  componentDidMount: function componentDidMount() {
	    FormsStore.on("change", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    FormsStore.off("change", this._onChange);
	  },

	  getInitialState: function getInitialState() {
	    return this._getState();
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  _getState: function _getState() {
	    return {
	      activeChatParticipants: FormsStore.get("activeChatParticipants"),
	      roster: FormsStore.get("roster"),
	      activeChat: FormsStore.get("activeChat")
	    };
	  },

	  _getName: function _getName(jid) {
	    return this.state.roster[jid].name;
	  },

	  _isAdmin: function _isAdmin(jid) {
	    return _.contains(this.state.activeChat.admins, jid);
	  },

	  _sortParticipants: function _sortParticipants() {
	    var participants = _.map(this.state.activeChatParticipants, function (jid) {
	      return {
	        jid: jid,
	        name: this._getName(jid),
	        isAdmin: this._isAdmin(jid)
	      };
	    }, this);
	    return _.sortBy(participants, ["isAdmin", "name"]);
	  },

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(this.refs.form.getDOMNode()).serializeArray(),
	        submit_data = {
	      room_jid: this.state.activeChat.jid,
	      user_jids: _.pluck(form_inputs, "value")
	    };

	    if (submit_data.user_jids.length) {
	      FormActions.removeUsers(submit_data, this._handleResponse);
	    } else {
	      this._throwFlagError(strings.fail.no_users_flag);
	    }
	    this._closeDialog();
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = Utils.dot(data, "error.text.__text") ? data.error.text.__text : strings.fail.remove_users;
	      this._throwFlagError(error_msg);
	    } else {
	      this._throwFlagSuccess(strings.success.users_removed);
	    }
	  },

	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    FlagActions.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },

	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data("flag-index");
	    FlagActions.removeFlag(flag_index);
	    this._showDialog();
	  },

	  _flagBody: function _flagBody(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._flagActionClick, href: "#" },
	            strings.button.try_again
	          )
	        )
	      )
	    );
	  },

	  _showDialog: function _showDialog() {
	    DialogActions.showRemoveUsersDialog();
	  },

	  _closeDialog: function _closeDialog() {
	    DialogActions.closeDialog();
	  },

	  render: function render() {
	    var sortedParticipants = this._sortParticipants();
	    return React.createElement(
	      "form",
	      { id: "remove-users-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(
	        "div",
	        null,
	        strings.description.choose_people_to_remove
	      ),
	      _.map(sortedParticipants, function (user) {
	        return React.createElement(AuiCheckboxField, { id: user.jid, value: user.jid, label: user.name, disabled: user.isAdmin });
	      }, this)
	    );
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1),
	    AuiInputFieldGroup = __webpack_require__(278),
	    AuiTextAreaFieldGroup = __webpack_require__(277),
	    RoomPrivacyRadios = __webpack_require__(273),
	    FlagActions = __webpack_require__(49),
	    DialogActions = __webpack_require__(28),
	    FormActions = __webpack_require__(50),
	    FormsStore = __webpack_require__(269),
	    Utils = __webpack_require__(4),
	    strings = __webpack_require__(270),
	    FormErrors = __webpack_require__(271);

	module.exports = React.createClass({

	  displayName: "CreateRoomForm",

	  componentDidMount: function componentDidMount() {
	    FormsStore.on("change:allRooms", this._onChange);
	    this._focusInput();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    FormsStore.off("change:allRooms", this._onChange);
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.errors.name) {
	      this.refs.nameField.focus();
	    }
	  },

	  getInitialState: function getInitialState() {
	    return this._getState();
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  _getState: function _getState() {
	    return {
	      allRooms: FormsStore.get("allRooms"),
	      errors: {},
	      room_name: null
	    };
	  },

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(this.refs.form.getDOMNode()).serializeArray(),
	        submit_data = {
	      name: form_inputs[0].value.trim(),
	      topic: form_inputs[1] ? form_inputs[1].value.trim() : "",
	      privacy: form_inputs[2] ? form_inputs[2].value : "public"
	    };

	    var errors = this._validate(submit_data.name);
	    if (errors) {
	      this.setState({
	        errors: errors
	      });
	    } else {
	      this.setState({
	        room_name: submit_data.name
	      });
	      DialogActions.startBtnLoading();
	      FormActions.createRoom(submit_data, this._handleResponse);
	    }
	  },

	  _validate: function _validate(name) {
	    if (!name) {
	      return {
	        name: FormErrors.create_room_form.no_room_name
	      };
	    } else if (name.length > 50) {
	      return {
	        name: FormErrors.create_room_form.name_too_long
	      };
	    } else if (_.find(this.state.allRooms, function (room) {
	      return room.name && room.name.toLowerCase() === name.toLowerCase();
	    })) {
	      return {
	        name: FormErrors.create_room_form.room_already_exists
	      };
	    }
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = Utils.dot(data, "error.text.__text") ? data.error.text.__text : strings.fail.create_room;
	      this._throwFlagError(error_msg);
	    } else {
	      var name = this.state.room_name || "Room";
	      var success_msg = strings.success.room_created(name);
	      this._throwFlagSuccess(success_msg);
	    }
	    this._closeDialog();
	  },

	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    FlagActions.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },

	  _flagBody: function _flagBody(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._flagActionClick, href: "#" },
	            strings.button.try_again
	          )
	        )
	      )
	    );
	  },

	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data("flag-index");
	    FlagActions.removeFlag(flag_index);
	    this._showDialog();
	  },

	  _showDialog: function _showDialog() {
	    DialogActions.showCreateRoomDialog();
	  },

	  _closeDialog: function _closeDialog() {
	    DialogActions.closeDialog();
	  },

	  _focusInput: function _focusInput() {
	    this.refs.form.getDOMNode().querySelector("#create-room-name").focus();
	  },

	  render: function render() {

	    var errors = this.state.errors;

	    return React.createElement(
	      "form",
	      { id: "create-room-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(AuiInputFieldGroup, { disabled: this.props.loading, ref: "nameField", id: "create-room-name", label: strings.label.room_name, maxLength: "50", description: strings.description.create_room_description, error: errors.name }),
	      React.createElement(AuiInputFieldGroup, { disabled: this.props.loading, id: "create-room-topic", label: strings.label.room_topic }),
	      React.createElement(RoomPrivacyRadios, { disabled: this.props.loading, defaultChecked: "public" })
	    );
	  }
	});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Promise = __webpack_require__(69).Promise,
	    AppDispatcher = __webpack_require__(1),
	    RoomPrivacyRadios = __webpack_require__(273),
	    FlagActions = __webpack_require__(49),
	    DialogActions = __webpack_require__(28),
	    FormActions = __webpack_require__(50),
	    strings = __webpack_require__(270),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "RoomPrivacyForm",

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    if (!nextProps.loading) {
	      return true;
	    } else {
	      return false;
	    }
	  },

	  _onSubmit: function _onSubmit(e) {
	    e.preventDefault();
	    var form_inputs = $(this.refs.form.getDOMNode()).serializeArray(),
	        submit_data = {
	      jid: this.props.jid,
	      privacy: form_inputs[0].value
	    };

	    if (submit_data.privacy !== this.props.privacy) {
	      DialogActions.startBtnLoading();
	      FormActions.changeRoomPrivacy(submit_data, this._handleResponse);
	    }
	  },

	  _handleResponse: function _handleResponse(data) {
	    if (data.error) {
	      var error_msg = Utils.dot(data, "error.text.__text") ? data.error.text.__text : strings.fail.change_privacy_flag;
	      this._throwFlagError(error_msg);
	    } else {
	      var privacy = this.props.privacy === "public" ? "private" : "public";
	      var success_msg = strings.success.privacy_changed(this.props.name, privacy);
	      this._throwFlagSuccess(success_msg);
	    }
	    this._closeDialog();
	  },

	  _throwFlagSuccess: function _throwFlagSuccess(msg) {
	    FlagActions.showFlag({
	      type: "success",
	      body: msg,
	      close: "auto"
	    });
	  },

	  _throwFlagError: function _throwFlagError(error) {
	    FlagActions.showFlag({
	      type: "error",
	      body: this._flagBody(error),
	      close: "manual"
	    });
	  },

	  _flagActionClick: function _flagActionClick(e) {
	    e.preventDefault();
	    var flag_index = $(e.target).closest(".flag").data("flag-index");
	    FlagActions.removeFlag(flag_index);
	    this._showDialog();
	  },

	  _flagBody: function _flagBody(error_msg) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "p",
	        { className: "hc-message-body" },
	        error_msg
	      ),
	      React.createElement(
	        "ul",
	        { className: "aui-nav-actions-list" },
	        React.createElement(
	          "li",
	          null,
	          React.createElement(
	            "a",
	            { onClick: this._flagActionClick, href: "#" },
	            strings.button.try_again
	          )
	        )
	      )
	    );
	  },

	  _showDialog: function _showDialog() {
	    DialogActions.showRoomPrivacyDialog({
	      jid: this.props.jid,
	      name: this.props.name,
	      privacy: this.props.privacy
	    });
	  },

	  _closeDialog: function _closeDialog() {
	    DialogActions.closeDialog();
	  },

	  render: function render() {
	    return React.createElement(
	      "form",
	      { id: "room-privacy-form", ref: "form", className: "aui", onSubmit: this._onSubmit },
	      React.createElement(RoomPrivacyRadios, { defaultChecked: this.props.privacy, private_desc: strings.description.privacy })
	    );
	  }
	});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	"use strict";

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if ("production" !== process.env.NODE_ENV) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        'Invariant Violation: ' +
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(297)))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var config = {
	  instrument: false
	};

	function configure(name, value) {
	  if (arguments.length === 2) {
	    config[name] = value;
	  } else {
	    return config[name];
	  }
	}

	exports.config = config;
	exports.configure = configure;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function objectOrFunction(x) {
	  return isFunction(x) || (typeof x === "object" && x !== null);
	}

	function isFunction(x) {
	  return typeof x === "function";
	}

	function isArray(x) {
	  return Object.prototype.toString.call(x) === "[object Array]";
	}

	// Date.now is not available in browsers < IE9
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
	var now = Date.now || function() { return new Date().getTime(); };


	exports.objectOrFunction = objectOrFunction;
	exports.isFunction = isFunction;
	exports.isArray = isArray;
	exports.now = now;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* global toString */

	var isArray = __webpack_require__(241).isArray;
	var isFunction = __webpack_require__(241).isFunction;

	/**
	  Returns a promise that is fulfilled when all the given promises have been
	  fulfilled, or rejected if any of them become rejected. The return promise
	  is fulfilled with an array that gives all the values in the order they were
	  passed in the `promises` array argument.

	  Example:

	  ```javascript
	  var promise1 = RSVP.resolve(1);
	  var promise2 = RSVP.resolve(2);
	  var promise3 = RSVP.resolve(3);
	  var promises = [ promise1, promise2, promise3 ];

	  RSVP.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```

	  If any of the `promises` given to `RSVP.all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:

	  Example:

	  ```javascript
	  var promise1 = RSVP.resolve(1);
	  var promise2 = RSVP.reject(new Error("2"));
	  var promise3 = RSVP.reject(new Error("3"));
	  var promises = [ promise1, promise2, promise3 ];

	  RSVP.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```

	  @method all
	  @for RSVP
	  @param {Array} promises
	  @param {String} label
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	*/
	function all(promises) {
	  /*jshint validthis:true */
	  var Promise = this;

	  if (!isArray(promises)) {
	    throw new TypeError('You must pass an array to all.');
	  }

	  return new Promise(function(resolve, reject) {
	    var results = [], remaining = promises.length,
	    promise;

	    if (remaining === 0) {
	      resolve([]);
	    }

	    function resolver(index) {
	      return function(value) {
	        resolveAll(index, value);
	      };
	    }

	    function resolveAll(index, value) {
	      results[index] = value;
	      if (--remaining === 0) {
	        resolve(results);
	      }
	    }

	    for (var i = 0; i < promises.length; i++) {
	      promise = promises[i];

	      if (promise && isFunction(promise.then)) {
	        promise.then(resolver(i), reject);
	      } else {
	        resolveAll(i, promise);
	      }
	    }
	  });
	}

	exports.all = all;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* global toString */
	var isArray = __webpack_require__(241).isArray;

	/**
	  `RSVP.race` allows you to watch a series of promises and act as soon as the
	  first promise given to the `promises` argument fulfills or rejects.

	  Example:

	  ```javascript
	  var promise1 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve("promise 1");
	    }, 200);
	  });

	  var promise2 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve("promise 2");
	    }, 100);
	  });

	  RSVP.race([promise1, promise2]).then(function(result){
	    // result === "promise 2" because it was resolved before promise1
	    // was resolved.
	  });
	  ```

	  `RSVP.race` is deterministic in that only the state of the first completed
	  promise matters. For example, even if other promises given to the `promises`
	  array argument are resolved, but the first completed promise has become
	  rejected before the other promises became fulfilled, the returned promise
	  will become rejected:

	  ```javascript
	  var promise1 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve("promise 1");
	    }, 200);
	  });

	  var promise2 = new RSVP.Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error("promise 2"));
	    }, 100);
	  });

	  RSVP.race([promise1, promise2]).then(function(result){
	    // Code here never runs because there are rejected promises!
	  }, function(reason){
	    // reason.message === "promise2" because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```

	  @method race
	  @for RSVP
	  @param {Array} promises array of promises to observe
	  @param {String} label optional string for describing the promise returned.
	  Useful for tooling.
	  @return {Promise} a promise that becomes fulfilled with the value the first
	  completed promises is resolved with if the first completed promise was
	  fulfilled, or rejected with the reason that the first completed promise
	  was rejected with.
	*/
	function race(promises) {
	  /*jshint validthis:true */
	  var Promise = this;

	  if (!isArray(promises)) {
	    throw new TypeError('You must pass an array to race.');
	  }
	  return new Promise(function(resolve, reject) {
	    var results = [], promise;

	    for (var i = 0; i < promises.length; i++) {
	      promise = promises[i];

	      if (promise && typeof promise.then === 'function') {
	        promise.then(resolve, reject);
	      } else {
	        resolve(promise);
	      }
	    }
	  });
	}

	exports.race = race;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function resolve(value) {
	  /*jshint validthis:true */
	  if (value && typeof value === 'object' && value.constructor === this) {
	    return value;
	  }

	  var Promise = this;

	  return new Promise(function(resolve) {
	    resolve(value);
	  });
	}

	exports.resolve = resolve;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	  `RSVP.reject` returns a promise that will become rejected with the passed
	  `reason`. `RSVP.reject` is essentially shorthand for the following:

	  ```javascript
	  var promise = new RSVP.Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  Instead of writing the above, your code now simply becomes the following:

	  ```javascript
	  var promise = RSVP.reject(new Error('WHOOPS'));

	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```

	  @method reject
	  @for RSVP
	  @param {Any} reason value that the returned promise will be rejected with.
	  @param {String} label optional string for identifying the returned promise.
	  Useful for tooling.
	  @return {Promise} a promise that will become rejected with the given
	  `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Promise = this;

	  return new Promise(function (resolve, reject) {
	    reject(reason);
	  });
	}

	exports.reject = reject;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
	var browserGlobal = (typeof window !== 'undefined') ? window : {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);

	// node
	function useNextTick() {
	  return function() {
	    process.nextTick(flush);
	  };
	}

	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });

	  return function() {
	    node.data = (iterations = ++iterations % 2);
	  };
	}

	function useSetTimeout() {
	  return function() {
	    local.setTimeout(flush, 1);
	  };
	}

	var queue = [];
	function flush() {
	  for (var i = 0; i < queue.length; i++) {
	    var tuple = queue[i];
	    var callback = tuple[0], arg = tuple[1];
	    callback(arg);
	  }
	  queue = [];
	}

	var scheduleFlush;

	// Decide what async method to use to triggering processing of queued callbacks:
	if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else {
	  scheduleFlush = useSetTimeout();
	}

	function asap(callback, arg) {
	  var length = queue.push([callback, arg]);
	  if (length === 1) {
	    // If length is 1, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    scheduleFlush();
	  }
	}

	exports.asap = asap;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(297)))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "Icon",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      classes: {},
	      iconName: "chat",
	      active: false
	    };
	  },

	  _getClassNames: function _getClassNames() {
	    return _.assign({}, {
	      "aui-icon": true,
	      "hipchat-icon-small": true
	    }, this.props.classes);
	  },

	  render: function render() {
	    var cx = React.addons.classSet;
	    var classNames = this._getClassNames();
	    var iconHtml = "<svg class='" + cx(classNames) + "'><use xlink:href='#icon-" + this.props.iconName + "'></use></svg>";

	    return React.createElement("span", { dangerouslySetInnerHTML: { __html: iconHtml } });
	  }
	});

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  getItem: function getItem(sKey) {
	    if (!sKey) {
	      return null;
	    }
	    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
	  },
	  setItem: function setItem(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
	      return false;
	    }
	    var sExpires = "";
	    if (vEnd) {
	      switch (vEnd.constructor) {
	        case Number:
	          sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	          break;
	        case String:
	          sExpires = "; expires=" + vEnd;
	          break;
	        case Date:
	          sExpires = "; expires=" + vEnd.toUTCString();
	          break;
	      }
	    }
	    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	    return true;
	  },
	  removeItem: function removeItem(sKey, sPath, sDomain) {
	    if (!this.hasItem(sKey)) {
	      return false;
	    }
	    document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
	    return true;
	  },
	  hasItem: function hasItem(sKey) {
	    if (!sKey) {
	      return false;
	    }
	    return new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(document.cookie);
	  },
	  keys: function keys() {
	    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
	    for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
	      aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
	    }
	    return aKeys;
	  }
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  // componentWillReceiveProps: function(nextProps) {
	  //   this.setState(this._getDefaultState(nextProps));
	  //   this._scrollState(this.state.scroll || 0);
	  // },

	  _getDefaultState: function _getDefaultState(props) {
	    var rowHeight = 37;
	    var rowsPerBody = Math.floor((props.height - 2) / rowHeight);
	    return _.merge(props, {
	      total: _.size(props.rows),
	      rows: props.rows,
	      rowHeight: rowHeight,
	      rowsPerBody: rowsPerBody,
	      visibleStart: 0,
	      visibleEnd: rowsPerBody,
	      displayStart: 0,
	      displayEnd: rowsPerBody * 2
	    });
	  },

	  _scrollState: function _scrollState(scroll) {
	    var visibleStart = Math.floor(scroll / this.state.rowHeight);
	    var visibleEnd = Math.min(visibleStart + this.state.rowsPerBody, this.state.total - 1);

	    var displayStart = Math.max(0, Math.floor(scroll / this.state.rowHeight) - this.state.rowsPerBody * 2);
	    var displayEnd = Math.min(displayStart + 4 * this.state.rowsPerBody, this.state.total - 1);

	    this.setState({
	      visibleStart: visibleStart,
	      visibleEnd: visibleEnd,
	      displayStart: displayStart,
	      displayEnd: displayEnd,
	      scroll: scroll
	    });
	  },

	  _onScroll: function _onScroll(event) {
	    this._scrollState(this.refs.scrollable.getDOMNode().scrollTop);
	  }
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var InfiniteScrollChildMixin = __webpack_require__(279);
	var LobbyItem = __webpack_require__(280);

	module.exports = React.createClass({

	  displayName: "LobbyListing",

	  mixins: [InfiniteScrollChildMixin],
	  render: function render() {
	    var itemNodes = {};
	    var items = _.map(this.props.rows);
	    for (var i = this.props.displayStart; i <= this.props.displayEnd; ++i) {
	      var item = items[i];
	      if (item) {
	        itemNodes["row-" + i] = React.createElement(LobbyItem, { item: item, key: item.jid, onChatOpen: this.props.onChatOpen });
	      }
	    }
	    return React.createElement(
	      "table",
	      { className: "aui hc-lobby-list-table" },
	      React.createElement(
	        "tbody",
	        null,
	        React.createElement("tr", { className: "hc-lobby-row-scroll-marker hc-lobby-row-top", style: { height: this.props.displayStart * this.props.rowHeight } }),
	        itemNodes,
	        React.createElement("tr", { className: "hc-lobby-row-scroll-marker hc-lobby-row-bottom", style: { height: (_.size(this.props.rows) - this.props.displayEnd) * this.props.rowHeight - this.props.rowHeight } })
	      )
	    );
	  }
	});

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var AppDispatcher = __webpack_require__(1);
	var Store = __webpack_require__(43);
	var Utils = __webpack_require__(4);

	var LobbyStore = (function (Store) {
	  function LobbyStore() {
	    _classCallCheck(this, LobbyStore);

	    this.data = {
	      all: {},
	      filtered: {},
	      filter: {
	        scope: "all",
	        query: ""
	      }
	    };

	    this.registerListeners();
	  }

	  _inherits(LobbyStore, Store);

	  _prototypeProperties(LobbyStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "updated:roster": function (roster) {
	            _this.handleRosterUpdate(roster);
	          },
	          "updated:allRooms": function (rooms) {
	            _this.handleRoomsUpdate(rooms);
	          },
	          "room-deleted": function (room) {
	            _this.handleRoomDeleted(room.jid);
	          },
	          "filter-lobby": function (filter) {
	            _this.handleFilter(filter);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    assignAndSort: {
	      value: function assignAndSort(items) {
	        return _.indexBy(_.sortBy(_.reject(_.assign(this.data.all, items), function (item) {
	          return !item || item.name === "";
	        }), "name"), "jid");
	      },
	      writable: true,
	      configurable: true
	    },
	    handleFilter: {
	      value: function handleFilter(filter) {

	        var scope = filter.scope || this.data.filter.scope;
	        var query = filter.query === "" ? filter.query : filter.query || this.data.filter.query;
	        var re;
	        if (query) {
	          try {
	            re = new RegExp(query, "i");
	          } catch (e) {
	            re = false;
	          }
	        }
	        function applyQueryFilter(item, re) {
	          if (!re) {
	            return true;
	          }
	          if (re.test(item.name)) {
	            return true;
	          } else {
	            return false;
	          }
	        }

	        var filtered = _.filter(this.data.all, function (item) {
	          if (scope === "rooms") {
	            if (Utils.jid.is_room(item.jid)) {
	              return applyQueryFilter(item, re);
	            } else {
	              return false;
	            }
	          } else if (scope === "people") {
	            if (Utils.jid.is_private_chat(item.jid)) {
	              return applyQueryFilter(item, re);
	            } else {
	              return false;
	            }
	          } else {
	            return applyQueryFilter(item, re);
	          }
	        });
	        this.set({
	          filtered: _.indexBy(filtered, "jid"),
	          filter: {
	            scope: scope || "all",
	            query: query || ""
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRosterUpdate: {
	      value: function handleRosterUpdate(roster) {
	        this.set("all", this.assignAndSort(roster));
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomsUpdate: {
	      value: function handleRoomsUpdate(rooms) {
	        this.set("all", this.assignAndSort(rooms));
	      },
	      writable: true,
	      configurable: true
	    },
	    handleRoomDeleted: {
	      value: function handleRoomDeleted(jid) {
	        delete this.data.all[jid];
	        this.set("all", this.data.all);
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return LobbyStore;
	})(Store);

	module.exports = new LobbyStore();

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  filter_label: "Filter rooms and people",
	  filter: "Filter",
	  all: "All",
	  rooms: "Rooms",
	  people: "People",
	  buttons: {
	    create_room: "Create a room"
	  }
	};

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Person = __webpack_require__(281),
	    RosterEmptyState = __webpack_require__(282),
	    strings = __webpack_require__(283),
	    Utils = __webpack_require__(4),
	    RosterStore = __webpack_require__(91),
	    RightPanelActions = __webpack_require__(284);

	module.exports = React.createClass({

	  displayName: "RightSideBarRoster",

	  getInitialState: function getInitialState() {
	    return {
	      selectedPerson: false
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var size = 0;

	    var members = Utils.dot(this.props, "participants.members");
	    if (members) {
	      size = members.length;
	    }

	    var id = RosterStore.get("active_chat");
	    RightPanelActions.rosterMounted({ id: id, size: size });
	  },

	  _onClick: function _onClick(jid) {
	    this.setState({
	      selectedPerson: jid
	    });
	  },

	  _showEmptyState: function _showEmptyState() {
	    var current_user_jid = this.props.current_user_jid,
	        members = this.props.participants.members,
	        guests = this.props.participants.guests,
	        result;

	    if (members.length === 1 && !guests.length) {
	      result = _.findWhere(members, { jid: current_user_jid });
	    } else if (guests.length === 1 && !members.length) {
	      result = _.findWhere(guests, { jid: current_user_jid });
	    }
	    return result ? true : false;
	  },

	  _isAdmin: function _isAdmin(user) {
	    return Utils.user.is_admin(this.props.admins, false, user);
	  },

	  _hasMembersAndGuests: function _hasMembersAndGuests() {
	    return this.props.participants.members && this.props.participants.members.length && this.props.participants.guests && this.props.participants.guests.length;
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        rosterClasses = cx({
	      "hc-roster": true,
	      "hc-sidebar-scroll": true
	    }),
	        guest_url_message;

	    if (this.props.guest_url) {
	      guest_url_message = React.createElement(
	        "div",
	        { className: "guest-access" },
	        React.createElement(
	          "strong",
	          null,
	          strings.guest_access_enabled
	        ),
	        React.createElement("br", null),
	        React.createElement(
	          "a",
	          { href: this.props.guest_url, target: "_blank" },
	          this.props.guest_url
	        )
	      );
	    }

	    return React.createElement(
	      "div",
	      { className: (this.props.guest_url ? "guest-access-enabled " : "") + "roster-wrap" },
	      React.createElement(
	        "div",
	        { className: rosterClasses },
	        React.createElement("div", { id: "hc-status-tooltip" }),
	        _.map(["members", "guests"], function (groupName) {
	          return this.props.participants[groupName] && this.props.participants[groupName].length ? React.createElement(
	            "ul",
	            { className: "aui-nav aui-navgroup-vertical", key: "RosterItem" + groupName, "data-skate-ignore": true },
	            this._hasMembersAndGuests() ? React.createElement(
	              "li",
	              { className: "aui-nav-heading" },
	              React.createElement(
	                "strong",
	                { className: "uppercase" },
	                strings[groupName]
	              )
	            ) : React.createElement("div", null),
	            _.map(this.props.participants[groupName], function (user, jid) {
	              return React.createElement(Person, { key: jid, user: user, onChatOpen: this.props.onChatOpen, active: this.state.selectedPerson === user.jid, isAdmin: this._isAdmin(user), onPersonClick: this._onClick });
	            }, this)
	          ) : _.noop(groupName);
	        }, this),
	        this._showEmptyState() ? React.createElement(RosterEmptyState, { room_privacy: this.props.active_chat_privacy, users: this.props.users, isAdmin: this._isAdmin(this.props.users[this.props.current_user_jid]) }) : ""
	      ),
	      guest_url_message
	    );
	  }
	});

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var File = __webpack_require__(285),
	    Utils = __webpack_require__(4),
	    EmptyState = __webpack_require__(286),
	    RightPanelActions = __webpack_require__(284);

	module.exports = React.createClass({

	  displayName: "RightSideBarFiles",

	  componentDidMount: function componentDidMount() {
	    var size = 0;
	    if (this.props.files) {
	      size = this.props.files.length;
	    }
	    RightPanelActions.filesMounted({ id: _.uniqueId(), size: size });
	  },

	  _getFile: function _getFile(file) {
	    var time = Utils.format_time(file.date, this.props.use24hrTime);

	    return React.createElement(File, { key: file.id, file: file, time: time });
	  },

	  _filesBody: function _filesBody() {
	    var filesBody = _.map(this.props.files, function (file) {
	      return this._getFile(file);
	    }, this);

	    return React.createElement(
	      "ul",
	      { className: "aui-nav aui-navgroup-vertical", "data-skate-ignore": true },
	      filesBody
	    );
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        fileClasses = cx({
	      "hc-files": true,
	      "hc-sidebar-scroll": true
	    }),
	        files_display = _.isEmpty(this.props.files) ? React.createElement(EmptyState, null) : this._filesBody();

	    return React.createElement(
	      "div",
	      { className: fileClasses },
	      files_display
	    );
	  }
	});

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Link = __webpack_require__(287),
	    Utils = __webpack_require__(4),
	    EmptyState = __webpack_require__(288);

	module.exports = React.createClass({

	  displayName: "RightSideBarLinks",

	  _getLink: function _getLink(link) {
	    var time = Utils.format_time(link.date, this.props.use24hrTime);

	    return React.createElement(Link, { key: link.id, name: link.user_name, url: link.url, users: this.props.users, time: time, display_url: link.display_url });
	  },

	  _linksBody: function _linksBody() {
	    var _this = this;

	    var linksBody = _.map(this.props.links, function (link) {
	      return _this._getLink(link);
	    });

	    return React.createElement(
	      "ul",
	      { className: "aui-nav aui-navgroup-vertical", "data-skate-ignore": true },
	      linksBody
	    );
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        linkClasses = cx({
	      "hc-links": true,
	      "hc-sidebar-scroll": true,
	      "hc-bg-striped": !_.isEmpty(this.props.links)
	    }),
	        links_display = _.isEmpty(this.props.links) ? React.createElement(EmptyState, null) : this._linksBody();

	    return React.createElement(
	      "div",
	      { className: linkClasses },
	      links_display
	    );
	  }
	});

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomDropDown = __webpack_require__(289),
	    CurrentUserStore = __webpack_require__(71),
	    RosterStore = __webpack_require__(91),
	    Utils = __webpack_require__(4),
	    AppStore = __webpack_require__(2),
	    ClientPreferencesStore = __webpack_require__(38),
	    strings = __webpack_require__(260);

	module.exports = React.createClass({

	  displayName: "RoomActions",

	  componentDidMount: function componentDidMount() {
	    ClientPreferencesStore.on(["change"], this._onChange);
	    CurrentUserStore.on(["change"], this._onChange);
	    this._createTooltip();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    ClientPreferencesStore.off(["change"], this._onChange);
	    CurrentUserStore.off(["change"], this._onChange);
	    this._destroyTooltip();
	  },

	  getInitialState: function getInitialState() {
	    return this._getState();
	  },

	  _getState: function _getState() {
	    return {
	      chat_show_sidebar: ClientPreferencesStore.shouldShowChatSidebar(),
	      groupchat_show_sidebar: ClientPreferencesStore.shouldShowGroupChatSidebar(),
	      current_user: CurrentUserStore.get("user")
	    };
	  },

	  _onChange: function _onChange() {
	    this.setState(this._getState());
	  },

	  _isAdmin: function _isAdmin() {
	    return Utils.user.is_admin(this.props.info.admins, this.props.info.owner, this.state.current_user);
	  },

	  render: function render() {

	    var buttonsMarkup = {

	      groupchat: React.createElement(
	        "div",
	        { className: "aui-page-header-actions hc-chat-header-actions" },
	        React.createElement(
	          "div",
	          { className: "aui-buttons" },
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-light " + (this.props.groupchat_active_panel == "roster" && this.state.groupchat_show_sidebar ? "active" : ""),
	              onClick: this.props.onPanelSelect.bind(null, "roster"),
	              title: this.state.groupchat_show_sidebar ? this.props.groupchat_active_panel == "roster" ? strings.hide_people : strings.people : strings.show_people },
	            React.createElement(
	              "span",
	              { className: "aui-icon aui-icon-small aui-iconfont-user" },
	              strings.people
	            )
	          ),
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-light " + (this.props.groupchat_active_panel == "files" && this.state.groupchat_show_sidebar ? "active" : ""),
	              onClick: this.props.onPanelSelect.bind(null, "files"),
	              title: this.state.groupchat_show_sidebar ? this.props.groupchat_active_panel == "files" ? strings.hide_files : strings.files : strings.show_files },
	            React.createElement(
	              "span",
	              { className: "aui-icon hipchat-icon-small icon-file" },
	              strings.files
	            )
	          ),
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-light " + (this.props.groupchat_active_panel == "links" && this.state.groupchat_show_sidebar ? "active" : ""),
	              onClick: this.props.onPanelSelect.bind(null, "links"),
	              title: this.state.groupchat_show_sidebar ? this.props.groupchat_active_panel == "links" ? strings.hide_links : strings.links : strings.show_links },
	            React.createElement(
	              "span",
	              { className: "aui-icon hipchat-icon-small icon-link" },
	              strings.links
	            )
	          ),
	          React.createElement(
	            "button",
	            { id: "room-actions-btn", className: "aui-button aui-button-light aui-dropdown2-trigger aui-dropdown2-trigger-arrowless", "aria-owns": "room-actions-drop-down", "aria-controls": "room-actions-drop-down", "aria-haspopup": "true", title: strings.room_actions },
	            React.createElement(
	              "span",
	              { className: "aui-icon aui-icon-small aui-iconfont-more" },
	              strings.room_actions
	            )
	          )
	        ),
	        React.createElement(RoomDropDown, {
	          roomId: this.props.info.id,
	          triggerId: "room-actions-btn",
	          isAdmin: this._isAdmin(),
	          privacy: this.props.info.privacy,
	          room: this.props.info })
	      ),

	      chat: React.createElement(
	        "div",
	        { className: "aui-page-header-actions hc-chat-header-actions" },
	        React.createElement(
	          "div",
	          { className: "aui-buttons" },
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-light " + (this.props.chat_active_panel == "files" && this.state.chat_show_sidebar ? "active" : ""),
	              onClick: this.props.onPanelSelect.bind(null, "files"),
	              title: this.state.chat_show_sidebar ? this.props.chat_active_panel == "files" ? strings.hide_files : strings.files : strings.show_files },
	            React.createElement(
	              "span",
	              { className: "aui-icon hipchat-icon-small icon-file" },
	              strings.files
	            )
	          ),
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-light " + (this.props.chat_active_panel == "links" && this.state.chat_show_sidebar ? "active" : ""),
	              onClick: this.props.onPanelSelect.bind(null, "links"),
	              title: this.state.chat_show_sidebar ? this.props.chat_active_panel == "links" ? strings.hide_links : strings.links : strings.show_links },
	            React.createElement(
	              "span",
	              { className: "aui-icon hipchat-icon-small icon-link" },
	              strings.links
	            )
	          )
	        )
	      ),

	      none: React.createElement("div", null)

	    };

	    return buttonsMarkup[this.props.type] || buttonsMarkup.none;
	  },

	  _createTooltip: function _createTooltip() {
	    AJS.$(".hc-chat-header-actions button").tooltip();
	  },

	  _destroyTooltip: function _destroyTooltip() {
	    AJS.$(".hc-chat-header-actions button").off();
	  }

	});

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomActions = __webpack_require__(256),
	    PresenceIcon = __webpack_require__(118),
	    Icon = __webpack_require__(247),
	    strings = __webpack_require__(260),
	    Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "OTOHeader",

	  _getAvatarStyle: function _getAvatarStyle() {
	    return {
	      backgroundImage: "url(" + this.props.info.photo_large + ")"
	    };
	  },

	  _getTitle: function _getTitle() {
	    var classes,
	        title = React.createElement("span", null);
	    if (this.props.info.title) {
	      classes = {
	        "hc-separator-icon": true
	      };
	      title = React.createElement(
	        "span",
	        { className: "hc-oto-header-title" },
	        React.createElement(Icon, { classes: classes, iconName: "dot" }),
	        this.props.info.title
	      );
	    }
	    return title;
	  },

	  _getHeaderIcon: function _getHeaderIcon() {
	    var icon,
	        avatarStyle = this._getAvatarStyle();
	    if (!this.props.info.photo_large || /\/img\/silhouette_125\.png/.test(this.props.info.photo_large)) {
	      icon = React.createElement("span", { className: "aui-icon hc-priv-chat hc-user-silhouette" });
	    } else {
	      icon = React.createElement("span", { className: "aui-icon hc-priv-chat hc-user-avatar", style: avatarStyle });
	    }
	    return icon;
	  },

	  _getStatus: function _getStatus() {
	    var status;
	    if (this.props.info.loading_profile) {
	      status = strings.loading;
	    } else {
	      status = this.props.info.presence.status || Utils.user.chat_header_status(this.props.info.presence.show);
	    }
	    return status;
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        hiddenClasses = cx({
	      hidden: this.props.info.loading_profile
	    }),
	        mentionClasses = cx({
	      hidden: this.props.info.loading_profile,
	      "mention-name": true
	    }),
	        title = this._getTitle(),
	        headerIcon = this._getHeaderIcon(),
	        status = this._getStatus();

	    return React.createElement(
	      "div",
	      { className: "aui-page-header-inner hc-priv-chat" },
	      React.createElement(
	        "div",
	        { className: "page-header-icon" },
	        headerIcon
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-page-header-main hc-page-header-main" },
	        React.createElement(
	          "h3",
	          null,
	          this.props.info.name
	        ),
	        " ",
	        React.createElement(
	          "span",
	          { className: mentionClasses },
	          "(@" + this.props.info.mention_name + ")"
	        ),
	        React.createElement(
	          "p",
	          null,
	          React.createElement(PresenceIcon, { presence: this.props.info.presence.show }),
	          React.createElement(
	            "span",
	            { className: "hc-oto-header" },
	            status
	          ),
	          React.createElement(
	            "span",
	            { className: hiddenClasses },
	            React.createElement(Icon, { classes: { "hc-separator-icon": true }, iconName: "dot" }),
	            React.createElement(
	              "span",
	              null,
	              this.props.info.time
	            ),
	            title,
	            React.createElement(
	              "span",
	              null,
	              React.createElement(Icon, { classes: { "hc-separator-icon": true }, iconName: "dot" }),
	              React.createElement(
	                "a",
	                { href: "mailto:" + this.props.info.email },
	                this.props.info.email
	              )
	            )
	          )
	        )
	      ),
	      React.createElement(RoomActions, { info: this.props.info, type: this.props.type, chat_active_panel: this.props.chat_active_panel, onPanelSelect: this.props.onPanelSelect })
	    );
	  }

	});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomActions = __webpack_require__(256),
	    TopicInput = __webpack_require__(259),
	    ChatHeaderActions = __webpack_require__(45),
	    Utils = __webpack_require__(4),
	    strings = __webpack_require__(260);

	module.exports = React.createClass({

	  displayName: "GroupChatHeader",

	  _getTopic: function _getTopic() {
	    var topic;
	    if (this.props.topic_editing) {
	      topic = this._getTopicInput();
	    } else {
	      topic = this._getTopicText();
	    }
	    return topic;
	  },

	  _getTopicInput: function _getTopicInput() {
	    return React.createElement(TopicInput, { jid: this.props.info.jid, topic_input_value: this.props.topic_input_value });
	  },

	  _getTopicText: function _getTopicText() {
	    var topic, escapedTopic;
	    if (this.props.info.topic) {
	      escapedTopic = Utils.escapeAndLinkify(this.props.info.topic, {
	        escape_whitespace: true,
	        do_word_breaks: false,
	        do_emoticons: this.props.do_emoticons
	      });
	      topic = React.createElement("p", { title: this.props.info.topic, onDoubleClick: this._onTopicDoubleClick, dangerouslySetInnerHTML: { __html: "<span>" + escapedTopic + "</span>" } });
	    } else {
	      topic = React.createElement(
	        "i",
	        { onDoubleClick: this._onTopicDoubleClick },
	        strings.default_topic
	      );
	    }
	    return topic;
	  },

	  _onTopicDoubleClick: function _onTopicDoubleClick() {
	    ChatHeaderActions.handleTopicDoubleClick();
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        iconClasses = cx({
	      "aui-icon": true,
	      "hipchat-icon-huge": true,
	      "icon-private": this.props.info.privacy === "private",
	      "icon-public": this.props.info.privacy === "public",
	      "icon-dot": !this.props.info.privacy
	    }),
	        topic = this._getTopic();

	    return React.createElement(
	      "div",
	      { className: "aui-page-header-inner hc-groupchat" },
	      React.createElement(
	        "div",
	        { className: "page-header-icon" },
	        React.createElement("span", { className: iconClasses })
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-page-header-main hc-page-header-main" },
	        React.createElement(
	          "h3",
	          null,
	          this.props.info.name
	        ),
	        React.createElement("br", null),
	        topic
	      ),
	      React.createElement(RoomActions, { info: this.props.info, type: this.props.type, groupchat_active_panel: this.props.groupchat_active_panel, onPanelSelect: this.props.onPanelSelect })
	    );
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ChatHeaderActions = __webpack_require__(45),
	    PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "TopicInput",

	  mixins: [PureRenderMixin],

	  componentDidMount: function componentDidMount() {
	    this.refs.topicInput.getDOMNode().select();
	  },

	  _handleTopicSubmit: function _handleTopicSubmit(e) {
	    e.preventDefault();
	    this._setTopic();
	  },

	  _onKeydown: function _onKeydown(evt) {
	    if (evt.keyCode === 27) {
	      this._dismissTopicEdit();
	    }
	  },

	  _onKeyPressCancel: function _onKeyPressCancel(e) {
	    if (e.keyCode === 13) {
	      this._dismissTopicEdit();
	    }
	  },

	  _onBlur: function _onBlur(e) {
	    var $relatedTarget = $(e.relatedTarget);
	    var $form = $(this.refs.topicForm.getDOMNode());
	    var containsRelatedTarget = $form.has($relatedTarget).length > 0;
	    if (containsRelatedTarget && ($relatedTarget.is(".aui-button") || $relatedTarget.is(".topic-edit-input"))) {
	      e.preventDefault();
	    } else {
	      this._dismissTopicEdit();
	    }
	  },

	  _onValueChange: function _onValueChange(evt) {
	    ChatHeaderActions.setInputValue({
	      text: evt.target.value
	    });
	  },

	  _setTopic: function _setTopic() {
	    var data = {
	      jid: this.props.jid,
	      topic: this.props.topic_input_value
	    };
	    ChatHeaderActions.changeTopic(data);
	  },

	  _dismissTopicEdit: function _dismissTopicEdit() {
	    ChatHeaderActions.dismissTopicEdit();
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        inputClasses = cx({
	      text: true,
	      "topic-edit-input": true
	    });

	    return React.createElement(
	      "form",
	      { ref: "topicForm", className: "aui", onSubmit: this._handleTopicSubmit, onKeyDown: this._onKeydown },
	      React.createElement("input", { type: "text",
	        ref: "topicInput",
	        className: inputClasses,
	        value: this.props.topic_input_value,
	        onBlur: this._onBlur,
	        onChange: this._onValueChange }),
	      React.createElement(
	        "button",
	        { type: "submit", className: "aui-button", onBlur: this._onBlur },
	        React.createElement(
	          "span",
	          { className: "aui-icon aui-icon-small aui-iconfont-success" },
	          "Success "
	        )
	      ),
	      React.createElement(
	        "button",
	        { type: "button", className: "aui-button", onBlur: this._onBlur, onKeyDown: this._onKeyPressCancel, onClick: this._dismissTopicEdit },
	        React.createElement(
	          "span",
	          { className: "aui-icon hipchat-icon-xsmall hc-close-icon icon-close" },
	          "Close "
	        )
	      )
	    );
	  }
	});

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  default_topic: "This is the room topic. Double click to change it.",
	  loading: "Loading…",
	  beta: function beta(feature) {
	    return "Still baking! The " + feature + " feature is not in the beta, but will be soon.";
	  },
	  integrations: "Integrations…",
	  create_new_room: "Create New Room…",
	  invite_users: "Invite Users…",
	  remove_users: "Remove Users…",
	  disable_guest: "Disable Guest Access…",
	  guest_enabled: "Guest Access Enabled",
	  guest_disabled: "Guest Access Disabled",
	  enable_guest: "Enable Guest Access…",
	  archive: "Archive",
	  unarchive: "Unarchive",
	  change_topic: "Change Topic",
	  change_privacy: "Change Privacy",
	  "delete": "Delete",
	  rename: "Rename",
	  files: "Files",
	  links: "Links",
	  people: "People",
	  room_actions: "Room actions",
	  show_people: "Show people",
	  hide_people: "Hide people",
	  show_files: "Show files",
	  hide_files: "Hide files",
	  show_links: "Show links",
	  hide_links: "Hide links"
	};

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ChatInputStore = __webpack_require__(290);
	var ChatInputActions = __webpack_require__(46);
	var MentionAutoComplete = __webpack_require__(291);
	var EmoticonAutoComplete = __webpack_require__(292);
	var Tooltip = __webpack_require__(293);
	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);
	var appConfig = __webpack_require__(3);

	var getInputState = function getInputState() {
	  return ChatInputStore.getAll();
	};

	var lastPosn = 0;

	function getSelection() {
	  var hasText = false;
	  if (typeof window.getSelection !== "undefined") {
	    hasText = window.getSelection().toString();
	  } else if (typeof document.selection !== "undefined" && document.selection.type == "Text") {
	    hasText = document.selection.createRange().text;
	  }

	  return hasText;
	}

	function onDocClick(evt) {
	  if (!$(evt.target).is(".hc-ac-name, #hc-message-input")) {
	    ChatInputStore.set({
	      mention_text: "",
	      emoticon_text: ""
	    });
	  }
	}

	module.exports = React.createClass({

	  displayName: "ChatInput",

	  getInitialState: function getInitialState() {
	    return getInputState();
	  },

	  componentDidMount: function componentDidMount() {
	    document.addEventListener("dragenter", this._handleDragEnter);
	    document.addEventListener("dragover", this._handleDragEnter);
	    document.addEventListener("drop", this._handleDrop);
	    document.addEventListener("click", this._focusIfAllowed);
	    ChatInputStore.on("change", this._onChange);
	    AppDispatcher.register("application-focused", this._focus);
	    AppDispatcher.register("select-room", this._focus);
	    AppDispatcher.register("upload-failed", this._handleUploadFailed);
	    this._debouncedOnCaretUpdate = _.debounce(this._onCaretUpdate, 20, { leading: true, trailing: true });
	    this._debouncedWindowResize = _.debounce(function () {
	      return $(window).trigger("resize");
	    }, 100, { leading: true, trailing: false });
	    this._mentionText = "";
	    this._preMention = "";
	    this._postMention = "";
	    this._emoticonText = "";
	    this._preEmoticon = "";
	    this._postEmoticon = "";
	    this._composing_timer = 0;
	    this._active_autocomplete_type = null;
	    this._focus();
	    $(this.refs.message.getDOMNode()).autosize({
	      append: false
	    });
	    $(document).on("click", onDocClick);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this._debouncedOnCaretUpdate.cancel();
	    this._debouncedWindowResize.cancel();
	    document.removeEventListener("dragenter", this._handleDragEnter);
	    document.removeEventListener("dragover", this._handleDragEnter);
	    document.removeEventListener("drop", this._handleDrop);
	    document.removeEventListener("click", this._focusIfAllowed);
	    ChatInputStore.off("change", this._onChange);
	    AppDispatcher.unregister("application-focused", this._focus);
	    AppDispatcher.unregister("select-room", this._focus);
	    AppDispatcher.unregister("upload-failed", this._handleUploadFailed);
	    $(this.refs.message.getDOMNode()).trigger("autosize.destroy");
	    $(document).off("click", onDocClick);
	  },

	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (this.state.active_chat !== nextState.active_chat) {
	      this._isPrivateChat = Utils.jid.is_private_chat(nextState.active_chat);
	    }
	  },

	  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	    if (typeof this.state.new_caret_position !== "undefined" && this.state.new_caret_position !== prevState.new_caret_position) {
	      Utils.setCaretPosition(this.refs.message.getDOMNode(), this.state.new_caret_position);
	    }
	    $(this.refs.message.getDOMNode()).trigger("autosize.resize");
	    this._debouncedWindowResize();
	  },

	  render: function render() {
	    var cx = React.addons.classSet,
	        fileInputIconClasses = cx({
	      "aui-icon": true,
	      "hipchat-icon-small": true,
	      "hc-file-icon": true
	    }),
	        fileIcon;

	    if (this.state.file_name) {
	      fileIcon = Utils.file.get_icon_class(this.state.file_name);
	    } else {
	      fileIcon = "icon-attachment";
	    }

	    return React.createElement(
	      "form",
	      { className: "aui" },
	      React.createElement(
	        "table",
	        { width: "100%", height: "100%", cellSpacing: "0" },
	        React.createElement(
	          "tbody",
	          null,
	          React.createElement(
	            "tr",
	            null,
	            React.createElement(
	              "div",
	              { className: "tipsy aui-form-notification-tooltip aui-form-notification-tooltip-error tipsy-s " + (this.state.file_error ? "" : "transparent"), role: "tooltip" },
	              React.createElement("div", { className: "tipsy-arrow tipsy-arrow-s" }),
	              React.createElement(
	                "div",
	                { className: "tipsy-inner" },
	                this.state.file_error_message
	              )
	            ),
	            React.createElement(
	              "td",
	              { width: "1%", height: "100%" },
	              React.createElement(
	                "div",
	                { className: "aui-button hc-attach-container" },
	                React.createElement(
	                  "a",
	                  { className: "hc-attach", onClick: this._openFilePicker },
	                  React.createElement(
	                    "span",
	                    { className: fileInputIconClasses + " " + fileIcon },
	                    "Attachment"
	                  )
	                ),
	                React.createElement("input", { className: "hidden", ref: "fileInput", type: "file", id: "fileInput", onChange: this._onFileChosen, multiple: "false" }),
	                React.createElement(
	                  "div",
	                  { className: "upload-input " + (this.state.attachment_expanded ? "" : "hidden") },
	                  React.createElement("input", { type: "text", value: this.state.file_name,
	                    onClick: this._onFileNameClick,
	                    onChange: this._onFileNameChange,
	                    className: (this.state.uploading ? "hidden " : " ") + (this.state.file_error ? "error" : ""),
	                    onKeyDown: this._onKeydown }),
	                  React.createElement(
	                    "a",
	                    { className: "close-upload " + (this.state.uploading ? "hidden" : ""), onClick: this._closeAttachmentInput },
	                    React.createElement("span", { className: "aui-icon hipchat-icon-small hc-close-icon icon-close" })
	                  ),
	                  React.createElement(
	                    "div",
	                    { id: "upload-progress-bar", className: "aui-progress-indicator " + (this.state.uploading ? "" : "hidden") },
	                    React.createElement("span", { className: "aui-progress-indicator-value" })
	                  )
	                ),
	                React.createElement(Tooltip, { type: "upload_preview" })
	              )
	            ),
	            React.createElement(
	              "td",
	              null,
	              React.createElement(
	                "div",
	                { className: "hc-textwrapper hc-text-input" },
	                React.createElement("textarea", { id: "hc-message-input",
	                  className: "mousetrap textarea hc-textarea",
	                  onChange: this._onValueChange,
	                  onKeyDown: this._onKeydown,
	                  onKeyUp: this._debouncedOnCaretUpdate,
	                  onClick: this._debouncedOnCaretUpdate,
	                  onPaste: this._onPaste,
	                  value: this.state.text,
	                  ref: "message" }),
	                React.createElement(MentionAutoComplete, { ref: "mentionAC",
	                  mention_text: this.state.mention_text,
	                  textarea_ref: this.refs.message,
	                  selected_item: this.state.mention_selected_item,
	                  onMentionSelected: this._onMentionSelected,
	                  updateMentionResultsCount: this._updateMentionsResultsCount }),
	                React.createElement(EmoticonAutoComplete, { ref: "emoticonAC",
	                  emoticon_text: this.state.emoticon_text,
	                  textarea_ref: this.refs.message,
	                  selected_item: this.state.emoticon_selected_item,
	                  onEmoticonSelected: this._onEmoticonSelected,
	                  updateEmoticonResultsCount: this._updateEmoticonResultsCount }),
	                React.createElement(
	                  "div",
	                  { className: "smiley-icon", onClick: this._onSmileyClick },
	                  React.createElement(
	                    "span",
	                    { className: "aui-icon hipchat-icon-small icon-emoticon" },
	                    "Emoticons"
	                  ),
	                  React.createElement(Tooltip, { type: "smiley_selector" })
	                )
	              )
	            )
	          )
	        )
	      )
	    );
	  },

	  _onChange: function _onChange(evt) {
	    this._debouncedOnCaretUpdate(evt);
	    this.setState(getInputState());
	  },

	  _onCaretUpdate: function _onCaretUpdate(evt) {
	    if (this.state.chat_type === "chat") {
	      this._shouldSendChatStateMessage(evt);
	    }
	    var node = this.refs.message.getDOMNode(),
	        caretPosn = Utils.getCaretPosition(node),
	        msgText = node.value;
	    if (caretPosn === lastPosn) {
	      return;
	    }lastPosn = caretPosn;
	    this._processEmoticonText(msgText, caretPosn);
	    if (!this._isPrivateChat) {
	      this._processMentionText(msgText, caretPosn);
	    }
	  },

	  _processMentionText: function _processMentionText(msgText, caretPosn) {
	    if (this._active_autocomplete_type === "emoticon") {
	      return;
	    }this._preMention = msgText.substring(0, caretPosn);
	    this._postMention = msgText.substring(caretPosn);
	    this._mentionText = this._preMention.split(/[^@a-zA-Z0-9]+/).slice(-1)[0];
	    if (this._mentionText.indexOf("@") === 0) {
	      ChatInputStore.set({
	        mention_text: this._mentionText,
	        mention_selected_item: 0
	      });
	      this._active_autocomplete_type = "mention";
	    } else {
	      this._mentionText = "";
	      ChatInputStore.set({
	        mention_text: "",
	        mention_selected_item: 0,
	        mention_results_count: 0
	      });
	      this._active_autocomplete_type = null;
	    }
	  },

	  _processEmoticonText: function _processEmoticonText(msgText, caretPosn) {
	    if (this._active_autocomplete_type === "mention") {
	      return;
	    }this._preEmoticon = msgText.substring(0, caretPosn);
	    this._postEmoticon = msgText.substring(caretPosn);
	    this._emoticonText = this._preEmoticon.split(/[^\(a-zA-Z0-9\-\:'=]+/).slice(-1)[0];
	    if (this._emoticonText.indexOf("(") === 0 && this._emoticonText !== "(") {
	      ChatInputStore.set({
	        emoticon_text: this._emoticonText,
	        emoticon_selected_item: 0
	      });
	      this._active_autocomplete_type = "emoticon";
	    } else {
	      this._emoticonText = "";
	      ChatInputStore.set({
	        emoticon_text: "",
	        emoticon_selected_item: 0,
	        emoticon_results_count: 0
	      });
	      this._active_autocomplete_type = null;
	    }
	  },

	  _onMentionSelected: function _onMentionSelected(user) {
	    var newPre = this._preMention.slice(0, -this._mentionText.length) + "@" + user.mention_name + " ",
	        firstSpace = this._postMention.indexOf(" "),
	        newPost = this._postMention;
	    if (firstSpace !== 0) {
	      newPost = this._postMention.slice(firstSpace + 1);
	    }
	    ChatInputStore.set({
	      text: newPre + newPost,
	      mention_text: "",
	      mention_selected_item: 0,
	      new_caret_position: newPre.length
	    });
	    this._active_autocomplete_type = null;
	  },

	  _onEmoticonSelected: function _onEmoticonSelected(emoticon) {
	    var newPre = this._preEmoticon.slice(0, -this._emoticonText.length) + emoticon.shortcut + " ",
	        firstSpace = this._postEmoticon.indexOf(" "),
	        newPost = this._postEmoticon;
	    if (firstSpace !== 0) {
	      newPost = this._postEmoticon.slice(firstSpace + 1);
	    }
	    ChatInputStore.set({
	      text: newPre + newPost,
	      emoticon_text: "",
	      emoticon_selected_item: 0,
	      new_caret_position: newPre.length
	    });
	    this._active_autocomplete_type = null;
	  },

	  _onKeydown: function _onKeydown(evt) {
	    if (this._active_autocomplete_type) {
	      var $node = $(this.refs[this._active_autocomplete_type + "AC"].getDOMNode());
	      if ($node.find(".aui-inline-dialog.show").length) {
	        var parentContainer = $node.find(".aui-inline-dialog-contents.contents").get(0),
	            tempObj = {};

	        // up
	        if (evt.keyCode === 38) {
	          var selectedItem = ChatInputStore.get(this._active_autocomplete_type + "_selected_item");
	          if (selectedItem > 0) {
	            tempObj[this._active_autocomplete_type + "_selected_item"] = selectedItem - 1;
	            ChatInputStore.set(tempObj);
	            Utils.scrollIntoViewIfNeeded($node.find("li.hc-autocomplete-item-selected").prev().get(0), parentContainer, false);
	          } else {
	            tempObj[this._active_autocomplete_type + "_selected_item"] = ChatInputStore.get(this._active_autocomplete_type + "_results_count") - 1;
	            ChatInputStore.set(tempObj);
	            Utils.scrollIntoViewIfNeeded($node.find("li.hc-autocomplete-item").last().get(0), parentContainer, false);
	          }
	          evt.preventDefault();
	        }
	        // down
	        if (evt.keyCode === 40) {
	          var selectedItem = ChatInputStore.get(this._active_autocomplete_type + "_selected_item");
	          if (selectedItem < ChatInputStore.get(this._active_autocomplete_type + "_results_count") - 1) {
	            tempObj[this._active_autocomplete_type + "_selected_item"] = selectedItem + 1;
	            ChatInputStore.set(tempObj);
	            Utils.scrollIntoViewIfNeeded($node.find("li.hc-autocomplete-item-selected").next().get(0), parentContainer, false);
	          } else {
	            tempObj[this._active_autocomplete_type + "_selected_item"] = 0;
	            ChatInputStore.set(tempObj);
	            Utils.scrollIntoViewIfNeeded($node.find("li.hc-autocomplete-item").first().get(0), parentContainer, false);
	          }
	          evt.preventDefault();
	        }
	        // tab or enter
	        if (evt.keyCode === 9 || evt.keyCode === 13) {
	          this.refs[this._active_autocomplete_type + "AC"].refs.acBox.refs["item-" + ChatInputStore.get(this._active_autocomplete_type + "_selected_item")]._selectItem();
	          evt.preventDefault();
	          return;
	        }
	      }
	    }
	    // escape
	    if (evt.keyCode === 27) {
	      ChatInputStore.set({
	        mention_text: "",
	        emoticon_text: ""
	      });
	      this._active_autocomplete_type = null;
	      evt.preventDefault();
	    }
	    if (evt.keyCode === 13 && !evt.shiftKey) {
	      evt.preventDefault();
	      if (!this.state.uploading) {
	        if (this.state.attachment_expanded && !this.state.file_error) {
	          ChatInputActions.uploadFile({
	            file: this.state.file,
	            fileName: this.state.file_name,
	            progressBarSelector: "#upload-progress-bar",
	            jid: this.state.active_chat,
	            desc: this.state.text
	          });
	          ChatInputActions.closeTooltip({ type: "upload_preview" });
	          this.refs.fileInput.getDOMNode().value = "";
	        } else if (this.state.text.trim().length) {
	          clearTimeout(this._composing_timer);
	          this._composing_timer = 0;
	          if (this.state.text.match(/^\/clear$/)) {
	            ChatInputActions.clearChat({
	              jid: this.state.active_chat
	            });
	          } else {
	            ChatInputActions.sendMessage({
	              text: this.state.text,
	              jid: this.state.active_chat,
	              id: this.state.message_id
	            });
	          }
	        }
	      }
	    }
	  },

	  _updateMentionsResultsCount: function _updateMentionsResultsCount(count) {
	    ChatInputStore.set({ mention_results_count: count });
	  },

	  _updateEmoticonResultsCount: function _updateEmoticonResultsCount(count) {
	    ChatInputStore.set({ emoticon_results_count: count });
	  },

	  _shouldSendChatStateMessage: function _shouldSendChatStateMessage(evt) {
	    var _this = this;

	    if (evt.keyCode && evt.keyCode != 13) {
	      if (this.state.text.trim().length && !this._composing_timer && this.state.user_state === "active") {
	        this._composing_timer = setTimeout(function () {
	          _this._sendComposingStateMessage();
	        }, appConfig.composing_message_delay_timeout);
	      } else if (!this.state.text.trim().length && this.state.user_state === "composing") {
	        clearTimeout(this._composing_timer);
	        this._composing_timer = 0;
	        ChatInputActions.setUserState({
	          jid: this.state.active_chat,
	          type: "chat",
	          state: "active"
	        });
	      }
	    }
	  },

	  _sendComposingStateMessage: function _sendComposingStateMessage() {
	    ChatInputActions.setUserState({
	      jid: this.state.active_chat,
	      type: "chat",
	      state: "composing"
	    });
	  },

	  _onValueChange: function _onValueChange(evt) {
	    ChatInputActions.setMsgValue({
	      text: evt.target.value
	    });
	  },

	  _openFilePicker: function _openFilePicker(evt) {
	    evt.preventDefault();
	    if (!this.state.attachment_expanded) {
	      document.getElementById("fileInput").click();
	    }
	  },

	  _closeAttachmentInput: function _closeAttachmentInput(e) {
	    e.stopPropagation();
	    document.getElementById("fileInput").value = null;
	    ChatInputActions.closeTooltip({ type: "upload_preview" });
	    ChatInputActions.closeAttachment();
	  },

	  _validateFile: function _validateFile(file) {
	    if (file.size && file.size / 1024 / 1024 > appConfig.max_upload_size) {
	      ChatInputActions.dispatchFileError("file_too_large");
	      return false;
	    } else {
	      var reader = new FileReader();
	      reader.onload = function (e) {
	        ChatInputActions.clearErrors();
	      };
	      reader.onerror = function (e) {
	        ChatInputActions.dispatchFileError("file_is_folder");
	      };
	      reader.readAsText(file);
	      return true;
	    }
	  },

	  _handleUploadFailed: function _handleUploadFailed() {
	    ChatInputActions.dispatchFileError("unable_to_upload");
	  },

	  _onFileChosen: function _onFileChosen(evt) {
	    var file, name;
	    if (evt.type === "change") {
	      file = evt.target.files[0];
	      name = Utils.dot(file, "name");
	    } else if (evt.type === "drop") {
	      file = evt.dataTransfer.files[0];
	      name = Utils.dot(file, "name");
	    } else if (evt.type === "paste") {
	      var dataTransferItem = evt.clipboardData.items[0];
	      file = dataTransferItem.getAsFile();
	      var ext = Utils.file.get_extension_for_mime_type(dataTransferItem.type);
	      if (ext) {
	        name = "upload." + ext;
	      }
	    }

	    if (file) {
	      this._focus();
	      ChatInputActions.expandAttachment({
	        file_name: name,
	        file: file
	      });
	      this._processFile(file);
	    }
	  },

	  _focusingDisabled: function _focusingDisabled() {
	    var disabled = false;
	    if (window.HC && window.HC.Config && window.HC.Config.composeMessageDisabled) {
	      disabled = window.HC.Config.composeMessageDisabled;
	    }

	    return disabled;
	  },

	  _focusIfAllowed: function _focusIfAllowed() {
	    _.defer(_.bind(function () {
	      if (!this._focusingDisabled() && !_.contains(["INPUT", "TEXTAREA"], document.activeElement.tagName) && document.querySelectorAll(".aui-blanket").length === 0 && this._lifeCycleState === "MOUNTED") {
	        this._focus();
	      }
	    }, this));
	  },

	  _focus: function _focus() {
	    var selection = getSelection();
	    if (!this._isFocused() && !selection) {
	      this.refs.message.getDOMNode().focus();
	    }
	  },

	  _isFocused: function _isFocused() {
	    return this.refs.message.getDOMNode() === document.activeElement;
	  },

	  _onFileNameClick: function _onFileNameClick(evt) {
	    evt.target.setSelectionRange(0, evt.target.value.lastIndexOf("."));
	  },

	  _onFileNameChange: function _onFileNameChange(evt) {
	    ChatInputActions.changeFileName({ file_name: evt.target.value });
	  },

	  _onSmileyClick: function _onSmileyClick(evt) {
	    var className = evt.currentTarget.className;
	    if (! ~className.indexOf(" selected")) {
	      evt.currentTarget.className += " selected";
	    } else {
	      evt.currentTarget.className = className.replace(" selected", "");
	    }
	    ChatInputActions.toggleTooltip({
	      type: "smiley_selector",
	      data: {
	        smileys: this.state.smileys,
	        prefix: this.state.path_prefix,
	        user_is_admin: this.state.user_is_admin
	      }
	    });
	  },

	  _processFile: function _processFile(file) {
	    var src = window.URL.createObjectURL(file),
	        filetype = file.type.split("/")[0],
	        subtype = file.type.split("/")[1];

	    if (subtype == "pdf") {
	      filetype = "text";
	    } else if (subtype == "xml" || subtype == "rtf" || subtype.indexOf("photoshop") !== -1) {
	      filetype = "application";
	    }

	    if (this._validateFile(file) && !! ~["image", "text", "video", "audio"].indexOf(filetype)) {
	      ChatInputActions.openTooltip({
	        type: "upload_preview",
	        data: {
	          file: {
	            src: src,
	            filetype: filetype
	          }
	        }
	      });
	    }
	  },

	  _handleDragEnter: function _handleDragEnter(evt) {
	    evt.stopPropagation();
	    evt.preventDefault();
	  },

	  _handleDrop: function _handleDrop(evt) {
	    evt.stopPropagation();
	    evt.preventDefault();

	    this._onFileChosen(evt);
	  },

	  _onPaste: function _onPaste(evt) {
	    if (evt.clipboardData.items) {
	      var dataTransferItem = evt.clipboardData.items[0];
	      if (dataTransferItem && dataTransferItem.kind === "file") {
	        this._onFileChosen(evt);
	      }
	    }
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ChatPanelStrings = __webpack_require__(22);
	var cx = React.addons.classSet;

	module.exports = React.createClass({

	  displayName: "Expando",

	  getInitialState: function getInitialState() {
	    return {
	      truncated: true,
	      height: 0
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    var height = $(this.refs.expando.getDOMNode()).height();
	    this.setState({
	      height: height,
	      truncated: height > 120 ? true : false
	    });
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.props.setScroll();
	  },

	  render: function render() {
	    var contentClasses = cx({
	      "msg-line": true,
	      truncatable: true,
	      truncated: this.state.truncated,
	      expanded: !this.state.truncated
	    });
	    var toggleClasses = cx({
	      truncatable: true,
	      truncated: this.state.truncated,
	      expanded: !this.state.truncated,
	      hidden: this.state.height <= 120
	    });
	    return React.createElement(
	      "div",
	      { className: contentClasses + " " + this.props.className },
	      React.createElement(
	        "div",
	        { className: "truncate-wrap" },
	        React.createElement(
	          "div",
	          { ref: "expando", className: "msg-wrap" },
	          this.props.children
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: toggleClasses },
	        React.createElement(
	          "a",
	          { name: "truncate", onClick: this._toggleTruncatedText },
	          this.state.truncated ? ChatPanelStrings.show_more : ChatPanelStrings.show_less
	        )
	      )
	    );
	  },

	  _toggleTruncatedText: function _toggleTruncatedText(e) {
	    e.preventDefault();
	    this.setState({
	      truncated: !this.state.truncated
	    });
	  }
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ChatPanelStrings = __webpack_require__(22);
	var AppDispatcher = __webpack_require__(1);

	module.exports = React.createClass({

	  displayName: "FailedMessage",

	  _resendMessage: function _resendMessage() {
	    AppDispatcher.dispatch("resend-message", this.props.msg);
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "msg-fail-container" },
	      this.props.children,
	      React.createElement(
	        "div",
	        { className: "msg-fail" },
	        React.createElement("span", { className: "aui-icon aui-icon-small aui-iconfont-error" }),
	        React.createElement(
	          "span",
	          { className: "msg-fail-retry" },
	          ChatPanelStrings.failed_message,
	          " · ",
	          React.createElement(
	            "button",
	            { className: "aui-button aui-button-link", onClick: this._resendMessage },
	            ChatPanelStrings.failed_message_retry
	          )
	        )
	      )
	    );
	  }
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * FileViewerActions
	 */

	var AppDispatcher = __webpack_require__(1);

	var FileViewerActions = module.exports = {

	  openInFileViewer: function openInFileViewer(data) {
	    AppDispatcher.dispatch("open-in-file-viewer", data);
	  }

	};;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var RoomsNavItemPerson = __webpack_require__(294);
	var RoomsNavItemRoom = __webpack_require__(295);
	var UnreadBadge = __webpack_require__(296);

	module.exports = React.createClass({

	  displayName: "RoomsNavItem",

	  render: function render() {
	    var unreadBadge = this.props.room.unreadCount > 0 && !this.props.active ? React.createElement(UnreadBadge, { unreadCount: this.props.room.unreadCount, hasMention: this.props.room.hasMention }) : "";

	    var roomLink = /@conf/.test(this.props.room.jid) ? React.createElement(RoomsNavItemRoom, { name: this.props.room.name,
	      privacy: this.props.room.privacy,
	      switchTab: this.props.switchTab,
	      active: this.props.active,
	      unreadBadge: unreadBadge }) : React.createElement(RoomsNavItemPerson, { presence: this.props.room.presence.show,
	      status: this.props.room.presence.status,
	      mobile: this.props.room.mobile,
	      switchTab: this.props.switchTab,
	      active: this.props.active,
	      name: this.props.room.name,
	      unreadBadge: unreadBadge });

	    var cx = React.addons.classSet;
	    var classes = cx({
	      "hc-tab": true,
	      "aui-nav-selected": this.props.active,
	      "hc-has-badge": this.props.room.unreadCount > 0,
	      "hc-room": /@conf/.test(this.props.room.jid),
	      "hc-person": !/@conf/.test(this.props.room.jid)
	    });
	    return React.createElement(
	      "li",
	      { draggable: "true", className: classes, onDragStart: this.props.dragStart, onDragEnd: this.props.dragEnd, "data-jid": this.props.jid },
	      roomLink,
	      React.createElement(
	        "a",
	        { className: "hc-tab-close", onClick: this.props.closeTab },
	        React.createElement("span", { className: "aui-icon hipchat-icon-xsmall hc-close-icon icon-close" })
	      )
	    );
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "LobbyNavItem",

	  mixins: [PureRenderMixin],

	  render: function render() {
	    var cx = React.addons.classSet;
	    var classes = cx({
	      "hc-tab": true,
	      "aui-nav-selected": this.props.active
	    });
	    return React.createElement(
	      "li",
	      { className: classes },
	      React.createElement(
	        "a",
	        { className: "aui-nav-item aui-nav-selected", onClick: this.props.switchTab },
	        React.createElement("span", { className: "aui-icon hipchat-icon-small icon-lobby" }),
	        React.createElement(
	          "span",
	          { className: "aui-nav-item-label" },
	          "Lobby"
	        )
	      )
	    );
	  }
	});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  scroll_up_to_unread: "Scroll up to unread",
	  scroll_down_to_unread: "Scroll down to unread"
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  online_help: "Online Help",
	  keyboard_shortcuts: "Keyboard Shortcuts"
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);

	var dispatcher = __webpack_require__(1);

	var FormsStore = (function (Store) {
	  function FormsStore() {
	    _classCallCheck(this, FormsStore);

	    this.data = {
	      allRooms: null,
	      activeRooms: null,
	      activeChat: null,
	      activeChatParticipants: [],
	      roster: null,
	      currentUser: null
	    };

	    this.registerListeners();
	  }

	  _inherits(FormsStore, Store);

	  _prototypeProperties(FormsStore, null, {
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        dispatcher.register({
	          "updated:allRooms": function (rooms) {
	            _this.set({
	              allRooms: rooms
	            });
	          },
	          "updated:activeRooms": function (rooms) {
	            _this.set({
	              activeRooms: rooms
	            });
	            if (_this.data.activeChat) {
	              _this.handleActiveChatUpdate(_this.data.activeChat.jid);
	            }
	          },
	          "updated:roster": function (roster) {
	            _this.set({
	              roster: roster
	            });
	          },
	          "updated:current_user": function (current_user) {
	            _this.set({
	              currentUser: current_user
	            });
	          },
	          "updated:active_chat": function (active_chat_jid) {
	            _this.handleActiveChatUpdate(active_chat_jid);
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleActiveChatUpdate: {
	      value: function handleActiveChatUpdate(active_chat_jid) {
	        var active_chat,
	            active_chat_participants = [];
	        if (this.data.activeRooms) {
	          active_chat = this.data.activeRooms[active_chat_jid];
	          if (active_chat) {
	            this.set({
	              activeChat: active_chat
	            });
	            _.each(active_chat.participants, function (group) {
	              _.each(group, function (jid) {
	                active_chat_participants.push(jid);
	              });
	            });
	          }
	          if (active_chat_participants.length) {
	            this.set({
	              activeChatParticipants: active_chat_participants
	            });
	          }
	        }
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return FormsStore;
	})(Store);

	module.exports = new FormsStore();

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  description: {
	    create_room_description: "Name your room after your team, project, or anything really.",
	    privacy: "Everyone already here will still have access. To add more people, you'll have to invite them.",
	    public_room: "Anyone can join this room and invite others.",
	    private_room: "Only people invited to this room may join.",
	    choose_people_to_remove: "Choose people to remove from this room:"
	  },
	  label: {
	    room_name: "Room name:",
	    room_topic: "Topic:",
	    these_people: "These people:",
	    message: "Message:",
	    new_room_name: "New room name:",
	    public_room: "Open room",
	    private_room: "Private room"
	  },
	  button: {
	    try_again: "Try again"
	  },
	  success: {
	    users_invited: "Users invited.",
	    users_removed: "Users removed.",
	    rename_flag: "Room renamed.",
	    privacy_changed: function privacy_changed(room, privacy) {
	      return "" + room + " is now " + privacy + ".";
	    },
	    room_created: function room_created(name) {
	      return "" + name + " created.";
	    }
	  },
	  fail: {
	    invite_fail: "Couldn't invite users.",
	    remove_users: "Couldn't remove users.",
	    no_users_flag: "Choose someone to remove.",
	    rename_flag: "Couldn't rename the room.",
	    create_room: "Couldn't create the room.",
	    change_privacy_flag: "Couldn't change the room privacy."
	  }
	};

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  create_room_form: {
	    no_room_name: "Every room needs a name.",
	    room_already_exists: "Someone beat you to it. That room name is taken.",
	    name_too_long: "Whoa! That name is way too long."
	  },
	  rename_room_form: {
	    no_room_name: "Every room needs a name.",
	    same_name: "That's the same name.",
	    name_too_long: "Whoa! That name is way too long.",
	    room_already_exists: "Someone beat you to it. That room name is taken." },
	  invite_users_form: {
	    no_users: "Who do you want to invite?",
	    msg_too_long: "Whoa! That message is too long."
	  }
	};

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var invariant = __webpack_require__(239);

	module.exports = {

	  componentDidMount: function componentDidMount() {
	    invariant(this.refs.form, "ref.form must be defined to use form reset mixin");
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.refs.form.getDOMNode().reset();
	    if ($(this.refs.form.getDOMNode()).find(".aui-select2")) {
	      AJS.$(this.refs.form.getDOMNode()).find(".aui-select2").auiSelect2("data", null);
	    }
	  }

	};

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AuiFieldSet = __webpack_require__(298),
	    strings = __webpack_require__(270),
	    AuiRadio = __webpack_require__(275);

	module.exports = React.createClass({

	  displayName: "RoomPrivacyRadios",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      public_desc: strings.description.public_room,
	      private_desc: strings.description.private_room
	    };
	  },

	  render: function render() {
	    return React.createElement(
	      AuiFieldSet,
	      { label: "Access:" },
	      React.createElement(AuiRadio, { id: "public-room", key: _.uniqueId(), name: "privacy", defaultChecked: this.props.defaultChecked == "public", value: "public", label: strings.label.public_room, description: this.props.public_desc }),
	      React.createElement(AuiRadio, { id: "private-room", key: _.uniqueId(), name: "privacy", defaultChecked: this.props.defaultChecked == "private", value: "private", label: strings.label.private_room, description: this.props.private_desc })
	    );
	  }

	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var AuiCheckbox = __webpack_require__(299);

	module.exports = React.createClass({

	  displayName: "AuiCheckBoxField",

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "checkbox" },
	      React.createElement(AuiCheckbox, _extends({ key: _.uniqueId() }, this.props)),
	      React.createElement(
	        "label",
	        { htmlFor: this.props.id, key: _.uniqueId() },
	        this.props.label
	      )
	    );
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AuiInput = __webpack_require__(300);

	module.exports = React.createClass({

	  displayName: "AuiRadio",

	  _getDescription: function _getDescription() {
	    if (this.props.description) {
	      return React.createElement(
	        "div",
	        { className: "description" },
	        this.props.description
	      );
	    }
	  },

	  render: function render() {
	    var name = this.props.name || this.props.id;
	    var description = this._getDescription();

	    return React.createElement(
	      "div",
	      { className: "radio" },
	      React.createElement(AuiInput, { type: "radio", ref: "radio", id: this.props.id, name: name, value: this.props.value, defaultChecked: this.props.defaultChecked, onChange: this.props.onChange }),
	      React.createElement(
	        "label",
	        { htmlFor: this.props.id },
	        this.props.label
	      ),
	      description
	    );
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AuiFormFieldGroup = __webpack_require__(301),
	    AuiSelect2Input = __webpack_require__(302);

	module.exports = React.createClass({

	  displayName: "AuiSelect2FieldGroup",

	  render: function render() {
	    return React.createElement(
	      AuiFormFieldGroup,
	      this.props,
	      React.createElement(AuiSelect2Input, { id: this.props.id,
	        size: this.props.size,
	        name: this.props.name,
	        placeholder: this.props.placeholder,
	        multiple: this.props.multiple,
	        data: this.props.data })
	    );
	  }

	});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AuiFormFieldGroup = __webpack_require__(301),
	    AuiTextArea = __webpack_require__(303);

	module.exports = React.createClass({

	  displayName: "AuiTextAreaFieldGroup",

	  render: function render() {
	    return React.createElement(
	      AuiFormFieldGroup,
	      this.props,
	      React.createElement(AuiTextArea, this.props)
	    );
	  }
	});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var AuiFormFieldGroup = __webpack_require__(301),
	    AuiInput = __webpack_require__(300);

	module.exports = React.createClass({

	  displayName: "AuiInputFieldGroup",

	  focus: function focus() {
	    this.refs.input.focus();
	  },

	  render: function render() {
	    return React.createElement(
	      AuiFormFieldGroup,
	      this.props,
	      React.createElement(AuiInput, _extends({ ref: "input" }, this.props))
	    );
	  }

	});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {

	  getInitialState: function getInitialState() {
	    return {
	      shouldUpdate: true,
	      total: 0,
	      displayStart: 0,
	      displayEnd: 0
	    };
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var shouldUpdate = !(nextProps.visibleStart >= this.state.displayStart && nextProps.visibleEnd <= this.state.displayEnd) || nextProps.total !== this.state.total;

	    if (shouldUpdate) {
	      this.setState({
	        shouldUpdate: shouldUpdate,
	        total: nextProps.total,
	        displayStart: nextProps.displayStart,
	        displayEnd: nextProps.displayEnd
	      });
	    } else {
	      this.setState({ shouldUpdate: false });
	    }
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    return this.state.shouldUpdate;
	  }

	};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PresenceIcon = __webpack_require__(118);

	module.exports = React.createClass({

	  displayName: "LobbyItem",

	  render: function render() {

	    var type = /@conf/.test(this.props.item.jid) ? "groupchat" : "chat",
	        icon = type == "groupchat" ? React.createElement("span", { className: "aui-icon hipchat-icon-small icon-" + this.props.item.privacy }) : React.createElement(PresenceIcon, { presence: this.props.item.presence ? this.props.item.presence.show : "unknown" });

	    return React.createElement(
	      "tr",
	      null,
	      React.createElement(
	        "td",
	        { className: "hc-lobby-list-icon" },
	        icon
	      ),
	      React.createElement(
	        "td",
	        { className: "hc-lobby-list-name" },
	        React.createElement(
	          "a",
	          { onClick: this.props.onChatOpen.bind(null, { jid: this.props.item.jid, name: this.props.item.name, type: type }) },
	          this.props.item.name
	        )
	      ),
	      React.createElement("td", { className: "hc-lobby-list-actions" })
	    );
	  }
	});
	/*
	   <button className="aui-button aui-button-subtle">
	     <span className="aui-icon aui-icon-small aui-iconfont-more">More </span>
	   </button>
	*/

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PersonStatus = __webpack_require__(304),
	    Utils = __webpack_require__(4),
	    PresenceIcon = __webpack_require__(118),
	    strings = __webpack_require__(305);

	module.exports = React.createClass({

	  displayName: "RightSideBarPerson",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onPersonClick: _.noop
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    this._createTooltip();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this._destroyTooltip();
	  },

	  _getStatus: function _getStatus() {
	    var status;
	    if (this.props.user.presence.show === "away") {
	      status = React.createElement(PersonStatus, { status: this.props.user.presence.status, idleTime: this.props.user.presence.idleTime });
	    } else if (this.props.user.presence.status) {
	      status = React.createElement(PersonStatus, { status: this.props.user.presence.status });
	    }
	    return status;
	  },

	  _onClick: function _onClick() {
	    this.props.onPersonClick(this.props.user.jid);
	  },

	  render: function render() {
	    var status = this._getStatus(),
	        link_classes,
	        cx = React.addons.classSet;

	    link_classes = cx({
	      "hc-roster-link": true,
	      "hc-roster-admin": this.props.isAdmin
	    });

	    var rosterItemClasses = cx({
	      "hc-roster-item": true,
	      "aui-nav-selected": this.props.active
	    });

	    return React.createElement(
	      "li",
	      { className: rosterItemClasses, onClick: this._onClick, ref: "person" },
	      React.createElement(
	        "div",
	        { className: "aui-nav-item" },
	        React.createElement(PresenceIcon, { presence: this.props.user.presence.show, active: true }),
	        React.createElement(
	          "a",
	          { className: link_classes, onDoubleClick: this.props.onChatOpen.bind(null, { jid: this.props.user.jid, name: this.props.user.name }) },
	          this.props.user.name
	        ),
	        status
	      )
	    );
	  },

	  _createTooltip: function _createTooltip() {
	    var _this = this;

	    AJS.$(this.refs.person.getDOMNode()).tooltip({
	      title: function () {
	        var title = "" + _this.props.user.name + "\n" + ("@" + _this.props.user.mention_name + "\n") + ("" + strings.status + " " + Utils.user.get_user_status(_this.props.user.presence.show));
	        if (_this.props.isAdmin) {
	          title += "\n" + strings.admin;
	        }
	        if (_this.props.user.presence.show === "dnd" && _this.props.user.presence.status) {
	          title += "\n" + strings.message + " " + _this.props.user.presence.status;
	        }
	        return title;
	      }
	    });
	  },

	  _destroyTooltip: function _destroyTooltip() {
	    AJS.$(this.refs.person.getDOMNode()).off();
	  }
	});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var strings = __webpack_require__(306),
	    DialogActions = __webpack_require__(28),
	    InlineDialogActions = __webpack_require__(51);

	module.exports = React.createClass({

	  displayName: "RightSideBarRosterEmptyState",

	  _openInviteUsers: function _openInviteUsers(e) {
	    e.preventDefault();
	    DialogActions.showInviteUsersDialog();
	  },

	  _openInviteTeam: function _openInviteTeam(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    InlineDialogActions.showInviteNewUsersForm();
	  },

	  _getInviteMessage: function _getInviteMessage() {
	    if (this.props.room_privacy === "private" && !this.props.isAdmin) {
	      return false;
	    } else {
	      var inviteAction = this._openInviteUsers,
	          inviteCTA = strings.invite_someone;

	      if (_.size(this.props.users) === 1) {
	        inviteAction = this._openInviteTeam;
	        inviteCTA = strings.invite_teammates;
	      }

	      return React.createElement(
	        "div",
	        { className: "hc-tab-es-msg" },
	        React.createElement(
	          "div",
	          null,
	          strings.chat_empty_sub
	        ),
	        React.createElement(
	          "a",
	          { className: "hc-tab-es-invite", onClick: inviteAction },
	          inviteCTA
	        )
	      );
	    }
	  },

	  render: function render() {
	    var inviteMessage = this._getInviteMessage();
	    return React.createElement(
	      "div",
	      { className: "hc-tab-es" },
	      React.createElement("div", { className: "hc-tab-es-img roster" }),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-title" },
	        strings.chat_empty
	      ),
	      inviteMessage
	    );
	  }
	});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  members: "members",
	  guests: "guests",
	  guest_access_enabled: "Room publicly available"
	};

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AnalyticsDispatcher = __webpack_require__(7);

	var RightPanelActions = {

	  filesMounted: function filesMounted(data) {
	    AnalyticsDispatcher.dispatch("analytics-files-mount", data);
	  },

	  rosterMounted: function rosterMounted(data) {
	    AnalyticsDispatcher.dispatch("analytics-roster-mount", data);
	  }
	};

	module.exports = RightPanelActions;

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Utils = __webpack_require__(4);
	var FileViewerActions = __webpack_require__(264);
	var fileHelper = __webpack_require__(90);

	module.exports = React.createClass({

	  displayName: "RightSideBarFile",

	  render: function render() {
	    return React.createElement(
	      "li",
	      { className: "hc-roster-item" },
	      React.createElement(
	        "div",
	        { className: "aui-nav-item", title: fileHelper.basename(this.props.file.name) },
	        React.createElement(
	          "a",
	          { className: "hc-file-link", target: "_blank", href: this.props.file.file_url, onClick: this._onClick },
	          React.createElement("span", { className: "hc-file-icon " + this.props.file.icon_class }),
	          React.createElement(
	            "span",
	            { className: "hc-file-name" },
	            fileHelper.basename(this.props.file.name)
	          )
	        ),
	        React.createElement(
	          "span",
	          { className: "hc-roster-user-name" },
	          this.props.file.user_name
	        ),
	        React.createElement(
	          "span",
	          { className: "hc-roster-date" },
	          this.props.time
	        )
	      )
	    );
	  },

	  _onClick: function _onClick(evt) {
	    if (fileHelper.shouldOpenFileViewer(evt)) {
	      evt.preventDefault();
	      FileViewerActions.openInFileViewer(this.props.file);
	    }
	  }
	});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var strings = __webpack_require__(306);

	module.exports = React.createClass({

	  displayName: "RightSideBarEmptyFileState",

	  _openFilePicker: function _openFilePicker(evt) {
	    evt.preventDefault();
	    document.getElementById("fileInput").click();
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-tab-es" },
	      React.createElement("div", { className: "hc-tab-es-img files" }),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-title" },
	        strings.no_files
	      ),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-msg" },
	        React.createElement(
	          "a",
	          { href: "#", onClick: this._openFilePicker },
	          strings.share_a_file
	        )
	      )
	    );
	  }
	});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "RightSideBarLink",

	  mixins: [PureRenderMixin],

	  render: function render() {
	    return React.createElement(
	      "li",
	      { className: "hc-roster-item" },
	      React.createElement(
	        "div",
	        { className: "aui-nav-item", title: this.props.url },
	        React.createElement(
	          "a",
	          { className: "hc-link", target: "_blank", href: this.props.url },
	          this.props.display_url
	        ),
	        React.createElement(
	          "span",
	          { className: "hc-roster-user-name" },
	          this.props.name
	        ),
	        React.createElement(
	          "span",
	          { className: "hc-roster-date" },
	          this.props.time
	        )
	      )
	    );
	  }
	});

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var strings = __webpack_require__(306);

	module.exports = React.createClass({

	  displayName: "RightSideBarLinksEmptyState",

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-tab-es" },
	      React.createElement("div", { className: "hc-tab-es-img links" }),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-title" },
	        strings.no_links
	      ),
	      React.createElement(
	        "div",
	        { className: "hc-tab-es-msg" },
	        strings.share_a_link
	      )
	    );
	  }
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var DialogActions = __webpack_require__(28),
	    strings = __webpack_require__(260),
	    RoomDropDownActions = __webpack_require__(54);

	module.exports = React.createClass({

	  displayName: "RoomDropDown",

	  shouldComponentUpdate: function shouldComponentUpdate() {
	    //this is REAL nasty, but I have no choice…
	    try {
	      this.getDOMNode();
	      return true;
	    } catch (e) {
	      return false;
	    }
	  },

	  componentDidMount: function componentDidMount() {
	    // Can't use standard React events here since AUI has mutated the drop-down.
	    // React can't operate on DOM that's mutated since it's been created. In most
	    // other cases, we should stick with React events.
	    this._bindEvents();
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this._bindEvents();
	  },

	  componentWillUpdate: function componentWillUpdate() {
	    this._removeEventListeners();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    this._removeEventListeners();
	  },

	  _bindEvents: function _bindEvents() {
	    document.querySelector(".create-room-action > a").addEventListener("click", this._onCreateRoomClick);
	    if (this._isNotArchived()) {
	      document.querySelector(".change-topic-action > a").addEventListener("click", this._onChangeTopicClick);
	      if (this.props.isAdmin) {
	        document.querySelector(".integrations-user-action > a").addEventListener("click", this._onIntegrationsClick);
	        document.querySelector(".change-privacy-action > a").addEventListener("click", this._onChangePrivacyClick);
	        document.querySelector(".rename-room-action > a").addEventListener("click", this._onRenameRoomClick);
	        document.querySelector(".delete-room-action > a").addEventListener("click", this._onDeleteRoomClick);
	        document.querySelector(".enable-guest-action > a").addEventListener("click", this._onEnableGuestClick);
	        document.querySelector(".disable-guest-action > a").addEventListener("click", this._onDisableGuestClick);
	        if (!parseInt(this.props.room.is_archived, 10) && this.props.room.is_archived != "") {
	          document.querySelector(".archive-room-action > a").addEventListener("click", this._onArchiveRoomClick);
	        } else if (this.props.room.is_archived == "" || !!parseInt(this.props.room.is_archived, 10)) {
	          document.querySelector(".unarchive-room-action > a").addEventListener("click", this._onUnarchiveRoomClick);
	        }
	      }
	      if (this._allowInviteUser()) {
	        document.querySelector(".invite-user-action > a").addEventListener("click", this._onInviteUserClick);
	      }
	      if (this._allowRemoveUser()) {
	        document.querySelector(".remove-user-action > a").addEventListener("click", this._onRemoveUserClick);
	      }
	    } else if (this.props.isAdmin && this._isArchived()) {
	      document.querySelector(".unarchive-room-action > a").addEventListener("click", this._onUnarchiveRoomClick);
	    }
	  },

	  _removeEventListeners: function _removeEventListeners() {
	    document.querySelector(".integrations-user-action > a").removeEventListener("click", this._onIntegrationsClick);
	    document.querySelector(".create-room-action > a").removeEventListener("click", this._onCreateRoomClick);
	    document.querySelector(".invite-user-action > a").removeEventListener("click", this._onInviteUserClick);
	    document.querySelector(".remove-user-action > a").removeEventListener("click", this._onRemoveUserClick);
	    document.querySelector(".change-topic-action > a").removeEventListener("click", this._onChangeTopicClick);
	    document.querySelector(".change-privacy-action > a").removeEventListener("click", this._onChangePrivacyClick);
	    document.querySelector(".rename-room-action > a").removeEventListener("click", this._onRenameRoomClick);
	    document.querySelector(".delete-room-action > a").removeEventListener("click", this._onDeleteRoomClick);
	    document.querySelector(".archive-room-action > a").removeEventListener("click", this._onArchiveRoomClick);
	    document.querySelector(".unarchive-room-action > a").removeEventListener("click", this._onUnarchiveRoomClick);
	    document.querySelector(".enable-guest-action > a").removeEventListener("click", this._onEnableGuestClick);
	    document.querySelector(".disable-guest-action > a").removeEventListener("click", this._onDisableGuestClick);
	  },

	  _onIntegrationsClick: function _onIntegrationsClick() {
	    RoomDropDownActions.openIntegrations(this.props.roomId);
	    AJS.$("#" + this.props.triggerId).trigger("aui-button-invoke");
	  },

	  _onCreateRoomClick: function _onCreateRoomClick() {
	    DialogActions.showCreateRoomDialog();
	  },

	  _onArchiveRoomClick: function _onArchiveRoomClick() {
	    DialogActions.showArchiveRoomDialog({ archive: true });
	  },

	  _onUnarchiveRoomClick: function _onUnarchiveRoomClick() {
	    DialogActions.showArchiveRoomDialog({ archive: false });
	  },

	  _onInviteUserClick: function _onInviteUserClick() {
	    DialogActions.showInviteUsersDialog();
	  },

	  _onRemoveUserClick: function _onRemoveUserClick() {
	    DialogActions.showRemoveUsersDialog();
	  },

	  _onChangeTopicClick: function _onChangeTopicClick() {
	    RoomDropDownActions.editTopic();
	  },

	  _onChangePrivacyClick: function _onChangePrivacyClick() {
	    DialogActions.showRoomPrivacyDialog({
	      jid: this.props.room.jid,
	      name: this.props.room.name,
	      privacy: this.props.room.privacy
	    });
	  },

	  _onRenameRoomClick: function _onRenameRoomClick() {
	    DialogActions.showRenameRoomDialog({
	      jid: this.props.room.jid,
	      name: this.props.room.name
	    });
	  },

	  _onDeleteRoomClick: function _onDeleteRoomClick() {
	    DialogActions.showDeleteRoomDialog({
	      jid: this.props.room.jid,
	      name: this.props.room.name
	    });
	  },

	  _allowInviteUser: function _allowInviteUser() {
	    return (this.props.privacy === "public" || this.props.privacy === "private" && this.props.isAdmin) && this._isNotArchived();
	  },

	  _allowRemoveUser: function _allowRemoveUser() {
	    return this.props.privacy === "private" && this.props.isAdmin && this._isNotArchived();
	  },

	  _isArchived: function _isArchived() {
	    return this.props.room.is_archived == "" || !!parseInt(this.props.room.is_archived, 10);
	  },

	  _isNotArchived: function _isNotArchived() {
	    return !parseInt(this.props.room.is_archived, 10) && this.props.room.is_archived != "";
	  },

	  _archiveEnabled: function _archiveEnabled() {
	    return this.props.isAdmin && this._isNotArchived();
	  },

	  _unarchiveEnabled: function _unarchiveEnabled() {
	    return this.props.isAdmin && this._isArchived();
	  },

	  _onEnableGuestClick: function _onEnableGuestClick(e) {
	    e.preventDefault();
	    RoomDropDownActions.enableGuestAccess({ jid: this.props.room.jid });
	  },

	  _onDisableGuestClick: function _onDisableGuestClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    DialogActions.showDisableGuestAccessDialog();
	  },

	  render: function render() {

	    var cx = React.addons.classSet,
	        enable_guest_classes = cx({
	      interactive: true,
	      "aui-dropdown2-radio": true,
	      disabled: !this.props.isAdmin,
	      checked: this.props.room.guest_url
	    }),
	        disable_guest_classes = cx({
	      interactive: true,
	      "aui-dropdown2-radio": true,
	      disabled: !this.props.isAdmin,
	      checked: !this.props.room.guest_url
	    });
	    return React.createElement(
	      "div",
	      { className: "aui-dropdown2 aui-style-default aui-dropdown2-in-header", id: "room-actions-drop-down", "aria-hidden": "true", "data-dropdown2-alignment": "right", "data-dropdown2-hide-location": "#room-actions-drop-down" },
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "integrations-user-action" },
	            React.createElement(
	              "a",
	              { title: strings.integrations, className: this.props.isAdmin && this._isNotArchived() ? "" : "disabled", "aria-disabled": this.props.isAdmin && this._isNotArchived() ? "false" : "true", href: "javascript:void(0)" },
	              strings.integrations
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "create-room-action" },
	            React.createElement(
	              "a",
	              { title: strings.create_new_room, href: "javascript:void(0)" },
	              strings.create_new_room
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "invite-user-action" },
	            React.createElement(
	              "a",
	              { title: strings.invite_users, className: this._allowInviteUser() ? "" : "disabled", "aria-disabled": this._allowInviteUser() ? "false" : "true", href: "javascript:void(0)" },
	              strings.invite_users
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "remove-user-action" },
	            React.createElement(
	              "a",
	              { title: strings.remove_users, className: this._allowRemoveUser() ? "" : "disabled", "aria-disabled": this._allowRemoveUser() ? "false" : "true", href: "javascript:void(0)" },
	              strings.remove_users
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "enable-guest-action" },
	            React.createElement(
	              "a",
	              { title: strings.enable_guest, className: enable_guest_classes, "aria-disabled": this.props.isAdmin ? "false" : "true" },
	              strings.enable_guest
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "disable-guest-action" },
	            React.createElement(
	              "a",
	              { title: strings.disable_guest, className: disable_guest_classes, "aria-disabled": this.props.isAdmin ? "false" : "true" },
	              strings.disable_guest
	            )
	          )
	        )
	      ),
	      React.createElement(
	        "div",
	        { className: "aui-dropdown2-section" },
	        React.createElement(
	          "ul",
	          null,
	          React.createElement(
	            "li",
	            { className: "archive-room-action" },
	            React.createElement(
	              "a",
	              { title: strings.archive, className: this._archiveEnabled() ? "" : "disabled", "aria-disabled": this._archiveEnabled() ? "false" : "true", href: "javascript:void(0)" },
	              strings.archive
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "unarchive-room-action" },
	            React.createElement(
	              "a",
	              { title: strings.unarchive, className: this._unarchiveEnabled() ? "" : "disabled", "aria-disabled": this._unarchiveEnabled() ? "false" : "true", href: "javascript:void(0)" },
	              strings.unarchive
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "change-topic-action" },
	            React.createElement(
	              "a",
	              { title: strings.change_topic, className: this._isNotArchived() ? "" : "disabled", "aria-disabled": this._isNotArchived() ? "false" : "true", href: "javascript:void(0)" },
	              strings.change_topic
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "change-privacy-action" },
	            React.createElement(
	              "a",
	              { title: strings.change_privacy, className: this.props.isAdmin && this._isNotArchived() ? "" : "disabled", "aria-disabled": this.props.isAdmin && this._isNotArchived() ? "false" : "true", href: "javascript:void(0)" },
	              strings.change_privacy
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "delete-room-action" },
	            React.createElement(
	              "a",
	              { title: strings["delete"], className: this.props.isAdmin && this._isNotArchived() ? "" : "disabled", "aria-disabled": this.props.isAdmin && this._isNotArchived() ? "false" : "true", href: "javascript:void(0)" },
	              strings["delete"]
	            )
	          ),
	          React.createElement(
	            "li",
	            { className: "rename-room-action" },
	            React.createElement(
	              "a",
	              { title: strings.rename, className: this.props.isAdmin && this._isNotArchived() ? "" : "disabled", "aria-disabled": this.props.isAdmin && this._isNotArchived() ? "false" : "true", href: "javascript:void(0)" },
	              strings.rename
	            )
	          )
	        )
	      )
	    );
	  }

	});

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var Store = __webpack_require__(43);
	var AppDispatcher = __webpack_require__(1);
	var Utils = __webpack_require__(4);
	var Strings = __webpack_require__(307);
	var Promise = __webpack_require__(69).Promise;

	var ChatInputStore = (function (Store) {
	  function ChatInputStore() {
	    var _this = this;

	    _classCallCheck(this, ChatInputStore);

	    this.data = this.getDefaults();

	    this.local = {
	      // map of jid to unsent text values (used when user types
	      unsentText: {}
	    };

	    this.registerListeners();

	    this.emoticonsDeferred = Utils.promise.defer();
	    this.smileysDeferred = Utils.promise.defer();

	    this.emoticonsDeferred.promise.then(function (data) {
	      _this.data.path_prefix = data.path_prefix;
	      _this.data.emoticons = data.icons;
	    });
	    this.smileysDeferred.promise.then(function (data) {
	      var unique = _.indexBy(_.indexBy(data, "file"), "shortcut");
	      _this.data.smileys = unique;
	    });

	    this.handlePromises();
	  }

	  _inherits(ChatInputStore, Store);

	  _prototypeProperties(ChatInputStore, null, {
	    getDefaults: {
	      value: function getDefaults() {
	        return {
	          text: "",
	          active_chat: null,
	          attachment_expanded: false,
	          file_name: "",
	          file: null,
	          uploading: false,
	          chat_type: "",
	          message_id: 0,
	          path_prefix: "",
	          smileys: {},
	          file_error: false,
	          file_error_message: "",
	          user_state: "active",
	          user_is_admin: false,
	          mention_text: "",
	          mention_selected_item: 0,
	          mention_results_count: 0,
	          emoticon_text: "",
	          emoticon_selected_item: 0,
	          emoticon_results_count: 0
	        };
	      },
	      writable: true,
	      configurable: true
	    },
	    registerListeners: {
	      value: function registerListeners() {
	        var _this = this;

	        AppDispatcher.register({
	          "updated:current_user": function (data) {
	            _this.data.user_is_admin = data.is_admin;
	          },
	          "open-room": function (data) {
	            _this.set({
	              active_chat: data.jid,
	              chat_type: data.type
	            });
	          },
	          "close-room": function (data) {
	            _this.deleteUnsentText(data.jid);
	          },
	          "updated:activeRooms": function (rooms) {
	            if (rooms[_this.data.active_chat]) {
	              _this.set("chat_type", rooms[_this.data.active_chat].type);
	            }
	          },
	          "send-message": function () {
	            _this.data.message_id++;
	            _this.set({
	              text: "",
	              message_id: _this.data.message_id,
	              user_state: "active"
	            });
	          },
	          "clear-messages": function () {
	            _this.set({
	              text: ""
	            });
	          },
	          "updated:smileys": function (data) {
	            _this.smileysDeferred.resolve(data);
	          },
	          "updated:emoticons": function (data) {
	            _this.emoticonsDeferred.resolve(data);
	          },
	          "initial-select-room": function (jid) {
	            _this.set({
	              active_chat: jid
	            });
	          },
	          "before:updated:active_chat": function (jid) {
	            _this.setUnsentText(_this.data.active_chat);
	          },
	          "updated:active_chat": function (jid) {
	            _this.set({
	              active_chat: jid,
	              chat_type: Utils.room.detect_chat_type(jid),
	              text: _this.getUnsentText(jid)
	            });
	          },
	          "upload-file": function () {
	            _this.set("uploading", true);
	          },
	          "upload-successful": function (data) {
	            _this.set({
	              uploading: false,
	              attachment_expanded: false,
	              file: null,
	              file_name: "",
	              text: ""
	            });
	            _this.handleUploadSuccess(data.responseXML);
	          },
	          "upload-failed": function () {
	            _this.set({
	              uploading: false
	            });
	          },
	          "set-message-value": function (text) {
	            _this.set("text", text);
	          },
	          "expand-attachment": function (data) {
	            _this.set({
	              attachment_expanded: true,
	              file: data.file,
	              file_name: data.file_name
	            });
	          },
	          "close-attachment": function () {
	            _this.set({
	              attachment_expanded: false,
	              file: null,
	              file_name: "",
	              file_error: false
	            });
	          },
	          "sender-clicked": function (data) {
	            if (_this.data.text.indexOf(data.mention + " ") == -1) {
	              _this.set({
	                text: _this.data.text + data.mention + " "
	              });
	            }
	          },
	          "change-filename": function (data) {
	            _this.set("file_name", data.file_name);
	          },
	          "smiley-chosen": function (data) {
	            _this.set({
	              text: _this.data.text + data.shortcut + " "
	            });
	          },
	          "set-user-state": function (data) {
	            if (_this.data.user_state != data.state) {
	              _this.data.user_state = data.state;
	            }
	          },
	          "file-error": function (message_key) {
	            _this.set({
	              file_error: true,
	              file_error_message: Strings[message_key]
	            });
	          },
	          "clear-errors": function () {
	            _this.set({
	              file_error: false,
	              file_error_message: ""
	            });
	          }
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    setUnsentText: {
	      value: function setUnsentText(jid) {
	        // testing for undefined and empty string before setting value
	        // NOTE:  We should probably have a constant for our lobby jid construct
	        if (jid && jid.length > 0 && jid !== "lobby") {
	          this.local.unsentText[jid] = this.data.text;
	        }
	      },
	      writable: true,
	      configurable: true
	    },
	    getUnsentText: {
	      value: function getUnsentText(jid) {
	        return this.local.unsentText[jid] || "";
	      },
	      writable: true,
	      configurable: true
	    },
	    deleteUnsentText: {
	      value: function deleteUnsentText(jid) {
	        delete this.local.unsentText[jid];
	      },
	      writable: true,
	      configurable: true
	    },
	    handlePromises: {
	      value: function handlePromises() {
	        var _this = this;

	        Promise.all([this.emoticonsDeferred.promise, this.smileysDeferred.promise]).then(function () {
	          _this.set({
	            smileys: _this.data.smileys,
	            emoticons: _this.data.emoticons
	          });
	        });
	      },
	      writable: true,
	      configurable: true
	    },
	    handleUploadSuccess: {
	      value: function handleUploadSuccess(xml) {
	        AppDispatcher.dispatch("send-upload-message", {
	          type: this.data.chat_type,
	          jid: this.data.active_chat,
	          file_info: xml
	        });
	      },
	      writable: true,
	      configurable: true
	    }
	  });

	  return ChatInputStore;
	})(Store);

	module.exports = new ChatInputStore();

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AutoCompleteBox = __webpack_require__(308);
	var RosterStore = __webpack_require__(91);
	var Utils = __webpack_require__(4);
	var PresenceIcon = __webpack_require__(118);

	function mentionFilter(mention_text, user) {
	  var name = user.name.toLowerCase().split(" "),
	      partialNameMatch = false;
	  for (var i = 0; i < name.length; i++) {
	    if (name[i].indexOf(mention_text) === 0) {
	      partialNameMatch = true;
	      break;
	    }
	  }
	  return user.mention_name && user.mention_name.toLowerCase().indexOf(mention_text) === 0 || partialNameMatch || user.name && user.name.replace(" ", "").toLowerCase().indexOf(mention_text) === 0;
	}

	module.exports = React.createClass({

	  displayName: "MentionAutoComplete",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      mention_text: "",
	      selected_item: 0,
	      defaultAtMentions: [{
	        name: "Available room members",
	        mention_name: "here",
	        presence: {
	          show: "chat"
	        }
	      }, {
	        name: "All room members",
	        mention_name: "all",
	        presence: {
	          show: "chat"
	        }
	      }, {
	        name: "HipChat",
	        mention_name: "HipChat",
	        presence: {
	          show: "chat"
	        }
	      }]
	    };
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.mention_text !== nextProps.mention_text || this.props.selected_item !== nextProps.selected_item || Utils.dot(this.props, "presence.show") !== Utils.dot(nextProps, "presence.show");
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.props.updateMentionResultsCount(this._resultsCount);
	  },

	  render: function render() {
	    var mention_text = this.props.mention_text.toLowerCase(),
	        filtered = [],
	        sortFilter,
	        room,
	        defaultAtMentions;
	    defaultAtMentions = this.props.defaultAtMentions;
	    sortFilter = function (i, opts) {
	      // 1st order sort on default @-mentions
	      var prefix1 = opts.prioritizeDefault ? _.find(defaultAtMentions, { name: i.name }) ? "0" : "1" : "";
	      // 2nd order sort on room participants
	      var prefix2 = _.find(room.participants.members.concat(room.participants.guests), { jid: i.jid }) ? "0" : "1";
	      // 3rd order sort on start of name match
	      var prefix3 = i.name.toLowerCase().indexOf(mention_text) === 0 ? "0" : "1";
	      return prefix1 + prefix2 + prefix3 + i.name.toLowerCase();
	    };
	    if (mention_text === "@") {
	      room = RosterStore.getAll();
	      filtered = _.sortBy(this.props.defaultAtMentions.concat(room.participants.members).concat(room.participants.guests), function (x) {
	        return sortFilter(x, { prioritizeDefault: true });
	      });
	    } else if (mention_text !== "") {
	      mention_text = mention_text.slice(1);
	      room = RosterStore.getAll();
	      if (room.active_chat_privacy === "public") {
	        filtered = _.sortBy(_.filter(_.toArray(room.users).concat(this.props.defaultAtMentions), mentionFilter.bind(null, mention_text)), sortFilter);
	      } else {
	        filtered = _.sortBy(_.filter(room.participants.members.concat(this.props.defaultAtMentions), mentionFilter.bind(null, mention_text)), sortFilter);
	      }
	    }
	    this._resultsCount = filtered.length;
	    return React.createElement(
	      "div",
	      { className: "hc-mention-ac hc-chat-input-autocomplete" },
	      React.createElement(AutoCompleteBox, { key: "mention_auto_complete", list: filtered,
	        textarea_ref: this.props.textarea_ref,
	        getItemContent: this._getItemContent,
	        selected_item: this.props.selected_item,
	        onItemSelected: this.props.onMentionSelected,
	        ref: "acBox" })
	    );
	  },

	  _getItemContent: function _getItemContent(user) {
	    return React.createElement(
	      "div",
	      { className: "hc-ac-row" },
	      React.createElement(
	        "div",
	        { className: "hc-ac-preview" },
	        React.createElement(PresenceIcon, { presence: user.presence.show, active: "false" })
	      ),
	      React.createElement(
	        "span",
	        { className: "hc-ac-name" },
	        user.name
	      ),
	      React.createElement(
	        "span",
	        { className: "hc-ac-mention-name" },
	        "@",
	        user.mention_name
	      )
	    );
	  }

	});

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AutoCompleteBox = __webpack_require__(308);
	var ChatInputStore = __webpack_require__(290);
	var Utils = __webpack_require__(4);

	var getInputState = function getInputState() {
	  var cis = ChatInputStore.getAll(),
	      emoticons = _.toArray(cis.emoticons),
	      defaultEmoticons = _.filter(_.toArray(cis.smileys), function (smileys) {
	    return smileys.shortcut.indexOf("(") === 0;
	  });
	  emoticons = _.sortBy(emoticons.concat(defaultEmoticons), "shortcut");
	  return {
	    emoticons: emoticons,
	    path_prefix: cis.path_prefix
	  };
	};

	module.exports = React.createClass({

	  displayName: "EmoticonAutoComplete",

	  getInitialState: function getInitialState() {
	    return getInputState();
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      emoticon_text: "",
	      selected_item: 0
	    };
	  },

	  componentDidMount: function componentDidMount() {
	    ChatInputStore.on("change:emoticons", this._onChange);
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    ChatInputStore.off("change:emoticons", this._onChange);
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	    return this.props.emoticon_text !== nextProps.emoticon_text || this.props.selected_item !== nextProps.selected_item;
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    this.props.updateEmoticonResultsCount(this._resultsCount);
	  },

	  render: function render() {
	    var emoticon_text = this.props.emoticon_text.toLowerCase(),
	        filtered = [];
	    if (emoticon_text.indexOf("(") === 0) {
	      filtered = _.filter(this.state.emoticons, function (emoticon) {
	        return emoticon.shortcut.indexOf(emoticon_text) === 0;
	      });
	    }
	    this._resultsCount = filtered.length;
	    return React.createElement(
	      "div",
	      { className: "hc-emoticon-ac hc-chat-input-autocomplete" },
	      React.createElement(AutoCompleteBox, { key: "emoticon_auto_complete", list: filtered,
	        textarea_ref: this.props.textarea_ref,
	        getItemContent: this._getItemContent,
	        selected_item: this.props.selected_item,
	        onItemSelected: this.props.onEmoticonSelected,
	        ref: "acBox" })
	    );
	  },

	  _getItemContent: function _getItemContent(emoticon) {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "div",
	        { className: "hc-ac-preview" },
	        React.createElement("img", { src: this.state.path_prefix + "/" + emoticon.file, width: "20px" })
	      ),
	      React.createElement(
	        "span",
	        { className: "hc-ac-name" },
	        emoticon.shortcut
	      )
	    );
	  },

	  _onChange: function _onChange() {
	    this.setState(getInputState());
	  }

	});

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var invariant = __webpack_require__(239);
	var AppDispatcher = __webpack_require__(1);
	var SmileySelector = __webpack_require__(309);
	var UploadPreview = __webpack_require__(310);

	module.exports = React.createClass({

	  displayName: "Tooltip",

	  componentWillMount: function componentWillMount() {
	    invariant(_.contains(["upload_preview", "smiley_selector"], this.props.type), "Type prop must be upload_preview or smiley_select");

	    this.toggle = _.bind(function () {
	      this._onToggle({ type: this.props.type });
	    }, this);
	    this.outside_click_dismiss = !! ~["smiley_selector"].indexOf(this.props.type);
	  },

	  componentDidMount: function componentDidMount() {
	    AppDispatcher.register({
	      "toggle-tooltip": this._onToggle,
	      "close-tooltip": this._onClose,
	      "open-tooltip": this._onOpen
	    });
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    var elem = this.getDOMNode();
	    AppDispatcher.unregister({
	      "toggle-tooltip": this._onToggle,
	      "close-tooltip": this._onClose,
	      "open-tooltip": this._onOpen
	    });
	    [].map.call(elem.querySelectorAll(".file-preview"), function (element) {
	      return element;
	    }).forEach(function (preview) {
	      preview.removeEventListener("load", this._positionTooltip);
	    }, this);
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (this.state.is_visible) {
	      this._positionTooltip();
	    }
	  },

	  getInitialState: function getInitialState() {
	    return {
	      is_visible: false
	    };
	  },

	  _getToolTip: function _getToolTip(type) {
	    var tooltip_types = {
	      smiley_selector: SmileySelector,
	      upload_preview: UploadPreview
	    };

	    return tooltip_types[type];
	  },

	  render: function render() {

	    var ToolTip = this._getToolTip(this.props.type);

	    return React.createElement(
	      "div",
	      { className: "hc-tooltip " + (this.state.is_visible ? "" : "hidden") },
	      React.createElement(
	        "div",
	        { className: "hc-tooltip-content" },
	        React.createElement(ToolTip, { data: this.state.data })
	      ),
	      React.createElement("div", { className: "aui-inline-dialog-arrow arrow aui-css-arrow" })
	    );
	  },

	  _onClose: function _onClose(args) {
	    if (!this.isMounted()) {
	      return;
	    }
	    if (args.type == this.props.type) {
	      if (this.outside_click_dismiss) {
	        document.removeEventListener("click", this.toggle);
	      }
	      this.setState({
	        is_visible: false
	      });
	    }
	    this._resetArrow();
	  },

	  _onOpen: function _onOpen(args) {
	    if (args.type == this.props.type) {
	      if (this.outside_click_dismiss) {
	        document.addEventListener("click", this.toggle);
	      }
	      this.setState({
	        is_visible: true,
	        data: args.data
	      });
	    }
	  },

	  _onToggle: function _onToggle(args) {
	    if (this.state.is_visible) {
	      this._onClose(args);
	    } else {
	      this._onOpen(args);
	    }
	  },

	  _resetArrow: function _resetArrow() {
	    this.getDOMNode().querySelector(".arrow").classList.remove("right");
	  },

	  _positionTooltip: function _positionTooltip() {
	    var elem = this.getDOMNode(),
	        parent = elem.parentElement,
	        bottom = parent.offsetHeight + 8,
	        left = -elem.offsetWidth / 2 + parent.offsetWidth / 2;
	    elem.style.bottom = bottom + "px";
	    elem.style.left = left + "px";

	    if (elem.getBoundingClientRect().right > window.innerWidth) {
	      // Tooltip extends beyond right side of window
	      elem.style.left = elem.offsetLeft - 8 - (elem.getBoundingClientRect().right - window.innerWidth) + "px";
	      elem.querySelector(".arrow").classList.add("right");
	    }

	    [].map.call(elem.querySelectorAll(".file-preview"), function (element) {
	      return element;
	    }).forEach(function (preview) {
	      preview.addEventListener("load", this._positionTooltip);
	    }, this);
	  }

	});

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PresenceIcon = __webpack_require__(118),
	    PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "RoomsNavItemPerson",

	  mixins: [PureRenderMixin],

	  render: function render() {
	    return React.createElement(
	      "a",
	      { className: "aui-nav-item", title: this.props.status, onClick: this.props.switchTab },
	      React.createElement(PresenceIcon, { active: true, presence: this.props.presence, mobile: this.props.mobile }),
	      React.createElement(
	        "span",
	        { className: "room-name" },
	        this.props.name
	      ),
	      this.props.unreadBadge
	    );
	  }
	});

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "RoomsNavItemRoom",

	  mixins: [PureRenderMixin],

	  render: function render() {
	    return React.createElement(
	      "a",
	      { className: "aui-nav-item", onClick: this.props.switchTab, title: this.props.name },
	      React.createElement("span", { className: "aui-icon hipchat-icon-small icon-" + (this.props.privacy || "dot") }),
	      React.createElement(
	        "span",
	        { className: "room-name" },
	        this.props.name
	      ),
	      this.props.unreadBadge
	    );
	  }
	});

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "UnreadBadge",

	  mixins: [PureRenderMixin],

	  render: function render() {
	    var cx = React.addons.classSet;
	    var classes = cx({
	      "aui-badge": this.props.unreadCount > 0,
	      "hc-badge": true,
	      "hc-mention": this.props.hasMention ? true : false
	    });
	    return React.createElement(
	      "span",
	      { className: classes },
	      this.props.unreadCount
	    );
	  }
	});

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};

	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canMutationObserver = typeof window !== 'undefined'
	    && window.MutationObserver;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;

	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }

	    var queue = [];

	    if (canMutationObserver) {
	        var hiddenDiv = document.createElement("div");
	        var observer = new MutationObserver(function () {
	            var queueList = queue.slice();
	            queue.length = 0;
	            queueList.forEach(function (fn) {
	                fn();
	            });
	        });

	        observer.observe(hiddenDiv, { attributes: true });

	        return function nextTick(fn) {
	            if (!queue.length) {
	                hiddenDiv.setAttribute('yes', 'no');
	            }
	            queue.push(fn);
	        };
	    }

	    if (canPost) {
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);

	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }

	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "AuiFormFieldSet",

	  render: function render() {
	    return React.createElement(
	      "fieldset",
	      { className: "group" },
	      React.createElement(
	        "legend",
	        null,
	        React.createElement(
	          "label",
	          { htmlFor: this.props.id },
	          this.props.label
	        )
	      ),
	      this.props.children
	    );
	  }

	});

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	module.exports = React.createClass({

	  displayName: "AuiCheckbox",

	  propTypes: {
	    defaultChecked: React.PropTypes.bool,
	    onChange: React.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      value: true,
	      defaultChecked: false,
	      onChange: function () {}
	    };
	  },

	  render: function render() {
	    this.props.name = this.props.name || this.props.id;
	    return React.createElement("input", _extends({ type: "checkbox", className: "checkbox" }, this.props));
	  }
	});

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	module.exports = React.createClass({

	  displayName: "AuiInput",

	  propTypes: {
	    onChange: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onBlur: React.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      type: "text",
	      onChange: function () {},
	      onFocus: function () {},
	      onBlur: function () {}
	    };
	  },

	  focus: function focus() {
	    this.refs.input.getDOMNode().focus();
	  },

	  render: function render() {

	    var name = this.props.name || this.props.id;
	    var classes = this.props.size ? this.props.type + " " + this.props.size : this.props.type;

	    return React.createElement("input", _extends({}, this.props, { ref: "input", className: classes, name: name }));
	  }

	});

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "AuiFormFieldGroup",

	  _getDescription: function _getDescription() {
	    if (this.props.description) {
	      return React.createElement(
	        "div",
	        { className: "description" },
	        this.props.description
	      );
	    }
	  },

	  _getRequiredIcon: function _getRequiredIcon() {
	    if (this.props.required) {
	      return React.createElement(
	        "span",
	        { className: "aui-icon icon-required" },
	        " required"
	      );
	    }
	  },

	  getError: function getError() {
	    if (this.props.error) {
	      return React.createElement(
	        "div",
	        { className: "error" },
	        this.props.error
	      );
	    }
	  },

	  render: function render() {
	    var name = this.props.name || this.props.id;
	    var description = this._getDescription();
	    var requiredIcon = this._getRequiredIcon();
	    var error = this.getError();

	    return React.createElement(
	      "div",
	      { className: "field-group" },
	      React.createElement(
	        "label",
	        { htmlFor: name },
	        this.props.label,
	        requiredIcon
	      ),
	      this.props.children,
	      description,
	      error
	    );
	  }

	});

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "AuiSelect2Input",

	  propTypes: {
	    multiple: React.PropTypes.bool,
	    placeholder: React.PropTypes.string,
	    data: React.PropTypes.array
	  },

	  componentDidMount: function componentDidMount() {
	    this._setupSelect();
	  },

	  componentWillUnmount: function componentWillUnmount() {
	    AJS.$(this.getDOMNode()).auiSelect2("destroy");
	    AJS.$("#select2-drop-mask").remove();
	    AJS.$(".select2-sizer").remove();
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      multiple: false,
	      placeholder: "",
	      data: []
	    };
	  },

	  _setupSelect: function _setupSelect() {
	    AJS.$(this.getDOMNode()).auiSelect2(this._getSelectOptions());
	  },

	  _getSelectOptions: function _getSelectOptions() {
	    return {
	      multiple: this.props.multiple,
	      placeholder: this.props.placeholder,
	      data: this.props.data
	    };
	  },

	  render: function render() {
	    var name = this.props.name || this.props.id,
	        classes = this.props.size ? "aui-select2 " + this.props.size : "aui-select2";

	    return React.createElement("input", { type: "hidden", id: this.props.id, className: classes, name: name });
	  }
	});

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	module.exports = React.createClass({

	  displayName: "AuiTextarea",

	  propTypes: {
	    onChange: React.PropTypes.func,
	    onFocus: React.PropTypes.func,
	    onBlur: React.PropTypes.func
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      onChange: function () {},
	      onFocus: function () {},
	      onBlur: function () {}
	    };
	  },

	  render: function render() {

	    var name = this.props.name || this.props.id;
	    var classes = this.props.size ? "textarea " + this.props.size : "textarea";

	    return React.createElement("textarea", _extends({}, this.props, { className: classes, name: name }));
	  }

	});

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var PureRenderMixin = React.addons.PureRenderMixin;

	module.exports = React.createClass({

	  displayName: "RightSideBarPersonStatus",

	  mixins: [PureRenderMixin],

	  _get_status_msg: function _get_status_msg() {
	    var msg;

	    if (this.props.status && this.props.idleTime) {
	      msg = this.props.idleTime + " - " + this.props.status;
	    } else if (this.props.status && !this.props.idleTime) {
	      msg = this.props.status;
	    } else {
	      msg = this.props.idleTime;
	    }
	    return msg;
	  },

	  render: function render() {
	    return React.createElement(
	      "div",
	      { className: "hc-roster-status" },
	      this._get_status_msg()
	    );
	  }
	});

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  emoticon_more_link: "More…",
	  custom_emoticon_link: "Custom",
	  admin: "Admin",
	  status: "Status:",
	  message: "Message:"
	};

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  no_files: "No files shared yet",
	  no_links: "No links shared yet",
	  share_a_file: "Share the first file",
	  share_a_link: "Recently shared links will appear here.",
	  invite_someone: "Invite people to join!",
	  invite_teammates: "Invite your team to join!",
	  chat_empty: "You're the only one here",
	  chat_empty_sub: "Feeling lonely?"
	};

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var appConfig = __webpack_require__(3);

	module.exports = {
	  file_too_large: "This file is too large. Try a file that's " + appConfig.max_upload_size + " MB or smaller.",
	  file_is_folder: "This looks like a folder; zip it up and try again.",
	  unable_to_upload: "Something went wrong uploading that file."
	};

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AutoComplete = __webpack_require__(311);
	var TextareaCaretMirror = __webpack_require__(312);

	module.exports = React.createClass({

	  displayName: "AutoCompleteBox",

	  render: function render() {
	    var self = this;
	    var results = this.props.list.map(function (item, idx) {
	      var isSelected = false;
	      if (idx === self.props.selected_item) isSelected = true;
	      return React.createElement(AutoComplete, { item: item,
	        key: idx,
	        idx: idx,
	        getItemContent: self.props.getItemContent,
	        selected: isSelected,
	        onItemSelected: self.props.onItemSelected,
	        ref: "item-" + idx });
	    });
	    var classes = React.addons.classSet({
	      "aui-inline-dialog": true,
	      show: this.props.list.length > 0
	    });
	    var caretOptions = {
	      textarea_ref: this.props.textarea_ref,
	      ac_box_ref: this.refs.acBox,
	      ac_box_container_ref: this.refs.container,
	      arrow_offset_left: 30,
	      arrow_offset_top: 10
	    };
	    var styles = {
	      left: caretOptions.arrow_offset_left + "px",
	      top: caretOptions.arrow_offset_top + "px"
	    };
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "div",
	        { className: classes, style: styles, ref: "acBox" },
	        React.createElement(
	          "div",
	          { className: "aui-inline-dialog-contents contents", ref: "container" },
	          React.createElement(
	            "ul",
	            null,
	            results
	          )
	        ),
	        React.createElement("div", { className: "aui-inline-dialog-arrow arrow aui-css-arrow aui-bottom-arrow" })
	      ),
	      React.createElement(TextareaCaretMirror, { ref: "caret", opts: caretOptions })
	    );
	  }

	});

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var AppDispatcher = __webpack_require__(1),
	    TooltipActions = __webpack_require__(57),
	    TooltipStrings = __webpack_require__(305);

	module.exports = React.createClass({

	  displayName: "TooltipTypeSmileySelector",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      data: {
	        smileys: {},
	        prefix: "",
	        user_is_admin: false
	      }
	    };
	  },

	  render: function render() {
	    var _this = this;

	    var custom_link;
	    if (this.props.data.user_is_admin) {
	      custom_link = React.createElement(
	        "div",
	        { className: "hc-float-right menu-link" },
	        React.createElement(
	          "a",
	          { target: "_blank", href: "/admin/emoticons" },
	          TooltipStrings.custom_emoticon_link
	        )
	      );
	    }

	    return React.createElement(
	      "div",
	      { className: "smileys-selection" },
	      _.map(this.props.data.smileys, function (smiley) {
	        return React.createElement("img", { "data-shortcut": smiley.shortcut, height: smiley.height, width: smiley.width, onClick: _this._onSmileyClick, key: smiley.file, src: _this.props.data.prefix + "/" + smiley.file });
	      }, this),
	      React.createElement("div", { className: "clear" }),
	      React.createElement(
	        "div",
	        { className: this.props.data.user_is_admin ? "hc-float-left menu-link" : "hc-text-center menu-link" },
	        React.createElement(
	          "a",
	          { target: "_blank", href: "/emoticons" },
	          TooltipStrings.emoticon_more_link
	        )
	      ),
	      custom_link
	    );
	  },

	  _onSmileyClick: function _onSmileyClick(e) {
	    TooltipActions.smileyChosen({ shortcut: e.currentTarget.getAttribute("data-shortcut") });
	  }

	});

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "TooltipTypeUploadPreview",

	  getDefaultProps: function getDefaultProps() {
	    return {
	      data: {
	        file: {
	          src: "",
	          filetype: ""
	        }
	      }
	    };
	  },

	  render: function render() {
	    var previewMarkup = {

	      image: React.createElement("img", { className: "file-preview", src: this.props.data.file.src }),

	      text: React.createElement("iframe", { className: "file-preview", src: this.props.data.file.src }),

	      video: React.createElement("video", { className: "file-preview", src: this.props.data.file.src, autoPlay: true, muted: true }),

	      audio: React.createElement("audio", { className: "file-preview", src: this.props.data.file.src, controls: true })

	    };

	    return previewMarkup[this.props.data.file.filetype] || React.createElement("div", null);
	  }

	});

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = React.createClass({

	  displayName: "AutoComplete",

	  render: function render() {
	    var classes = React.addons.classSet({
	      "hc-autocomplete-item": true,
	      "hc-autocomplete-item-selected": this.props.selected
	    });
	    return React.createElement(
	      "li",
	      { className: classes, onClick: this._selectItem },
	      this.props.getItemContent(this.props.item)
	    );
	  },

	  _selectItem: function _selectItem() {
	    this.props.onItemSelected(this.props.item);
	  }

	});

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Utils = __webpack_require__(4);

	module.exports = React.createClass({

	  displayName: "TextAreaCaretMirror",

	  componentDidMount: function componentDidMount() {
	    this._stylesToMirror = [
	    // Box Styles.
	    "boxSizing", "height", "width", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop"

	    // Font stuff.
	    , "fontFamily", "fontSize", "fontStyle", "fontVariant", "fontWeight"

	    // Spacing etc.
	    , "wordSpacing", "letterSpacing", "lineHeight", "textDecoration", "textIndent", "textTransform"

	    // The direction.
	    , "direction"];
	  },

	  componentDidUpdate: function componentDidUpdate() {
	    if (!this.refs.caret) {
	      return;
	    }var $acBox = $(this.props.opts.ac_box_ref.getDOMNode());
	    var $caret = $(this.refs.caret.getDOMNode());
	    $acBox.css({
	      left: $caret.position().left - this.props.opts.arrow_offset_left + "px",
	      top: $caret.position().top - $(this.props.opts.ac_box_container_ref.getDOMNode()).height() - this.props.opts.arrow_offset_top + "px"
	    });
	  },

	  render: function render() {
	    if (!this.props.opts.textarea_ref) {
	      return React.createElement("div", null);
	    }var $src = $(this.props.opts.textarea_ref.getDOMNode());
	    if ($src.length < 1) {
	      return React.createElement("div", null);
	    }var caretPosn = Utils.getCaretPosition($src.get(0)),
	        pre = $src.val().substring(0, caretPosn),
	        post = $src.val().substring(caretPosn),
	        containerStyles = {
	      position: "absolute",
	      overflow: "auto",
	      whiteSpace: "pre-wrap",
	      wordWrap: "break-word",
	      top: 0,
	      left: -9999
	    },
	        caretStyles = {
	      position: "absolute"
	    };
	    for (var i = 0, style; style = this._stylesToMirror[i]; i++) {
	      containerStyles[style] = $src.css(style);
	    }
	    return React.createElement(
	      "div",
	      { style: containerStyles },
	      pre,
	      React.createElement("span", { ref: "caret", className: "hc-textarea-caret", style: caretStyles }),
	      post
	    );
	  }

	});

/***/ }
/******/ ])
//# sourceMappingURL=app.js.map
